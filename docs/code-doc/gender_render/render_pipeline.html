<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gender_render.render_pipeline API documentation</title>
<meta name="description" content="Contains the functions to render templates and pronoun data, bundled together in a class.
This is the submodule where pronoun data and templates …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gender_render.render_pipeline</code></h1>
</header>
<section id="section-intro">
<p>Contains the functions to render templates and pronoun data, bundled together in a class.
This is the submodule where pronoun data and templates finally come together.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/blob/433a58f714a292d2db8600f87c34b1bd42547c37/src/gender_render/render_pipeline.py#L0-L179" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contains the functions to render templates and pronoun data, bundled together in a class.
This is the submodule where pronoun data and templates finally come together.
&#34;&#34;&#34;

import typing
import copy

from . import parse_pronoun_data
from . import parse_templates
from . import warnings
from . import errors
from . import gender_nouns
from .handle_context_values import ContextValues


class GRenderer:
    &#34;&#34;&#34;Bundles methods that are part of the rendering pipeline.&#34;&#34;&#34;
    @staticmethod
    def id_resolution(
            # regarding the given template:
            parsed_template: parse_templates.ParsedTemplateRefined,
            ids_used_in_template: typing.FrozenSet[str],
            template_contains_unspecified_ids: bool,

            # regarding the given pronoun data:
            grpd: parse_pronoun_data.GRPD) -&gt; (parse_templates.ParsedTemplateRefined, parse_pronoun_data.GRPD):
        &#34;&#34;&#34;Takes a parsed template (as returned by the GRParser-pipeline), a set of all ids used in the template, a
        boolean indicating whether the template contains tags with unspecified ids, and the pronoun data to render it.
        Performs the id resolution steps described by the specification, with the corresponding errors, and returns
        the modified template and grpd.
        No modifications are performed in-place.&#34;&#34;&#34;

        ids_matched_without_modification = False

        # create deep copies of input values to later modify them:
        new_template = copy.deepcopy(parsed_template)
        new_grpd = copy.deepcopy(grpd)

        # only individual pronoun data is given:
        grpd_is_actually_idpd = &#34;&#34; in grpd
        if grpd_is_actually_idpd:

            # no ids are used in the template:
            if len(ids_used_in_template) == 0:
                new_grpd = {&#34;usr&#34;: new_grpd[&#34;&#34;]}
                for i in range(1, len(new_template), 2):
                    new_template[i][&#34;id&#34;] = &#34;usr&#34;

            # all tags have the same id:
            elif len(ids_used_in_template) == 1 and not template_contains_unspecified_ids:
                single_id_in_template, = ids_used_in_template
                new_grpd = {single_id_in_template: new_grpd[&#34;&#34;]}

            # there is more than one id used in the template:
            else:
                raise errors.IdResolutionError(&#34;The given template contains more than one id, but the given pronoun &#34;
                                               + &#34;data is individual pronoun data, meaning it has no specified id.&#34;)

        # the grpd contains only one id:
        elif len(grpd) == 1:

            # no ids are used in the template:
            if len(ids_used_in_template) == 0:
                for i in range(1, len(new_template), 2):
                    new_template[i][&#34;id&#34;] = list(grpd.keys())[0]

            # all tags have the same id:
            elif len(ids_used_in_template) == 1 and not template_contains_unspecified_ids:
                if list(ids_used_in_template)[0] != list(grpd.keys())[0]:
                    raise errors.IdResolutionError(&#34;The pronoun contains only pronouns for one id, and the template &#34;
                                                   + &#34;also contains only one id, but they both differ.&#34;)
                else:
                    ids_matched_without_modification = True

            # there is more than one id used in the template:
            else:
                raise errors.IdResolutionError(&#34;The given template contains exactly one id, but the given pronoun &#34;
                                               + &#34;contains multiple different ids.&#34;)

        # the grpd contains more than one id:
        else:

            # all tags have ids assigned:
            if not template_contains_unspecified_ids:
                if not frozenset(grpd.keys()).issuperset(ids_used_in_template):
                    raise errors.IdResolutionError(&#34;All tags have ids assigned (more than one id, in summa) and the &#34;
                                                   + &#34;pronoun data contains several ids as well, but they do not &#34;
                                                   + &#34;match.&#34;)
                else:
                    ids_matched_without_modification = True

            # not all tags have ids assigned:
            else:
                if len(grpd) != len(ids_used_in_template) + 1:
                    raise errors.IdResolutionError(&#34;Some tags don&#39;t have ids, and the amount of different ids used in &#34;
                                                   + &#34;the template does not equal the amount of ids in the pronoun &#34;
                                                   + &#34;data, minus one.&#34;)
                else:
                    # there is one id more in the pronoun data than there is in the template:
                    if frozenset(grpd.keys()).issuperset(ids_used_in_template):
                        missing_id_value = list(frozenset(grpd.keys()) - ids_used_in_template)[0]
                        for i in range(1, len(new_template), 2):
                            if &#34;id&#34; not in new_template[i]:
                                new_template[i][&#34;id&#34;] = missing_id_value
                    else:
                        raise errors.IdResolutionError(&#34;The template contains tags without an id value and the &#34;
                                                       + &#34;pronoun data contains one more id than the template, but &#34;
                                                       + &#34;the ids of template and pronoun data do not match.&#34;)

        # raise a warning if template or pronoun data had to be modified:
        if not ids_matched_without_modification:
            warnings.WarningManager.raise_warning(None, warnings.IdMatchingNecessaryWarning)

        return new_template, new_grpd

    @staticmethod
    def resolve_addressing(parsed_template: parse_templates.ParsedTemplateRefined,
                           grpd: parse_pronoun_data.GRPD) -&gt; (parse_templates.ParsedTemplateRefined,
                                                              parse_pronoun_data.GRPD):
        &#34;&#34;&#34;Accepts a parsed template with a piece of gender*render pronoun data, both with matching id values,
        and returns a modified copy of the template in which the implications of the gender-addressing property are
        already applied and the grpd.&#34;&#34;&#34;

        new_template = copy.deepcopy(parsed_template)
        new_grpd = copy.deepcopy(grpd)
        for i in range(1, len(new_template), 2):
            id_value = new_template[i][&#34;id&#34;]
            if new_template[i][&#34;context&#34;] == &#34;address&#34;:
                if ContextValues.get_value(grpd, id_value, &#34;gender-addressing&#34;) in (&#34;f&#34;, &#34;false&#34;):
                    new_template[i][&#34;context&#34;] = &#34;personal-name&#34;

        return new_template, new_grpd

    @staticmethod
    def render_final_context_values(parsed_template: parse_templates.ParsedTemplateRefined,
                                    grpd: parse_pronoun_data.GRPD) -&gt; str:
        &#34;&#34;&#34;Accepts a parsed template with a piece of gender*render pronoun data, both with matching id values,
        and returns the rendered template as a string.
        This should be the last step in the rendering pipeline.&#34;&#34;&#34;

        result = &#34;&#34;
        for i in range(len(parsed_template)):
            if not i % 2:  # &lt;- is a string
                result += parsed_template[i]
            else:  # &lt;- is a tag
                id_value = parsed_template[i][&#34;id&#34;]
                context_value = parsed_template[i][&#34;context&#34;]

                if ContextValues.property_maps_directly_between_template_and_pronoun_data(context_value):
                    # render tag by looking it up in the individual pronoun data of the individual:
                    result += ContextValues.get_value(grpd, id_value, context_value)

                else:  # type(context_value) is gender_nouns.GenderedNoun:
                    # render tag by correctly gendering the noun it represents.
                    gender = ContextValues.get_value(grpd, id_value, &#34;gender-nouns&#34;)
                    result += context_value.render_noun(gender)

        return result

    @staticmethod
    def render_with_full_rendering_pipeline(
            # regarding the given template:
            parsed_template: parse_templates.ParsedTemplateRefined,
            ids_used_in_template: typing.FrozenSet[str],
            template_contains_unspecified_ids: bool,

            # regarding the given pronoun data:
            grpd: parse_pronoun_data.GRPD) -&gt; str:
        &#34;&#34;&#34;Takes a parsed template, a set of ids used in the template, a boolean specifying whether there are
        tags without specified ids in the template, and a piece of the grpd, and runs the full set of functions defined
        by GRenderer on it.
        Returns the rendered template.&#34;&#34;&#34;

        parsed_template, grpd = GRenderer.id_resolution(parsed_template, ids_used_in_template,
                                                        template_contains_unspecified_ids, grpd)
        parsed_template, grpd = GRenderer.resolve_addressing(parsed_template, grpd)
        result = GRenderer.render_final_context_values(parsed_template, grpd)

        return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gender_render.render_pipeline.GRenderer"><code class="flex name class">
<span>class <span class="ident">GRenderer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Bundles methods that are part of the rendering pipeline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/blob/433a58f714a292d2db8600f87c34b1bd42547c37/src/gender_render/render_pipeline.py#L17-L180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GRenderer:
    &#34;&#34;&#34;Bundles methods that are part of the rendering pipeline.&#34;&#34;&#34;
    @staticmethod
    def id_resolution(
            # regarding the given template:
            parsed_template: parse_templates.ParsedTemplateRefined,
            ids_used_in_template: typing.FrozenSet[str],
            template_contains_unspecified_ids: bool,

            # regarding the given pronoun data:
            grpd: parse_pronoun_data.GRPD) -&gt; (parse_templates.ParsedTemplateRefined, parse_pronoun_data.GRPD):
        &#34;&#34;&#34;Takes a parsed template (as returned by the GRParser-pipeline), a set of all ids used in the template, a
        boolean indicating whether the template contains tags with unspecified ids, and the pronoun data to render it.
        Performs the id resolution steps described by the specification, with the corresponding errors, and returns
        the modified template and grpd.
        No modifications are performed in-place.&#34;&#34;&#34;

        ids_matched_without_modification = False

        # create deep copies of input values to later modify them:
        new_template = copy.deepcopy(parsed_template)
        new_grpd = copy.deepcopy(grpd)

        # only individual pronoun data is given:
        grpd_is_actually_idpd = &#34;&#34; in grpd
        if grpd_is_actually_idpd:

            # no ids are used in the template:
            if len(ids_used_in_template) == 0:
                new_grpd = {&#34;usr&#34;: new_grpd[&#34;&#34;]}
                for i in range(1, len(new_template), 2):
                    new_template[i][&#34;id&#34;] = &#34;usr&#34;

            # all tags have the same id:
            elif len(ids_used_in_template) == 1 and not template_contains_unspecified_ids:
                single_id_in_template, = ids_used_in_template
                new_grpd = {single_id_in_template: new_grpd[&#34;&#34;]}

            # there is more than one id used in the template:
            else:
                raise errors.IdResolutionError(&#34;The given template contains more than one id, but the given pronoun &#34;
                                               + &#34;data is individual pronoun data, meaning it has no specified id.&#34;)

        # the grpd contains only one id:
        elif len(grpd) == 1:

            # no ids are used in the template:
            if len(ids_used_in_template) == 0:
                for i in range(1, len(new_template), 2):
                    new_template[i][&#34;id&#34;] = list(grpd.keys())[0]

            # all tags have the same id:
            elif len(ids_used_in_template) == 1 and not template_contains_unspecified_ids:
                if list(ids_used_in_template)[0] != list(grpd.keys())[0]:
                    raise errors.IdResolutionError(&#34;The pronoun contains only pronouns for one id, and the template &#34;
                                                   + &#34;also contains only one id, but they both differ.&#34;)
                else:
                    ids_matched_without_modification = True

            # there is more than one id used in the template:
            else:
                raise errors.IdResolutionError(&#34;The given template contains exactly one id, but the given pronoun &#34;
                                               + &#34;contains multiple different ids.&#34;)

        # the grpd contains more than one id:
        else:

            # all tags have ids assigned:
            if not template_contains_unspecified_ids:
                if not frozenset(grpd.keys()).issuperset(ids_used_in_template):
                    raise errors.IdResolutionError(&#34;All tags have ids assigned (more than one id, in summa) and the &#34;
                                                   + &#34;pronoun data contains several ids as well, but they do not &#34;
                                                   + &#34;match.&#34;)
                else:
                    ids_matched_without_modification = True

            # not all tags have ids assigned:
            else:
                if len(grpd) != len(ids_used_in_template) + 1:
                    raise errors.IdResolutionError(&#34;Some tags don&#39;t have ids, and the amount of different ids used in &#34;
                                                   + &#34;the template does not equal the amount of ids in the pronoun &#34;
                                                   + &#34;data, minus one.&#34;)
                else:
                    # there is one id more in the pronoun data than there is in the template:
                    if frozenset(grpd.keys()).issuperset(ids_used_in_template):
                        missing_id_value = list(frozenset(grpd.keys()) - ids_used_in_template)[0]
                        for i in range(1, len(new_template), 2):
                            if &#34;id&#34; not in new_template[i]:
                                new_template[i][&#34;id&#34;] = missing_id_value
                    else:
                        raise errors.IdResolutionError(&#34;The template contains tags without an id value and the &#34;
                                                       + &#34;pronoun data contains one more id than the template, but &#34;
                                                       + &#34;the ids of template and pronoun data do not match.&#34;)

        # raise a warning if template or pronoun data had to be modified:
        if not ids_matched_without_modification:
            warnings.WarningManager.raise_warning(None, warnings.IdMatchingNecessaryWarning)

        return new_template, new_grpd

    @staticmethod
    def resolve_addressing(parsed_template: parse_templates.ParsedTemplateRefined,
                           grpd: parse_pronoun_data.GRPD) -&gt; (parse_templates.ParsedTemplateRefined,
                                                              parse_pronoun_data.GRPD):
        &#34;&#34;&#34;Accepts a parsed template with a piece of gender*render pronoun data, both with matching id values,
        and returns a modified copy of the template in which the implications of the gender-addressing property are
        already applied and the grpd.&#34;&#34;&#34;

        new_template = copy.deepcopy(parsed_template)
        new_grpd = copy.deepcopy(grpd)
        for i in range(1, len(new_template), 2):
            id_value = new_template[i][&#34;id&#34;]
            if new_template[i][&#34;context&#34;] == &#34;address&#34;:
                if ContextValues.get_value(grpd, id_value, &#34;gender-addressing&#34;) in (&#34;f&#34;, &#34;false&#34;):
                    new_template[i][&#34;context&#34;] = &#34;personal-name&#34;

        return new_template, new_grpd

    @staticmethod
    def render_final_context_values(parsed_template: parse_templates.ParsedTemplateRefined,
                                    grpd: parse_pronoun_data.GRPD) -&gt; str:
        &#34;&#34;&#34;Accepts a parsed template with a piece of gender*render pronoun data, both with matching id values,
        and returns the rendered template as a string.
        This should be the last step in the rendering pipeline.&#34;&#34;&#34;

        result = &#34;&#34;
        for i in range(len(parsed_template)):
            if not i % 2:  # &lt;- is a string
                result += parsed_template[i]
            else:  # &lt;- is a tag
                id_value = parsed_template[i][&#34;id&#34;]
                context_value = parsed_template[i][&#34;context&#34;]

                if ContextValues.property_maps_directly_between_template_and_pronoun_data(context_value):
                    # render tag by looking it up in the individual pronoun data of the individual:
                    result += ContextValues.get_value(grpd, id_value, context_value)

                else:  # type(context_value) is gender_nouns.GenderedNoun:
                    # render tag by correctly gendering the noun it represents.
                    gender = ContextValues.get_value(grpd, id_value, &#34;gender-nouns&#34;)
                    result += context_value.render_noun(gender)

        return result

    @staticmethod
    def render_with_full_rendering_pipeline(
            # regarding the given template:
            parsed_template: parse_templates.ParsedTemplateRefined,
            ids_used_in_template: typing.FrozenSet[str],
            template_contains_unspecified_ids: bool,

            # regarding the given pronoun data:
            grpd: parse_pronoun_data.GRPD) -&gt; str:
        &#34;&#34;&#34;Takes a parsed template, a set of ids used in the template, a boolean specifying whether there are
        tags without specified ids in the template, and a piece of the grpd, and runs the full set of functions defined
        by GRenderer on it.
        Returns the rendered template.&#34;&#34;&#34;

        parsed_template, grpd = GRenderer.id_resolution(parsed_template, ids_used_in_template,
                                                        template_contains_unspecified_ids, grpd)
        parsed_template, grpd = GRenderer.resolve_addressing(parsed_template, grpd)
        result = GRenderer.render_final_context_values(parsed_template, grpd)

        return result</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.render_pipeline.GRenderer.id_resolution"><code class="name flex">
<span>def <span class="ident">id_resolution</span></span>(<span>parsed_template: List[Union[str, Dict[str, Union[str, List[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]], ids_used_in_template: FrozenSet[str], template_contains_unspecified_ids: bool, grpd: Dict[str, Dict[str, str]]) ‑> (typing.List[typing.Union[str, typing.Dict[str, typing.Union[str, typing.List[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]], typing.Dict[str, typing.Dict[str, str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template (as returned by the GRParser-pipeline), a set of all ids used in the template, a
boolean indicating whether the template contains tags with unspecified ids, and the pronoun data to render it.
Performs the id resolution steps described by the specification, with the corresponding errors, and returns
the modified template and grpd.
No modifications are performed in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/blob/433a58f714a292d2db8600f87c34b1bd42547c37/src/gender_render/render_pipeline.py#L19-L115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def id_resolution(
        # regarding the given template:
        parsed_template: parse_templates.ParsedTemplateRefined,
        ids_used_in_template: typing.FrozenSet[str],
        template_contains_unspecified_ids: bool,

        # regarding the given pronoun data:
        grpd: parse_pronoun_data.GRPD) -&gt; (parse_templates.ParsedTemplateRefined, parse_pronoun_data.GRPD):
    &#34;&#34;&#34;Takes a parsed template (as returned by the GRParser-pipeline), a set of all ids used in the template, a
    boolean indicating whether the template contains tags with unspecified ids, and the pronoun data to render it.
    Performs the id resolution steps described by the specification, with the corresponding errors, and returns
    the modified template and grpd.
    No modifications are performed in-place.&#34;&#34;&#34;

    ids_matched_without_modification = False

    # create deep copies of input values to later modify them:
    new_template = copy.deepcopy(parsed_template)
    new_grpd = copy.deepcopy(grpd)

    # only individual pronoun data is given:
    grpd_is_actually_idpd = &#34;&#34; in grpd
    if grpd_is_actually_idpd:

        # no ids are used in the template:
        if len(ids_used_in_template) == 0:
            new_grpd = {&#34;usr&#34;: new_grpd[&#34;&#34;]}
            for i in range(1, len(new_template), 2):
                new_template[i][&#34;id&#34;] = &#34;usr&#34;

        # all tags have the same id:
        elif len(ids_used_in_template) == 1 and not template_contains_unspecified_ids:
            single_id_in_template, = ids_used_in_template
            new_grpd = {single_id_in_template: new_grpd[&#34;&#34;]}

        # there is more than one id used in the template:
        else:
            raise errors.IdResolutionError(&#34;The given template contains more than one id, but the given pronoun &#34;
                                           + &#34;data is individual pronoun data, meaning it has no specified id.&#34;)

    # the grpd contains only one id:
    elif len(grpd) == 1:

        # no ids are used in the template:
        if len(ids_used_in_template) == 0:
            for i in range(1, len(new_template), 2):
                new_template[i][&#34;id&#34;] = list(grpd.keys())[0]

        # all tags have the same id:
        elif len(ids_used_in_template) == 1 and not template_contains_unspecified_ids:
            if list(ids_used_in_template)[0] != list(grpd.keys())[0]:
                raise errors.IdResolutionError(&#34;The pronoun contains only pronouns for one id, and the template &#34;
                                               + &#34;also contains only one id, but they both differ.&#34;)
            else:
                ids_matched_without_modification = True

        # there is more than one id used in the template:
        else:
            raise errors.IdResolutionError(&#34;The given template contains exactly one id, but the given pronoun &#34;
                                           + &#34;contains multiple different ids.&#34;)

    # the grpd contains more than one id:
    else:

        # all tags have ids assigned:
        if not template_contains_unspecified_ids:
            if not frozenset(grpd.keys()).issuperset(ids_used_in_template):
                raise errors.IdResolutionError(&#34;All tags have ids assigned (more than one id, in summa) and the &#34;
                                               + &#34;pronoun data contains several ids as well, but they do not &#34;
                                               + &#34;match.&#34;)
            else:
                ids_matched_without_modification = True

        # not all tags have ids assigned:
        else:
            if len(grpd) != len(ids_used_in_template) + 1:
                raise errors.IdResolutionError(&#34;Some tags don&#39;t have ids, and the amount of different ids used in &#34;
                                               + &#34;the template does not equal the amount of ids in the pronoun &#34;
                                               + &#34;data, minus one.&#34;)
            else:
                # there is one id more in the pronoun data than there is in the template:
                if frozenset(grpd.keys()).issuperset(ids_used_in_template):
                    missing_id_value = list(frozenset(grpd.keys()) - ids_used_in_template)[0]
                    for i in range(1, len(new_template), 2):
                        if &#34;id&#34; not in new_template[i]:
                            new_template[i][&#34;id&#34;] = missing_id_value
                else:
                    raise errors.IdResolutionError(&#34;The template contains tags without an id value and the &#34;
                                                   + &#34;pronoun data contains one more id than the template, but &#34;
                                                   + &#34;the ids of template and pronoun data do not match.&#34;)

    # raise a warning if template or pronoun data had to be modified:
    if not ids_matched_without_modification:
        warnings.WarningManager.raise_warning(None, warnings.IdMatchingNecessaryWarning)

    return new_template, new_grpd</code></pre>
</details>
</dd>
<dt id="gender_render.render_pipeline.GRenderer.resolve_addressing"><code class="name flex">
<span>def <span class="ident">resolve_addressing</span></span>(<span>parsed_template: List[Union[str, Dict[str, Union[str, List[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]], grpd: Dict[str, Dict[str, str]]) ‑> (typing.List[typing.Union[str, typing.Dict[str, typing.Union[str, typing.List[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]], typing.Dict[str, typing.Dict[str, str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts a parsed template with a piece of gender*render pronoun data, both with matching id values,
and returns a modified copy of the template in which the implications of the gender-addressing property are
already applied and the grpd.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/blob/433a58f714a292d2db8600f87c34b1bd42547c37/src/gender_render/render_pipeline.py#L117-L133" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def resolve_addressing(parsed_template: parse_templates.ParsedTemplateRefined,
                       grpd: parse_pronoun_data.GRPD) -&gt; (parse_templates.ParsedTemplateRefined,
                                                          parse_pronoun_data.GRPD):
    &#34;&#34;&#34;Accepts a parsed template with a piece of gender*render pronoun data, both with matching id values,
    and returns a modified copy of the template in which the implications of the gender-addressing property are
    already applied and the grpd.&#34;&#34;&#34;

    new_template = copy.deepcopy(parsed_template)
    new_grpd = copy.deepcopy(grpd)
    for i in range(1, len(new_template), 2):
        id_value = new_template[i][&#34;id&#34;]
        if new_template[i][&#34;context&#34;] == &#34;address&#34;:
            if ContextValues.get_value(grpd, id_value, &#34;gender-addressing&#34;) in (&#34;f&#34;, &#34;false&#34;):
                new_template[i][&#34;context&#34;] = &#34;personal-name&#34;

    return new_template, new_grpd</code></pre>
</details>
</dd>
<dt id="gender_render.render_pipeline.GRenderer.render_final_context_values"><code class="name flex">
<span>def <span class="ident">render_final_context_values</span></span>(<span>parsed_template: List[Union[str, Dict[str, Union[str, List[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]], grpd: Dict[str, Dict[str, str]]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts a parsed template with a piece of gender*render pronoun data, both with matching id values,
and returns the rendered template as a string.
This should be the last step in the rendering pipeline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/blob/433a58f714a292d2db8600f87c34b1bd42547c37/src/gender_render/render_pipeline.py#L135-L159" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def render_final_context_values(parsed_template: parse_templates.ParsedTemplateRefined,
                                grpd: parse_pronoun_data.GRPD) -&gt; str:
    &#34;&#34;&#34;Accepts a parsed template with a piece of gender*render pronoun data, both with matching id values,
    and returns the rendered template as a string.
    This should be the last step in the rendering pipeline.&#34;&#34;&#34;

    result = &#34;&#34;
    for i in range(len(parsed_template)):
        if not i % 2:  # &lt;- is a string
            result += parsed_template[i]
        else:  # &lt;- is a tag
            id_value = parsed_template[i][&#34;id&#34;]
            context_value = parsed_template[i][&#34;context&#34;]

            if ContextValues.property_maps_directly_between_template_and_pronoun_data(context_value):
                # render tag by looking it up in the individual pronoun data of the individual:
                result += ContextValues.get_value(grpd, id_value, context_value)

            else:  # type(context_value) is gender_nouns.GenderedNoun:
                # render tag by correctly gendering the noun it represents.
                gender = ContextValues.get_value(grpd, id_value, &#34;gender-nouns&#34;)
                result += context_value.render_noun(gender)

    return result</code></pre>
</details>
</dd>
<dt id="gender_render.render_pipeline.GRenderer.render_with_full_rendering_pipeline"><code class="name flex">
<span>def <span class="ident">render_with_full_rendering_pipeline</span></span>(<span>parsed_template: List[Union[str, Dict[str, Union[str, List[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]], ids_used_in_template: FrozenSet[str], template_contains_unspecified_ids: bool, grpd: Dict[str, Dict[str, str]]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template, a set of ids used in the template, a boolean specifying whether there are
tags without specified ids in the template, and a piece of the grpd, and runs the full set of functions defined
by GRenderer on it.
Returns the rendered template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/blob/433a58f714a292d2db8600f87c34b1bd42547c37/src/gender_render/render_pipeline.py#L161-L180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def render_with_full_rendering_pipeline(
        # regarding the given template:
        parsed_template: parse_templates.ParsedTemplateRefined,
        ids_used_in_template: typing.FrozenSet[str],
        template_contains_unspecified_ids: bool,

        # regarding the given pronoun data:
        grpd: parse_pronoun_data.GRPD) -&gt; str:
    &#34;&#34;&#34;Takes a parsed template, a set of ids used in the template, a boolean specifying whether there are
    tags without specified ids in the template, and a piece of the grpd, and runs the full set of functions defined
    by GRenderer on it.
    Returns the rendered template.&#34;&#34;&#34;

    parsed_template, grpd = GRenderer.id_resolution(parsed_template, ids_used_in_template,
                                                    template_contains_unspecified_ids, grpd)
    parsed_template, grpd = GRenderer.resolve_addressing(parsed_template, grpd)
    result = GRenderer.render_final_context_values(parsed_template, grpd)

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gender_render" href="index.html">gender_render</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gender_render.render_pipeline.GRenderer" href="#gender_render.render_pipeline.GRenderer">GRenderer</a></code></h4>
<ul class="">
<li><code><a title="gender_render.render_pipeline.GRenderer.id_resolution" href="#gender_render.render_pipeline.GRenderer.id_resolution">id_resolution</a></code></li>
<li><code><a title="gender_render.render_pipeline.GRenderer.resolve_addressing" href="#gender_render.render_pipeline.GRenderer.resolve_addressing">resolve_addressing</a></code></li>
<li><code><a title="gender_render.render_pipeline.GRenderer.render_final_context_values" href="#gender_render.render_pipeline.GRenderer.render_final_context_values">render_final_context_values</a></code></li>
<li><code><a title="gender_render.render_pipeline.GRenderer.render_with_full_rendering_pipeline" href="#gender_render.render_pipeline.GRenderer.render_with_full_rendering_pipeline">render_with_full_rendering_pipeline</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
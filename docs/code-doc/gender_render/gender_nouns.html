<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gender_render.gender_nouns API documentation</title>
<meta name="description" content="Functions to gender nouns with gender bias correctly â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/gender_render/gender_nouns.html">
<link rel="icon" href="https://pdoc3.github.io/pdoc/logo.png">
</head>
<body>
<!-- The following github corner is taken from Tim Holman (copyright notice: Copyright (c) 2016 Tim Holman),
and licensed under MIT according to https://github.com/tholman/github-corners/blob/master/license.md -->
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<a href="https://github.com/phseiff/gender-render" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gender_render.gender_nouns</code></h1>
</header>
<section id="section-intro">
<p>Functions to gender nouns with gender bias correctly.</p>
<p>Please note that you need to have <code>nltk</code> installed for this to work completely, e.g. to include all types of warnings.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L0-L733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Functions to gender nouns with gender bias correctly.

Please note that you need to have `nltk` installed for this to work completely, e.g. to include all types of warnings.
&#34;&#34;&#34;

import requests
import json
import copy
import warnings as builtin_warnings
import os
from typing import Set, Optional, Dict, List, Callable, Tuple, Union
try:
    from typing_extensions import TypedDict, Literal
except ImportError:
    TypedDict = dict
    Literal = None

from . import warnings

# make some type definitions for the data we read from the web:


if Literal:
    OriginalDataGender = Literal[&#34;f&#34;, &#34;m&#34;, &#34;n&#34;, &#34;o&#34;]
else:
    OriginalDataGender = str


class OriginalDataGenderedVersionInfo(TypedDict):
    parts_of_speech: Optional[str]
    word: str


class OriginalDataGenderMapping(TypedDict):
    f: Optional[List[OriginalDataGenderedVersionInfo]]
    m: Optional[List[OriginalDataGenderedVersionInfo]]
    n: Optional[List[OriginalDataGenderedVersionInfo]]
    h: Optional[List[OriginalDataGenderedVersionInfo]]


class OriginalDataWord(TypedDict):
    word: str
    wordnet_senseno: Optional[str]
    gender: OriginalDataGender
    gender_map: Optional[OriginalDataGenderMapping]


OriginalGenderNounData = List[OriginalDataWord]

# make some type definitions for the data we create:


if Literal:
    GeneratedDataGender = Literal[&#34;female&#34;, &#34;male&#34;, &#34;neutral&#34;]
else:
    GeneratedDataGender = str


class GeneratedDataGenderMapping(TypedDict):
    neutral: Optional[str]
    male: Optional[str]
    female: Optional[str]


class GeneratedDataWord(TypedDict):
    gender: str
    gender_map: GeneratedDataGenderMapping
    warning: Optional[Set[str]]


GeneratedGenderNounData = Dict[str, GeneratedDataWord]

# functions to check for the validity of (gendered) words/nouns:

try:
    import nltk
    try:
        nltk.data.find(&#34;corpora/words&#34;)
        nltk.data.find(&#34;corpora/wordnet&#34;)
    except LookupError:
        builtin_warnings.warn(&#34;nltk corpus (words and/or wordnet) not found; downloading it since it is small.&#34;)
        nltk.download(&#39;words&#39;, quiet=True)
        nltk.download(&#39;wordnet&#39;, quiet=True)
    from nltk.corpus import wordnet as wn
    person_synsets = set(wn.synsets(&#34;person&#34;)) | set(wn.synsets(&#34;people&#34;))
    english_person_nouns = (
        set([w.lower() for p in person_synsets for s in p.closure(lambda s: s.hyponyms()) for w in s.lemma_names()]))
    english_nouns = set(w.name().split(&#34;.&#34;)[0].lower() for w in wn.all_synsets(&#34;n&#34;)) | english_person_nouns
    english_vocab = set(w.lower() for w in nltk.corpus.words.words()) | english_nouns

    def is_a_word(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english word.&#34;&#34;&#34;
        return set(word.lower().split(&#34;_&#34;)).issubset(english_vocab) or word.lower() in english_vocab

    def is_a_noun(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english noun.&#34;&#34;&#34;
        return set(word.lower().split(&#34;_&#34;)).issubset(english_nouns) or word.lower() in english_nouns

    def is_a_person_noun(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english person noun.&#34;&#34;&#34;
        return set(word.lower().split(&#34;_&#34;)).issubset(english_person_nouns) or word.lower() in english_person_nouns
        # ^ this function is not used anymore, but remains for purposes of testing, completeness and developement

except ImportError:
    builtin_warnings.warn(&#34;The nltk-module is not installed. Some types of helpful hints and warnings may not be &#34;
                          + &#34;raised, but otherwise, this is not an issue.&#34;)

    def is_a_word(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english word.&#34;&#34;&#34;
        return True

    def is_a_noun(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english noun.&#34;&#34;&#34;
        return True

    def is_a_person_noun(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english person noun.&#34;&#34;&#34;
        return True

# a helper function for logging:


def lwarn(*text, sep=&#34; &#34;, end=&#34;\n&#34;):
    &#34;&#34;&#34;Prints the given text, but only if the &#34;BuildingGenderedNounDataLogging&#34;-warning is enabled.
    The name &#34;lwarn&#34; is supposed to stand for &#34;log warning&#34;.&#34;&#34;&#34;
    warnings.WarningManager.raise_warning(sep.join([str(t) for t in text]) + end,
                                          warnings.BuildingGenderedNounDataLogging)

# a pipeline for creating files that describe differently gendered versions of gendered nouns:


class GenderNounDataHandler:
    &#34;&#34;&#34;Bundles several static methods to handle and create data that describes the differently gendered versions of
    gendered nouns.
    These methods form a pipeline used for creating a full linked graph of gendered nouns.
    All methods of the pipeline print extensive logs if the corresponding &#34;warning&#34; is enabled, and may or may not
    modify their input in-place.
    Please note that this pipeline is tested only in environments with nltk installed.&#34;&#34;&#34;

    @staticmethod
    def load_from_web() -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Creates a JSON object describing the differently gendered versions of every gendered noun.
        Word with no wordnet_senseno-attribute (that are not from wordnet) are ignored, and words with &#34;other&#34; as gender
        are re-gendered as &#34;neutral&#34;.

        The data used for this is taken from https://github.com/ecmonsen/gendered_words
        (which is not by me; see the repository for the license).&#34;&#34;&#34;

        grammatical_genders = {&#34;m&#34;: &#34;male&#34;, &#34;f&#34;: &#34;female&#34;, &#34;n&#34;: &#34;neutral&#34;}

        # load from the web, in a completely wrong format that we have yet to change:
        raw_json: OriginalGenderNounData = json.loads(requests.get(
            &#34;https://raw.githubusercontent.com/phseiff/gendered_words/master/gendered_words.json&#34;).text)

        # change the format:
        result = dict()
        for word in raw_json:
            if &#34;wordnet_senseno&#34; in word:
                result[word[&#34;word&#34;]] = {&#34;gender_map&#34;: dict()}
                if &#34;gender_map&#34; in word:
                    for short, long in grammatical_genders.items():
                        if short in word[&#34;gender_map&#34;]:
                            result[word[&#34;word&#34;]][&#34;gender_map&#34;][long] = word[&#34;gender_map&#34;][short][0][&#34;word&#34;].replace(
                                &#34; &#34;, &#34;_&#34;)
                if word[&#34;gender&#34;] == &#34;o&#34;:
                    lwarn(&#34;Found an \&#34;other\&#34;-word! It&#39;s \&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34;.&#34;)
                    result[word[&#34;word&#34;]][&#34;gender&#34;] = &#34;neutral&#34;
                else:
                    result[word[&#34;word&#34;]][&#34;gender&#34;] = grammatical_genders[word[&#34;gender&#34;]]
            else:
                lwarn(&#34;\&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34; ignored because it is not part of wordnet and therefore not a hyponyms &#34;
                      + &#34;for a person.&#34;)

        lwarn(len(result), &#34;words found.&#34;)
        return result

    @staticmethod
    def load_from_disk(file_name: str) -&gt; (GeneratedGenderNounData, Dict[str, str]):
        &#34;&#34;&#34;Loads the gendered nouns from a piece of json data contained in the given file.
        The json object in this file must have a data-attribute, which contains the actual gendered noun data, and may
        contain an arbitrary amount of meta data in the form of strings mapped to strings, which will be returned as a
        dict as the second return value.
        The first return value is the actual gendered noun data, with the only change being that the
        `warnings`-attribute of every noun is converted from a list to a set.
        This assumes the gendered noun data to be of the same type as the data used throughout all the other methods
        of this class, NOT the format of the repository from which `load_from_web` loads its data.&#34;&#34;&#34;
        with open(file_name, &#34;r&#34;) as f:
            code = f.read()
        meta_data = json.loads(code)
        actual_data = meta_data[&#34;data&#34;]
        del meta_data[&#34;data&#34;]

        for word_data in actual_data.values():
            if &#34;warning&#34; in word_data:
                word_data[&#34;warning&#34;] = set(word_data[&#34;warning&#34;])
        return actual_data, meta_data

    @staticmethod
    def save_to_disk(graph: GeneratedGenderNounData, file_name: str, **meta_data: Dict[str, str]) -&gt; None:
        &#34;&#34;&#34;Saves the given gendered nouns data to the given file as json. The data is saved without any modifications,
        except for the `warnings`-attribute of all noun data, which is converted from a set to a list to be compatible
        with standard json format, in the data-attribute of the resulting json file.
        `meta_data` may be used to describe additional meta data in the form of strings of the resulting file.
        This assumes the given data to be of the same type as the data used throughout all the other methods of this
        class, NOT the format of the repository from which `load_from_web` loads its data.
        The data saved with this method can be read again with `load_from_disk`, so that `save_to_disk(data, file_name)`
        implies `load_from_disk(file_name) == data`.
        This method is guaranteed to not change the given data in-place.&#34;&#34;&#34;
        graph_copy: dict = copy.deepcopy(graph)
        for word_data in graph_copy.values():
            if &#34;warning&#34; in word_data:
                word_data[&#34;warning&#34;] = list(word_data[&#34;warning&#34;])
                word_data[&#34;warning&#34;].sort()
        resulting_data: dict = copy.deepcopy(meta_data)
        resulting_data[&#34;data&#34;] = graph_copy
        with open(file_name, &#34;w&#34;) as f:
            json.dump(resulting_data, f, indent=4, sort_keys=True)

    @staticmethod
    def remove_words_that_are_not_nouns(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Removes all elements that are not nouns from the graph. Words that are not nouns, but whose gendered versions
        contain nouns for some reason, are not purged by this.
        Returns the result.
        This step should usually do nothing, since all words that are not nouns should already be filtered out when
        the data is read via load_from_web, but this uses an undocumented feature of the online data set it uses, so
        this function ensures that changes of that feature don&#39;t break this code.

        This step may or may not change the given object in-place.&#34;&#34;&#34;

        grammatical_genders = [&#34;male&#34;, &#34;female&#34;, &#34;neutral&#34;]

        count = 0
        for word_name, word_data in list(graph.items()):
            is_noun = is_a_noun(word_name)
            for grammatical_gender in grammatical_genders:
                if grammatical_gender in word_data[&#34;gender_map&#34;]:
                    is_noun = is_noun or is_a_noun(word_data[&#34;gender_map&#34;][grammatical_gender])
            if not is_noun:
                lwarn(&#34;Deleting \&#34;&#34; + word_name + &#34;\&#34;, since it is not a noun!&#34;)
                count += 1
                del graph[word_name]

        lwarn(count, &#34;words deleted.&#34;)
        return graph

    @staticmethod
    def make_sure_all_referenced_words_exist(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Returns a version of the graph where every word linked as a differently gendered version of a word exists.&#34;&#34;&#34;

        count = 0
        for word_name, word_data in list(graph.items()):
            for gender_name, link_name in word_data[&#34;gender_map&#34;].items():
                if link_name not in graph:
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; lists \&#34;&#34; + link_name + &#34;\&#34; as its &#34; + gender_name + &#34; version, but \&#34;&#34;
                          + link_name + &#34;\&#34; does not exist in the word data file.&#34;)
                    count += 1
                    graph[link_name] = {&#34;gender&#34;: gender_name, &#34;gender_map&#34;: {word_data[&#34;gender&#34;]: word_name}}
                # # Commented out, since it is already covered by create_extra_links_to_gender_ambiguous_words():
                # if graph[link_name][&#34;gender&#34;] != gender_name:
                #     lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is \&#34;&#34; + word_name + &#34;\&#34;s &#34; + gender_name + &#34;s version, but is not &#34;
                #           + gender_name + &#34;.&#34;)

        lwarn(count, &#34;new words created.&#34;)
        return graph

    @staticmethod
    def choose_better_word(option1, option2, log=False):
        &#34;&#34;&#34;There are cases where a word has two different gendered versions for the same gender;
        for example, &#34;foremother&#34; and &#34;ancestress&#34; are both female words for an ancestor. In these cases, the &#34;better&#34;
        one will be chosen according to this pipeline.
        This is relevant for `make_all_links_two_sided`, for example (see docstring).

        If `log` is set, having to resort to alphabetical decisions is logged.&#34;&#34;&#34;

        # ToDo: Add further rules to this, or better yet, make manual (no automated data!) PRs to
        #  https://github.com/phseiff/gendered-words to clear up all these unnecessary unclearnesses.
        bad_things_in_order_of_badness: List[Callable[[str], int]] = [
            # the sooner the lambda, the worse it is:
            lambda word: len([c for c in word if c == &#34;_&#34;]),
            lambda word: int(word.endswith(&#34;man&#34;) or word.endswith(&#34;woman&#34;)),
            lambda word: int(word.endswith(&#34;person&#34;)),
            lambda word: int(word.endswith(&#34;mother&#34;) or word.endswith(&#34;father&#34;)),
            lambda word: int(word.endswith(&#34;parent&#34;))
        ]
        for badness_meter in bad_things_in_order_of_badness:
            if badness_meter(option1) &gt; badness_meter(option2):
                return option2
            elif badness_meter(option2) &gt; badness_meter(option1):
                return option1
        # otherwise, return the alphabetically first one:
        if log:
            lwarn(&#34;Had to alphabetically decide between&#34;, option1, &#34;and&#34;, option2)
        return sorted([option1, option2])[0]

    @staticmethod
    def make_all_links_two_sided(graph: GeneratedGenderNounData, log_clashs=False)\
            -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Returns a version of the graph where every word linked to links back to the word linking to it, if this words
        gender is not yet in its gender mapping.
        This also goes for triangles where a links to b and c, but b and c are not linked.

        If `log_clashs` is set to True, clashes are logged (these are cases where there are multiple versions available
        for the gendered version of a word). This should only be enabled before
        `create_gendered_versions_for_words_that_end_with_gender_indicators` is called on the data for the first time,
        since afterwards, multiple words might be connected that wheren&#39;t conntected before. One example would be that
        &#34;wonder_woman&#34; and &#34;wonder_girl&#34; are both considered female, and both will get &#34;wonder_person&#34; assigned as their
        neutral version by `create_gendered_versions_for_words_that_end_with_gender_indicators`. This is not an issue
        since one of them already links to &#34;wonder_boy&#34;, and the other one to &#34;wonder_man&#34; from the beginning, but
        they will still be considered clashing by the algorithm, so calling `make_all_links_two_sided` with
        `log_clashs` set to True after applying `create_gendered_versions_for_words_that_end_with_gender_indicators` to
         the data will create logs for two words that don&#39;t clash more than linguistically necessary.

         If `infect_warnings` isn&#39;t explicitely set to False, all warnings added to a word are &#34;passed&#34; to every word
         it&#39;s linked to.&#34;&#34;&#34;

        count = 0

        # makes sure we do not report a clash twice.
        already_reported_clashes: Set[str] = set()

        def assign_value_or_use_old_one(gender_dict, gender, value):
            &#34;&#34;&#34;Assigns a gendered version (`value`) to the given `gender` in the `gender_dict`.
            If there is already a value for the given gender, a decision is made whether to replace the old value in the
            gender dict with the newfound alternative one, and we then log the decision if `log_clashs` is set, and
            collect information required to build a warning to attach to the word to indicate that there was an
            algorithmic choose between two options.&#34;&#34;&#34;
            if gender in gender_dict and gender_dict[gender] != value:
                # log the clash if it wasn&#39;t logged yet:
                clash_report = value + &#34; clashes with &#34; + gender_dict[gender]
                if log_clashs and clash_report not in already_reported_clashes:
                    lwarn(clash_report)
                    already_reported_clashes.add(clash_report)

                # choose the better of both options (keep the old word or rather use the new one):
                chosen_option = GenderNounDataHandler.choose_better_word(value, gender_dict[gender], log=log_clashs)
            else:
                chosen_option = value

            gender_dict[gender] = chosen_option
            gender_dict_alts[gender] |= {chosen_option, value}

        def get_all_connected_words(word_name, data: Union[Set[str], None] = None):
            &#34;&#34;&#34;Returns a set of all words that are indirectly or directly linked to the given word.&#34;&#34;&#34;
            if not data:
                data = {word_name}
            for link_name in graph[word_name][&#34;gender_map&#34;].values():
                if link_name not in data:
                    data.add(link_name)
                    get_all_connected_words(link_name, data)
                if link_name in link_groups:
                    data |= link_groups[link_name]
            return data

        link_groups: Dict[str, Set[str]] = dict()
        words_we_already_visited: Set[str] = set()
        # first iteration is to make FULL links groups of connected words before we start linking words to each other:
        for word_name, word_data in graph.items():
            if word_name not in words_we_already_visited:

                # create group of all words that are linked to this word (including those that are once removed):
                link_group = get_all_connected_words(word_name)
                for link_name in link_group:
                    if link_name in link_groups:
                        link_groups[link_name] |= link_group
                    else:
                        link_groups[link_name] = link_group

                # add these words to the visited words now:
                words_we_already_visited |= link_group

        # second iteration is to actually do the linking:
        words_we_already_visited: Set[str] = set()
        for word_name in graph.keys():
            # if we did not visit this word yet:
            if word_name not in words_we_already_visited:
                link_group = link_groups[word_name]
                words_we_already_visited |= link_group

                # create a gender-dict for all of them:
                genders_we_are_very_sure_about: Set[GeneratedDataGender] = set()
                gender_dict: Dict[GeneratedDataGender, str] = dict()
                gender_dict_alts: Dict[GeneratedDataGender, Set[str]] = {&#34;female&#34;: set(), &#34;male&#34;: set(),
                                                                         &#34;neutral&#34;: set()}
                for link_name in link_group:
                    # add gender of the individual...
                    gender = graph[link_name][&#34;gender&#34;]
                    if gender in genders_we_are_very_sure_about:
                        assign_value_or_use_old_one(gender_dict, gender, link_name)
                    else:
                        gender_dict_alts[gender] = {link_name}
                        gender_dict[gender] = link_name
                    genders_we_are_very_sure_about.add(gender)

                    # ...as well as genders it specifies in its gender_map, but only if we couldn&#39;t find these otherwise
                    for gender, link_name2 in graph[link_name][&#34;gender_map&#34;].items():
                        if gender not in genders_we_are_very_sure_about:
                            assign_value_or_use_old_one(gender_dict, gender, link_name2)

                # link words with each other, so each word gets the full gender dict to call its own,
                # but only for genders it does not have in its own original gender dict yet, so manual links in the
                # already given data take precedence:
                for link_name in link_group:
                    for gender, link_name2 in gender_dict.items():
                        if gender not in graph[link_name][&#34;gender_map&#34;] and gender != graph[link_name][&#34;gender&#34;]:
                            graph[link_name][&#34;gender_map&#34;][gender] = link_name2
                            lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is (indirectly) linked to \&#34;&#34; + link_name2
                                  + &#34;\&#34;, which is &#34; + graph[link_name2][&#34;gender&#34;], &#34; but \&#34;&#34; + link_name
                                  + &#34;\&#34; has no &#34; + graph[link_name2][&#34;gender&#34;] + &#34; version.&#34;)
                            count += 1

                            # if the newly added link was chosen between two possible words algorithmically, add this as
                            # a warning:
                            if gender_dict_alts[gender] != {link_name2}:
                                if &#34;warning&#34; not in graph[link_name]:
                                    graph[link_name][&#34;warning&#34;] = set()
                                alt_values = sorted(list(gender_dict_alts[gender]))
                                alt_values_str = &#34;, &#34;.join(alt_values[:-1]) + &#34; and &#34; + alt_values[-1]
                                new_warning = (alt_values_str + &#34; would&#39;ve all been good values for the &#34; + gender + &#34; &#34;
                                               + &#34;version of \&#34;&#34; + link_name + &#34;\&#34;, but \&#34;&#34; + link_name2
                                               + &#34;\&#34; was automatically chosen based on an algorithm.&#34;)
                                lwarn(new_warning)
                                graph[link_name][&#34;warning&#34;].add(new_warning)

                # infect linked words with the warnings of the words they&#39;re linked to:
                link_group_warnings = set()
                for link_name in link_group:
                    if &#34;warning&#34; in graph[link_name]:
                        link_group_warnings |= graph[link_name][&#34;warning&#34;]
                if link_group_warnings:
                    for link_name in link_group:
                        if &#34;warning&#34; not in graph[link_name]:
                            graph[link_name][&#34;warning&#34;] = set()
                        graph[link_name][&#34;warning&#34;] |= link_group_warnings

        lwarn(count, &#34;links created.&#34;)
        return graph

    @staticmethod
    def create_extra_links_to_gender_ambiguous_words(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;There may be some words A with gender x, that list another word B as their gender-y-version, but don&#39;t have
        any gender-z-version, and word B is listet as gender z for some reason.
        This method returns a version of the given graph where A links to B as its gender-z-version.&#34;&#34;&#34;

        count = 0
        for word_name, word_data in graph.items():
            for gender_name, link_name in list(word_data[&#34;gender_map&#34;].items()):
                if graph[link_name][&#34;gender&#34;] not in word_data[&#34;gender_map&#34;]:
                    if graph[link_name][&#34;gender&#34;] != word_data[&#34;gender&#34;]:
                        word_data[&#34;gender_map&#34;][graph[link_name][&#34;gender&#34;]] = link_name
                        lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have a &#34; + graph[link_name][&#34;gender&#34;] + &#34; version, but a &#34;
                              + &#34;word it links to as its &#34; + gender_name + &#34; version is &#34; + graph[link_name][&#34;gender&#34;]
                              + &#34;.&#34;)
                        count += 1

        lwarn(count, &#34;links created.&#34;)
        return graph

    @staticmethod
    def create_gendered_versions_for_words_that_end_with_gender_indicators(graph: GeneratedGenderNounData)\
            -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Some words end on &#34;-man&#34; or &#34;-woman&#34;, or similar things like &#34;boy&#34; or &#34;maid&#34;, but don&#39;t have a male/female/
        neutral version. This method returns a version of the graph where every word of these has a male, female as well
        as neutral version. It also ensures that the resulting word doesn&#39;t end with &#34;_&#34; due to having its end or
        beginning removed, and that it doesn&#39;t create &#34;empty&#34; words.&#34;&#34;&#34;

        # ToDo: better suggestions regarding the maid/maiden/boy/girl-stuff are welcome!
        # ToDo: running replacement strategies like this when creating a tag with a GenderedNoun-object for an unknown
        #  noun might be a good idea... this would, however, require figuring out a words gender, so the table we have
        #  here would have to be accessible outside this function.
        #  Feel free to submit a pull request for this, or an issue if you see this fitting!
        gender_indicator_tuples_table = [
            (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;&#34;)]),

            (&#34;end&#34;,   [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;bean&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),  # or butler? domestic?
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)]),

            (&#34;start&#34;, [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;bean&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)])
        ]

        words_created = 0
        links_created = 0
        for word_name, word_data in list(graph.items()):
            for end_or_start, gender_indicator_tuples in gender_indicator_tuples_table:
                created_corresponding_gendered_versions = False
                for gender, gender_indicator in gender_indicator_tuples:
                    if (((end_or_start == &#34;end&#34; and word_name.endswith(gender_indicator))
                            or (end_or_start == &#34;start&#34; and word_name.startswith(gender_indicator)))
                            and gender_indicator):
                        not_applicable = False
                        if gender != &#34;neutral&#34;:
                            other_gender_indicator_tuples = [
                                t for t in gender_indicator_tuples if t != (gender, gender_indicator)]
                            for other_gender, other_gender_indicator in other_gender_indicator_tuples:
                                if other_gender not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
                                    # figure out the potential new word:
                                    if end_or_start == &#34;end&#34;:
                                        new_gendered_version = (word_name[:-len(gender_indicator)]
                                                                + other_gender_indicator)
                                    else:
                                        new_gendered_version = (other_gender_indicator
                                                                + word_name[len(gender_indicator):])
                                    new_gendered_version = new_gendered_version.lstrip(&#34;_&#34;).rstrip(&#34;_&#34;)
                                    if new_gendered_version == &#34;&#34;:
                                        not_applicable = True
                                        continue
                                    # create the new word or link to it:
                                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; ends with \&#34;-&#34; + gender_indicator
                                          + &#34;\&#34;, but it has no &#34; + other_gender + &#34; version. &#34;, end=&#34;&#34;)
                                    word_data[&#34;gender_map&#34;][other_gender] = new_gendered_version
                                    links_created += 1
                                    if new_gendered_version not in graph:
                                        lwarn(&#34;Creating one as \&#34;&#34; + new_gendered_version + &#34;\&#34;!&#34;)
                                        words_created += 1
                                        graph[new_gendered_version] = {
                                            &#34;gender&#34;: other_gender,
                                            &#34;gender_map&#34;: dict(),
                                            &#34;warning&#34;: {&#34;\&#34;&#34; + new_gendered_version
                                                        + &#34;\&#34; was automatically generated as the &#34; + other_gender
                                                        + &#34; version of a word due to the &#34;
                                                        + (&#34;ending&#34; if end_or_start == &#34;end&#34; else &#34;beginning&#34;)
                                                        + &#34; of said &#34; + &#34;word.&#34;}
                                        }
                                    else:
                                        lwarn(&#34;Linking to \&#34;&#34; + new_gendered_version + &#34;\&#34;.&#34;)
                                    # Add a new warning that a link was created between those two:
                                    if &#34;warning&#34; not in word_data:
                                        word_data[&#34;warning&#34;] = set()
                                    word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + new_gendered_version
                                                             + &#34;\&#34; was automatically linked to \&#34;&#34; + word_name
                                                             + &#34;\&#34; as its &#34; + gender + &#34; version due to the &#34;
                                                             + (&#34;ending&#34; if end_or_start == &#34;end&#34; else &#34;beginning&#34;)
                                                             + &#34; of said &#34; + &#34;word.&#34;)

                        if not not_applicable:
                            created_corresponding_gendered_versions = True
                            break
                if created_corresponding_gendered_versions:
                    break

        lwarn(words_created, &#34;new words created.&#34;)
        lwarn(links_created, &#34;new links created.&#34;)
        return graph

    @staticmethod
    def find_words_with_no_neutral_form(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Informs about every word that does not have a neutral version, and uses this word as its own neutral version.
        Gives each of these words a neutral form by using the male version of the word by default and the female version
        if there is no male one.&#34;&#34;&#34;

        count_male = 0
        count_used_male = 0
        count_used_female = 0
        count = 0
        for word_name, word_data in list(graph.items()):
            if word_data[&#34;gender&#34;] != &#34;neutral&#34;:
                if &#34;neutral&#34; not in word_data[&#34;gender_map&#34;]:
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; is neither neutral, nor does it link to a neutral version.&#34;)
                    count += 1
                    if word_data[&#34;gender&#34;] == &#34;male&#34;:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                        if &#34;warning&#34; not in word_data:
                            word_data[&#34;warning&#34;] = set()
                        word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                                 + &#34;neutral version, and since it is male, it&#39;s automatically used as &#34;
                                                 + &#34;own neutral version. This is done because lots of words in the &#34;
                                                 + &#34;database are wrongly marked as male even though they are actually &#34;
                                                 + &#34;neutral.&#34;)
                        count_male += 1
                    elif &#34;male&#34; in word_data[&#34;gender_map&#34;]:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_data[&#34;gender_map&#34;][&#34;male&#34;]
                        if &#34;warning&#34; not in word_data:
                            word_data[&#34;warning&#34;] = set()
                        word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                                 + &#34;neutral version, and since it has a male version, this version is &#34;
                                                 + &#34;automatically used as its neutral version. This is done because &#34;
                                                 + &#34;lots of words in the  database are wrongly marked as male even &#34;
                                                 + &#34;though they are actually neutral.&#34;)
                        count_used_male += 1
                    else:
                        if &#34;warning&#34; not in word_data:
                            word_data[&#34;warning&#34;] = set()
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                        word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; neither has a male nor a female version, so &#34;
                                                 + &#34;it is used as its own neutral version.&#34;)
                        count_used_female += 1
                    lwarn(word_data[&#34;warning&#34;])

        lwarn(count, &#34;instances found.&#34;)
        lwarn(count_male, &#34;instances where male words where used as their own neutral version,&#34;)
        lwarn(count_used_male, &#34;instances where a male version of a word was used as its neutral version,&#34;)
        lwarn(count_used_female, &#34;instances where a female word was used as its own neutral version.&#34;)

        return graph

    @staticmethod
    def create_full_graph_from_web() -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;A pipeline that combines all methods of this method collection to pull a graph of gendered words from the web
        and automatically fill all holes this graph has left open.&#34;&#34;&#34;

        graph = GenderNounDataHandler.load_from_web()
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.remove_words_that_are_not_nouns(graph)

        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_sure_all_referenced_words_exist(graph)
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_all_links_two_sided(graph)

        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words(graph)
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_all_links_two_sided(graph, log_clashs=True)

        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators(graph)
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_all_links_two_sided(graph)

        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.find_words_with_no_neutral_form(graph)
        return graph


# the final dict:

# !!! The following lines of code (or, to say it pythonic, the following dict) contain license information.
# This licesne information is part of this code in that it is processed by the code and then written into a different
# file, alongside the runtime-generated content it refers to. IT DOES NOT, HOWEVER; REFER TO THE CONTENT OF THE FILE YOU
# FOUND IT IN, IF YOU FOUND IT ALONGSIDE THIS DISCLAIMER.
GDN_META_DATA = {
    &#34;license&#34;: &#39;\
Most parts of the contents of this file were created based on WordNet content, which is licensed under the WordNet\
 license (https://wordnet.princeton.edu/license-and-commercial-use), by GitHub-user ecmonson\
 (https://github.com/ecmonsen), who applied modifications to it licensed under the Creative Commons Attribution 3.0\
 (https://creativecommons.org/licenses/by/3.0/us/), as explained here\
 (https://github.com/ecmonsen/gendered_words#license).\
 The dataset was then taken by GitHub-user phseiff (https://phseiff.com), who converted it into a different format,\
 effectively stripping all WordNet content but the selection of hyponyms for &#34;person&#34; from it, and closed some holes in\
 it, as outlines in this (https://github.com/ecmonsen/gendered_words/issues/1) issue.\
 Contributions by phseiff are licensed under Creative Commons Attribution 3.0 as well.&#39;
}
noun_data_location = os.path.join(__file__.rsplit(os.sep, 1)[0], &#34;data/gendered-nouns.gdn&#34;)
GENDER_DICT: GeneratedGenderNounData
try:
    GENDER_DICT, _ = GenderNounDataHandler.load_from_disk(noun_data_location)
except FileNotFoundError:
    warnings.WarningManager.raise_warning(None, warnings.GenderedNounsBuildFromWebWarning)
    g = GenderNounDataHandler.create_full_graph_from_web()
    GenderNounDataHandler.save_to_disk(g, noun_data_location, **GDN_META_DATA)
    GENDER_DICT, _ = GenderNounDataHandler.load_from_disk(noun_data_location)


# Representation of a not-yet correctly gendered noun:

class GenderedNoun:
    &#34;&#34;&#34;A representation of a gendered noun, with methods to get gendered equivalents of it.&#34;&#34;&#34;

    def __init__(self, word: str):
        &#34;&#34;&#34;Generates an object to get gendered versions of the given noun for different genders.&#34;&#34;&#34;

        # save the full word, but lookup the word in lowercase:
        self.word = word

        # raise warnings if the word is not a word/ noun/ person noun:
        if word not in GENDER_DICT:
            if not is_a_word(word):
                warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known word, so gender*render might not&#34;
                                                      + &#34; be able to gender it correctly.&#34;, warnings.NotAWordWarning)
            elif not is_a_noun(word):
                warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known noun, so gender*render might not&#34;
                                                      + &#34; be able to gender it correctly.&#34;, warnings.NotANounWarning)
            else:
                warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a hyponym for person, so gender*render &#34;
                                                      + &#34;might not be able to gender it correctly.&#34;,
                                                      warnings.NotAPersonNounWarning)
        elif &#34;warning&#34; in GENDER_DICT[word]:
            warnings.WarningManager.raise_warning(&#34;warnings for \&#34;&#34; + word + &#34;\&#34;:\n&#34;
                                                  + &#34;\n&#34;.join(list(GENDER_DICT[word][&#34;warning&#34;])),
                                                  warnings.NounGenderingGuessingsWarning)
            # ToDo: Maybe only print those warnings that contain `&#34;\&#34;&#34; + word + &#34;\&#34;&#34;` in them? This would require
            #  reviewing all warnings attached to words by this modules code, to be sure this actually prints all
            #  relevant warnings, as well as injecting some trivial code here and generally discussing this idea in an
            #  issue.
            #  See also the comment in test/test_gender_nouns in test_create_full_graph_from_web.

    def render_noun(self, gender: GeneratedDataGender) -&gt; str:
        &#34;&#34;&#34;Returns the correctly gendered version of itself as a string. gender must be either &#34;male&#34;, &#34;female&#34; or
        &#34;neutral&#34;.&#34;&#34;&#34;  # ToDo: Re-test this since capitalization is no longer supported.

        # return the correctly gendered version of the word:
        word = self.word
        if word in GENDER_DICT:
            word_data = GENDER_DICT[word]
            # look for the neutral version if there is no version of the given gender:
            if gender not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
                gender = &#34;neutral&#34;
            # return the word if it is the right gender:
            if GENDER_DICT[word][&#34;gender&#34;] == gender:
                result = word
            # otherwise, return the correctly gendered version from the gender_map:
            else:
                result = word_data[&#34;gender_map&#34;][gender]
        else:
            result = self.word
        return result.replace(&#34;_&#34;, &#34; &#34;)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Checks whether two GenderedNoun-representations are identical, based on what noun they represent.&#34;&#34;&#34;
        if isinstance(other, self.__class__):
            return self.word == other.word
        else:
            return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gender_render.gender_nouns.is_a_word"><code class="name flex">
<span>def <span class="ident">is_a_word</span></span>(<span>word:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given word is a valid english word.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L92-L94" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_a_word(word: str) -&gt; bool:
    &#34;&#34;&#34;Checks whether the given word is a valid english word.&#34;&#34;&#34;
    return set(word.lower().split(&#34;_&#34;)).issubset(english_vocab) or word.lower() in english_vocab</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.is_a_noun"><code class="name flex">
<span>def <span class="ident">is_a_noun</span></span>(<span>word:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given word is a valid english noun.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L96-L98" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_a_noun(word: str) -&gt; bool:
    &#34;&#34;&#34;Checks whether the given word is a valid english noun.&#34;&#34;&#34;
    return set(word.lower().split(&#34;_&#34;)).issubset(english_nouns) or word.lower() in english_nouns</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.is_a_person_noun"><code class="name flex">
<span>def <span class="ident">is_a_person_noun</span></span>(<span>word:Â str) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given word is a valid english person noun.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L100-L102" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_a_person_noun(word: str) -&gt; bool:
    &#34;&#34;&#34;Checks whether the given word is a valid english person noun.&#34;&#34;&#34;
    return set(word.lower().split(&#34;_&#34;)).issubset(english_person_nouns) or word.lower() in english_person_nouns</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.lwarn"><code class="name flex">
<span>def <span class="ident">lwarn</span></span>(<span>*text, sep=' ', end='\n')</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the given text, but only if the "BuildingGenderedNounDataLogging"-warning is enabled.
The name "lwarn" is supposed to stand for "log warning".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L124-L128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lwarn(*text, sep=&#34; &#34;, end=&#34;\n&#34;):
    &#34;&#34;&#34;Prints the given text, but only if the &#34;BuildingGenderedNounDataLogging&#34;-warning is enabled.
    The name &#34;lwarn&#34; is supposed to stand for &#34;log warning&#34;.&#34;&#34;&#34;
    warnings.WarningManager.raise_warning(sep.join([str(t) for t in text]) + end,
                                          warnings.BuildingGenderedNounDataLogging)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gender_render.gender_nouns.OriginalDataGenderedVersionInfo"><code class="flex name class">
<span>class <span class="ident">OriginalDataGenderedVersionInfo</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L30-L32" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OriginalDataGenderedVersionInfo(TypedDict):
    parts_of_speech: Optional[str]
    word: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.gender_nouns.OriginalDataGenderedVersionInfo.parts_of_speech"><code class="name">var <span class="ident">parts_of_speech</span> :Â Union[str,Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataGenderedVersionInfo.word"><code class="name">var <span class="ident">word</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataGenderMapping"><code class="flex name class">
<span>class <span class="ident">OriginalDataGenderMapping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L35-L39" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OriginalDataGenderMapping(TypedDict):
    f: Optional[List[OriginalDataGenderedVersionInfo]]
    m: Optional[List[OriginalDataGenderedVersionInfo]]
    n: Optional[List[OriginalDataGenderedVersionInfo]]
    h: Optional[List[OriginalDataGenderedVersionInfo]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.gender_nouns.OriginalDataGenderMapping.f"><code class="name">var <span class="ident">f</span> :Â Union[List[<a title="gender_render.gender_nouns.OriginalDataGenderedVersionInfo" href="#gender_render.gender_nouns.OriginalDataGenderedVersionInfo">OriginalDataGenderedVersionInfo</a>],Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataGenderMapping.m"><code class="name">var <span class="ident">m</span> :Â Union[List[<a title="gender_render.gender_nouns.OriginalDataGenderedVersionInfo" href="#gender_render.gender_nouns.OriginalDataGenderedVersionInfo">OriginalDataGenderedVersionInfo</a>],Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataGenderMapping.n"><code class="name">var <span class="ident">n</span> :Â Union[List[<a title="gender_render.gender_nouns.OriginalDataGenderedVersionInfo" href="#gender_render.gender_nouns.OriginalDataGenderedVersionInfo">OriginalDataGenderedVersionInfo</a>],Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataGenderMapping.h"><code class="name">var <span class="ident">h</span> :Â Union[List[<a title="gender_render.gender_nouns.OriginalDataGenderedVersionInfo" href="#gender_render.gender_nouns.OriginalDataGenderedVersionInfo">OriginalDataGenderedVersionInfo</a>],Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataWord"><code class="flex name class">
<span>class <span class="ident">OriginalDataWord</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L42-L46" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OriginalDataWord(TypedDict):
    word: str
    wordnet_senseno: Optional[str]
    gender: OriginalDataGender
    gender_map: Optional[OriginalDataGenderMapping]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.gender_nouns.OriginalDataWord.word"><code class="name">var <span class="ident">word</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataWord.wordnet_senseno"><code class="name">var <span class="ident">wordnet_senseno</span> :Â Union[str,Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataWord.gender"><code class="name">var <span class="ident">gender</span> :Â typing_extensions.Literal['f',Â 'm',Â 'n',Â 'o']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.OriginalDataWord.gender_map"><code class="name">var <span class="ident">gender_map</span> :Â Union[<a title="gender_render.gender_nouns.OriginalDataGenderMapping" href="#gender_render.gender_nouns.OriginalDataGenderMapping">OriginalDataGenderMapping</a>,Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="gender_render.gender_nouns.GeneratedDataGenderMapping"><code class="flex name class">
<span>class <span class="ident">GeneratedDataGenderMapping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L60-L63" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GeneratedDataGenderMapping(TypedDict):
    neutral: Optional[str]
    male: Optional[str]
    female: Optional[str]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.gender_nouns.GeneratedDataGenderMapping.neutral"><code class="name">var <span class="ident">neutral</span> :Â Union[str,Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.GeneratedDataGenderMapping.male"><code class="name">var <span class="ident">male</span> :Â Union[str,Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.GeneratedDataGenderMapping.female"><code class="name">var <span class="ident">female</span> :Â Union[str,Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="gender_render.gender_nouns.GeneratedDataWord"><code class="flex name class">
<span>class <span class="ident">GeneratedDataWord</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L66-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GeneratedDataWord(TypedDict):
    gender: str
    gender_map: GeneratedDataGenderMapping
    warning: Optional[Set[str]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.gender_nouns.GeneratedDataWord.gender"><code class="name">var <span class="ident">gender</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.GeneratedDataWord.gender_map"><code class="name">var <span class="ident">gender_map</span> :Â <a title="gender_render.gender_nouns.GeneratedDataGenderMapping" href="#gender_render.gender_nouns.GeneratedDataGenderMapping">GeneratedDataGenderMapping</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.gender_nouns.GeneratedDataWord.warning"><code class="name">var <span class="ident">warning</span> :Â Union[Set[str],Â NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler"><code class="flex name class">
<span>class <span class="ident">GenderNounDataHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Bundles several static methods to handle and create data that describes the differently gendered versions of
gendered nouns.
These methods form a pipeline used for creating a full linked graph of gendered nouns.
All methods of the pipeline print extensive logs if the corresponding "warning" is enabled, and may or may not
modify their input in-place.
Please note that this pipeline is tested only in environments with nltk installed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L133-L643" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GenderNounDataHandler:
    &#34;&#34;&#34;Bundles several static methods to handle and create data that describes the differently gendered versions of
    gendered nouns.
    These methods form a pipeline used for creating a full linked graph of gendered nouns.
    All methods of the pipeline print extensive logs if the corresponding &#34;warning&#34; is enabled, and may or may not
    modify their input in-place.
    Please note that this pipeline is tested only in environments with nltk installed.&#34;&#34;&#34;

    @staticmethod
    def load_from_web() -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Creates a JSON object describing the differently gendered versions of every gendered noun.
        Word with no wordnet_senseno-attribute (that are not from wordnet) are ignored, and words with &#34;other&#34; as gender
        are re-gendered as &#34;neutral&#34;.

        The data used for this is taken from https://github.com/ecmonsen/gendered_words
        (which is not by me; see the repository for the license).&#34;&#34;&#34;

        grammatical_genders = {&#34;m&#34;: &#34;male&#34;, &#34;f&#34;: &#34;female&#34;, &#34;n&#34;: &#34;neutral&#34;}

        # load from the web, in a completely wrong format that we have yet to change:
        raw_json: OriginalGenderNounData = json.loads(requests.get(
            &#34;https://raw.githubusercontent.com/phseiff/gendered_words/master/gendered_words.json&#34;).text)

        # change the format:
        result = dict()
        for word in raw_json:
            if &#34;wordnet_senseno&#34; in word:
                result[word[&#34;word&#34;]] = {&#34;gender_map&#34;: dict()}
                if &#34;gender_map&#34; in word:
                    for short, long in grammatical_genders.items():
                        if short in word[&#34;gender_map&#34;]:
                            result[word[&#34;word&#34;]][&#34;gender_map&#34;][long] = word[&#34;gender_map&#34;][short][0][&#34;word&#34;].replace(
                                &#34; &#34;, &#34;_&#34;)
                if word[&#34;gender&#34;] == &#34;o&#34;:
                    lwarn(&#34;Found an \&#34;other\&#34;-word! It&#39;s \&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34;.&#34;)
                    result[word[&#34;word&#34;]][&#34;gender&#34;] = &#34;neutral&#34;
                else:
                    result[word[&#34;word&#34;]][&#34;gender&#34;] = grammatical_genders[word[&#34;gender&#34;]]
            else:
                lwarn(&#34;\&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34; ignored because it is not part of wordnet and therefore not a hyponyms &#34;
                      + &#34;for a person.&#34;)

        lwarn(len(result), &#34;words found.&#34;)
        return result

    @staticmethod
    def load_from_disk(file_name: str) -&gt; (GeneratedGenderNounData, Dict[str, str]):
        &#34;&#34;&#34;Loads the gendered nouns from a piece of json data contained in the given file.
        The json object in this file must have a data-attribute, which contains the actual gendered noun data, and may
        contain an arbitrary amount of meta data in the form of strings mapped to strings, which will be returned as a
        dict as the second return value.
        The first return value is the actual gendered noun data, with the only change being that the
        `warnings`-attribute of every noun is converted from a list to a set.
        This assumes the gendered noun data to be of the same type as the data used throughout all the other methods
        of this class, NOT the format of the repository from which `load_from_web` loads its data.&#34;&#34;&#34;
        with open(file_name, &#34;r&#34;) as f:
            code = f.read()
        meta_data = json.loads(code)
        actual_data = meta_data[&#34;data&#34;]
        del meta_data[&#34;data&#34;]

        for word_data in actual_data.values():
            if &#34;warning&#34; in word_data:
                word_data[&#34;warning&#34;] = set(word_data[&#34;warning&#34;])
        return actual_data, meta_data

    @staticmethod
    def save_to_disk(graph: GeneratedGenderNounData, file_name: str, **meta_data: Dict[str, str]) -&gt; None:
        &#34;&#34;&#34;Saves the given gendered nouns data to the given file as json. The data is saved without any modifications,
        except for the `warnings`-attribute of all noun data, which is converted from a set to a list to be compatible
        with standard json format, in the data-attribute of the resulting json file.
        `meta_data` may be used to describe additional meta data in the form of strings of the resulting file.
        This assumes the given data to be of the same type as the data used throughout all the other methods of this
        class, NOT the format of the repository from which `load_from_web` loads its data.
        The data saved with this method can be read again with `load_from_disk`, so that `save_to_disk(data, file_name)`
        implies `load_from_disk(file_name) == data`.
        This method is guaranteed to not change the given data in-place.&#34;&#34;&#34;
        graph_copy: dict = copy.deepcopy(graph)
        for word_data in graph_copy.values():
            if &#34;warning&#34; in word_data:
                word_data[&#34;warning&#34;] = list(word_data[&#34;warning&#34;])
                word_data[&#34;warning&#34;].sort()
        resulting_data: dict = copy.deepcopy(meta_data)
        resulting_data[&#34;data&#34;] = graph_copy
        with open(file_name, &#34;w&#34;) as f:
            json.dump(resulting_data, f, indent=4, sort_keys=True)

    @staticmethod
    def remove_words_that_are_not_nouns(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Removes all elements that are not nouns from the graph. Words that are not nouns, but whose gendered versions
        contain nouns for some reason, are not purged by this.
        Returns the result.
        This step should usually do nothing, since all words that are not nouns should already be filtered out when
        the data is read via load_from_web, but this uses an undocumented feature of the online data set it uses, so
        this function ensures that changes of that feature don&#39;t break this code.

        This step may or may not change the given object in-place.&#34;&#34;&#34;

        grammatical_genders = [&#34;male&#34;, &#34;female&#34;, &#34;neutral&#34;]

        count = 0
        for word_name, word_data in list(graph.items()):
            is_noun = is_a_noun(word_name)
            for grammatical_gender in grammatical_genders:
                if grammatical_gender in word_data[&#34;gender_map&#34;]:
                    is_noun = is_noun or is_a_noun(word_data[&#34;gender_map&#34;][grammatical_gender])
            if not is_noun:
                lwarn(&#34;Deleting \&#34;&#34; + word_name + &#34;\&#34;, since it is not a noun!&#34;)
                count += 1
                del graph[word_name]

        lwarn(count, &#34;words deleted.&#34;)
        return graph

    @staticmethod
    def make_sure_all_referenced_words_exist(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Returns a version of the graph where every word linked as a differently gendered version of a word exists.&#34;&#34;&#34;

        count = 0
        for word_name, word_data in list(graph.items()):
            for gender_name, link_name in word_data[&#34;gender_map&#34;].items():
                if link_name not in graph:
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; lists \&#34;&#34; + link_name + &#34;\&#34; as its &#34; + gender_name + &#34; version, but \&#34;&#34;
                          + link_name + &#34;\&#34; does not exist in the word data file.&#34;)
                    count += 1
                    graph[link_name] = {&#34;gender&#34;: gender_name, &#34;gender_map&#34;: {word_data[&#34;gender&#34;]: word_name}}
                # # Commented out, since it is already covered by create_extra_links_to_gender_ambiguous_words():
                # if graph[link_name][&#34;gender&#34;] != gender_name:
                #     lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is \&#34;&#34; + word_name + &#34;\&#34;s &#34; + gender_name + &#34;s version, but is not &#34;
                #           + gender_name + &#34;.&#34;)

        lwarn(count, &#34;new words created.&#34;)
        return graph

    @staticmethod
    def choose_better_word(option1, option2, log=False):
        &#34;&#34;&#34;There are cases where a word has two different gendered versions for the same gender;
        for example, &#34;foremother&#34; and &#34;ancestress&#34; are both female words for an ancestor. In these cases, the &#34;better&#34;
        one will be chosen according to this pipeline.
        This is relevant for `make_all_links_two_sided`, for example (see docstring).

        If `log` is set, having to resort to alphabetical decisions is logged.&#34;&#34;&#34;

        # ToDo: Add further rules to this, or better yet, make manual (no automated data!) PRs to
        #  https://github.com/phseiff/gendered-words to clear up all these unnecessary unclearnesses.
        bad_things_in_order_of_badness: List[Callable[[str], int]] = [
            # the sooner the lambda, the worse it is:
            lambda word: len([c for c in word if c == &#34;_&#34;]),
            lambda word: int(word.endswith(&#34;man&#34;) or word.endswith(&#34;woman&#34;)),
            lambda word: int(word.endswith(&#34;person&#34;)),
            lambda word: int(word.endswith(&#34;mother&#34;) or word.endswith(&#34;father&#34;)),
            lambda word: int(word.endswith(&#34;parent&#34;))
        ]
        for badness_meter in bad_things_in_order_of_badness:
            if badness_meter(option1) &gt; badness_meter(option2):
                return option2
            elif badness_meter(option2) &gt; badness_meter(option1):
                return option1
        # otherwise, return the alphabetically first one:
        if log:
            lwarn(&#34;Had to alphabetically decide between&#34;, option1, &#34;and&#34;, option2)
        return sorted([option1, option2])[0]

    @staticmethod
    def make_all_links_two_sided(graph: GeneratedGenderNounData, log_clashs=False)\
            -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Returns a version of the graph where every word linked to links back to the word linking to it, if this words
        gender is not yet in its gender mapping.
        This also goes for triangles where a links to b and c, but b and c are not linked.

        If `log_clashs` is set to True, clashes are logged (these are cases where there are multiple versions available
        for the gendered version of a word). This should only be enabled before
        `create_gendered_versions_for_words_that_end_with_gender_indicators` is called on the data for the first time,
        since afterwards, multiple words might be connected that wheren&#39;t conntected before. One example would be that
        &#34;wonder_woman&#34; and &#34;wonder_girl&#34; are both considered female, and both will get &#34;wonder_person&#34; assigned as their
        neutral version by `create_gendered_versions_for_words_that_end_with_gender_indicators`. This is not an issue
        since one of them already links to &#34;wonder_boy&#34;, and the other one to &#34;wonder_man&#34; from the beginning, but
        they will still be considered clashing by the algorithm, so calling `make_all_links_two_sided` with
        `log_clashs` set to True after applying `create_gendered_versions_for_words_that_end_with_gender_indicators` to
         the data will create logs for two words that don&#39;t clash more than linguistically necessary.

         If `infect_warnings` isn&#39;t explicitely set to False, all warnings added to a word are &#34;passed&#34; to every word
         it&#39;s linked to.&#34;&#34;&#34;

        count = 0

        # makes sure we do not report a clash twice.
        already_reported_clashes: Set[str] = set()

        def assign_value_or_use_old_one(gender_dict, gender, value):
            &#34;&#34;&#34;Assigns a gendered version (`value`) to the given `gender` in the `gender_dict`.
            If there is already a value for the given gender, a decision is made whether to replace the old value in the
            gender dict with the newfound alternative one, and we then log the decision if `log_clashs` is set, and
            collect information required to build a warning to attach to the word to indicate that there was an
            algorithmic choose between two options.&#34;&#34;&#34;
            if gender in gender_dict and gender_dict[gender] != value:
                # log the clash if it wasn&#39;t logged yet:
                clash_report = value + &#34; clashes with &#34; + gender_dict[gender]
                if log_clashs and clash_report not in already_reported_clashes:
                    lwarn(clash_report)
                    already_reported_clashes.add(clash_report)

                # choose the better of both options (keep the old word or rather use the new one):
                chosen_option = GenderNounDataHandler.choose_better_word(value, gender_dict[gender], log=log_clashs)
            else:
                chosen_option = value

            gender_dict[gender] = chosen_option
            gender_dict_alts[gender] |= {chosen_option, value}

        def get_all_connected_words(word_name, data: Union[Set[str], None] = None):
            &#34;&#34;&#34;Returns a set of all words that are indirectly or directly linked to the given word.&#34;&#34;&#34;
            if not data:
                data = {word_name}
            for link_name in graph[word_name][&#34;gender_map&#34;].values():
                if link_name not in data:
                    data.add(link_name)
                    get_all_connected_words(link_name, data)
                if link_name in link_groups:
                    data |= link_groups[link_name]
            return data

        link_groups: Dict[str, Set[str]] = dict()
        words_we_already_visited: Set[str] = set()
        # first iteration is to make FULL links groups of connected words before we start linking words to each other:
        for word_name, word_data in graph.items():
            if word_name not in words_we_already_visited:

                # create group of all words that are linked to this word (including those that are once removed):
                link_group = get_all_connected_words(word_name)
                for link_name in link_group:
                    if link_name in link_groups:
                        link_groups[link_name] |= link_group
                    else:
                        link_groups[link_name] = link_group

                # add these words to the visited words now:
                words_we_already_visited |= link_group

        # second iteration is to actually do the linking:
        words_we_already_visited: Set[str] = set()
        for word_name in graph.keys():
            # if we did not visit this word yet:
            if word_name not in words_we_already_visited:
                link_group = link_groups[word_name]
                words_we_already_visited |= link_group

                # create a gender-dict for all of them:
                genders_we_are_very_sure_about: Set[GeneratedDataGender] = set()
                gender_dict: Dict[GeneratedDataGender, str] = dict()
                gender_dict_alts: Dict[GeneratedDataGender, Set[str]] = {&#34;female&#34;: set(), &#34;male&#34;: set(),
                                                                         &#34;neutral&#34;: set()}
                for link_name in link_group:
                    # add gender of the individual...
                    gender = graph[link_name][&#34;gender&#34;]
                    if gender in genders_we_are_very_sure_about:
                        assign_value_or_use_old_one(gender_dict, gender, link_name)
                    else:
                        gender_dict_alts[gender] = {link_name}
                        gender_dict[gender] = link_name
                    genders_we_are_very_sure_about.add(gender)

                    # ...as well as genders it specifies in its gender_map, but only if we couldn&#39;t find these otherwise
                    for gender, link_name2 in graph[link_name][&#34;gender_map&#34;].items():
                        if gender not in genders_we_are_very_sure_about:
                            assign_value_or_use_old_one(gender_dict, gender, link_name2)

                # link words with each other, so each word gets the full gender dict to call its own,
                # but only for genders it does not have in its own original gender dict yet, so manual links in the
                # already given data take precedence:
                for link_name in link_group:
                    for gender, link_name2 in gender_dict.items():
                        if gender not in graph[link_name][&#34;gender_map&#34;] and gender != graph[link_name][&#34;gender&#34;]:
                            graph[link_name][&#34;gender_map&#34;][gender] = link_name2
                            lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is (indirectly) linked to \&#34;&#34; + link_name2
                                  + &#34;\&#34;, which is &#34; + graph[link_name2][&#34;gender&#34;], &#34; but \&#34;&#34; + link_name
                                  + &#34;\&#34; has no &#34; + graph[link_name2][&#34;gender&#34;] + &#34; version.&#34;)
                            count += 1

                            # if the newly added link was chosen between two possible words algorithmically, add this as
                            # a warning:
                            if gender_dict_alts[gender] != {link_name2}:
                                if &#34;warning&#34; not in graph[link_name]:
                                    graph[link_name][&#34;warning&#34;] = set()
                                alt_values = sorted(list(gender_dict_alts[gender]))
                                alt_values_str = &#34;, &#34;.join(alt_values[:-1]) + &#34; and &#34; + alt_values[-1]
                                new_warning = (alt_values_str + &#34; would&#39;ve all been good values for the &#34; + gender + &#34; &#34;
                                               + &#34;version of \&#34;&#34; + link_name + &#34;\&#34;, but \&#34;&#34; + link_name2
                                               + &#34;\&#34; was automatically chosen based on an algorithm.&#34;)
                                lwarn(new_warning)
                                graph[link_name][&#34;warning&#34;].add(new_warning)

                # infect linked words with the warnings of the words they&#39;re linked to:
                link_group_warnings = set()
                for link_name in link_group:
                    if &#34;warning&#34; in graph[link_name]:
                        link_group_warnings |= graph[link_name][&#34;warning&#34;]
                if link_group_warnings:
                    for link_name in link_group:
                        if &#34;warning&#34; not in graph[link_name]:
                            graph[link_name][&#34;warning&#34;] = set()
                        graph[link_name][&#34;warning&#34;] |= link_group_warnings

        lwarn(count, &#34;links created.&#34;)
        return graph

    @staticmethod
    def create_extra_links_to_gender_ambiguous_words(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;There may be some words A with gender x, that list another word B as their gender-y-version, but don&#39;t have
        any gender-z-version, and word B is listet as gender z for some reason.
        This method returns a version of the given graph where A links to B as its gender-z-version.&#34;&#34;&#34;

        count = 0
        for word_name, word_data in graph.items():
            for gender_name, link_name in list(word_data[&#34;gender_map&#34;].items()):
                if graph[link_name][&#34;gender&#34;] not in word_data[&#34;gender_map&#34;]:
                    if graph[link_name][&#34;gender&#34;] != word_data[&#34;gender&#34;]:
                        word_data[&#34;gender_map&#34;][graph[link_name][&#34;gender&#34;]] = link_name
                        lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have a &#34; + graph[link_name][&#34;gender&#34;] + &#34; version, but a &#34;
                              + &#34;word it links to as its &#34; + gender_name + &#34; version is &#34; + graph[link_name][&#34;gender&#34;]
                              + &#34;.&#34;)
                        count += 1

        lwarn(count, &#34;links created.&#34;)
        return graph

    @staticmethod
    def create_gendered_versions_for_words_that_end_with_gender_indicators(graph: GeneratedGenderNounData)\
            -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Some words end on &#34;-man&#34; or &#34;-woman&#34;, or similar things like &#34;boy&#34; or &#34;maid&#34;, but don&#39;t have a male/female/
        neutral version. This method returns a version of the graph where every word of these has a male, female as well
        as neutral version. It also ensures that the resulting word doesn&#39;t end with &#34;_&#34; due to having its end or
        beginning removed, and that it doesn&#39;t create &#34;empty&#34; words.&#34;&#34;&#34;

        # ToDo: better suggestions regarding the maid/maiden/boy/girl-stuff are welcome!
        # ToDo: running replacement strategies like this when creating a tag with a GenderedNoun-object for an unknown
        #  noun might be a good idea... this would, however, require figuring out a words gender, so the table we have
        #  here would have to be accessible outside this function.
        #  Feel free to submit a pull request for this, or an issue if you see this fitting!
        gender_indicator_tuples_table = [
            (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;&#34;)]),

            (&#34;end&#34;,   [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;bean&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),  # or butler? domestic?
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)]),

            (&#34;start&#34;, [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;bean&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)])
        ]

        words_created = 0
        links_created = 0
        for word_name, word_data in list(graph.items()):
            for end_or_start, gender_indicator_tuples in gender_indicator_tuples_table:
                created_corresponding_gendered_versions = False
                for gender, gender_indicator in gender_indicator_tuples:
                    if (((end_or_start == &#34;end&#34; and word_name.endswith(gender_indicator))
                            or (end_or_start == &#34;start&#34; and word_name.startswith(gender_indicator)))
                            and gender_indicator):
                        not_applicable = False
                        if gender != &#34;neutral&#34;:
                            other_gender_indicator_tuples = [
                                t for t in gender_indicator_tuples if t != (gender, gender_indicator)]
                            for other_gender, other_gender_indicator in other_gender_indicator_tuples:
                                if other_gender not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
                                    # figure out the potential new word:
                                    if end_or_start == &#34;end&#34;:
                                        new_gendered_version = (word_name[:-len(gender_indicator)]
                                                                + other_gender_indicator)
                                    else:
                                        new_gendered_version = (other_gender_indicator
                                                                + word_name[len(gender_indicator):])
                                    new_gendered_version = new_gendered_version.lstrip(&#34;_&#34;).rstrip(&#34;_&#34;)
                                    if new_gendered_version == &#34;&#34;:
                                        not_applicable = True
                                        continue
                                    # create the new word or link to it:
                                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; ends with \&#34;-&#34; + gender_indicator
                                          + &#34;\&#34;, but it has no &#34; + other_gender + &#34; version. &#34;, end=&#34;&#34;)
                                    word_data[&#34;gender_map&#34;][other_gender] = new_gendered_version
                                    links_created += 1
                                    if new_gendered_version not in graph:
                                        lwarn(&#34;Creating one as \&#34;&#34; + new_gendered_version + &#34;\&#34;!&#34;)
                                        words_created += 1
                                        graph[new_gendered_version] = {
                                            &#34;gender&#34;: other_gender,
                                            &#34;gender_map&#34;: dict(),
                                            &#34;warning&#34;: {&#34;\&#34;&#34; + new_gendered_version
                                                        + &#34;\&#34; was automatically generated as the &#34; + other_gender
                                                        + &#34; version of a word due to the &#34;
                                                        + (&#34;ending&#34; if end_or_start == &#34;end&#34; else &#34;beginning&#34;)
                                                        + &#34; of said &#34; + &#34;word.&#34;}
                                        }
                                    else:
                                        lwarn(&#34;Linking to \&#34;&#34; + new_gendered_version + &#34;\&#34;.&#34;)
                                    # Add a new warning that a link was created between those two:
                                    if &#34;warning&#34; not in word_data:
                                        word_data[&#34;warning&#34;] = set()
                                    word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + new_gendered_version
                                                             + &#34;\&#34; was automatically linked to \&#34;&#34; + word_name
                                                             + &#34;\&#34; as its &#34; + gender + &#34; version due to the &#34;
                                                             + (&#34;ending&#34; if end_or_start == &#34;end&#34; else &#34;beginning&#34;)
                                                             + &#34; of said &#34; + &#34;word.&#34;)

                        if not not_applicable:
                            created_corresponding_gendered_versions = True
                            break
                if created_corresponding_gendered_versions:
                    break

        lwarn(words_created, &#34;new words created.&#34;)
        lwarn(links_created, &#34;new links created.&#34;)
        return graph

    @staticmethod
    def find_words_with_no_neutral_form(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;Informs about every word that does not have a neutral version, and uses this word as its own neutral version.
        Gives each of these words a neutral form by using the male version of the word by default and the female version
        if there is no male one.&#34;&#34;&#34;

        count_male = 0
        count_used_male = 0
        count_used_female = 0
        count = 0
        for word_name, word_data in list(graph.items()):
            if word_data[&#34;gender&#34;] != &#34;neutral&#34;:
                if &#34;neutral&#34; not in word_data[&#34;gender_map&#34;]:
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; is neither neutral, nor does it link to a neutral version.&#34;)
                    count += 1
                    if word_data[&#34;gender&#34;] == &#34;male&#34;:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                        if &#34;warning&#34; not in word_data:
                            word_data[&#34;warning&#34;] = set()
                        word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                                 + &#34;neutral version, and since it is male, it&#39;s automatically used as &#34;
                                                 + &#34;own neutral version. This is done because lots of words in the &#34;
                                                 + &#34;database are wrongly marked as male even though they are actually &#34;
                                                 + &#34;neutral.&#34;)
                        count_male += 1
                    elif &#34;male&#34; in word_data[&#34;gender_map&#34;]:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_data[&#34;gender_map&#34;][&#34;male&#34;]
                        if &#34;warning&#34; not in word_data:
                            word_data[&#34;warning&#34;] = set()
                        word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                                 + &#34;neutral version, and since it has a male version, this version is &#34;
                                                 + &#34;automatically used as its neutral version. This is done because &#34;
                                                 + &#34;lots of words in the  database are wrongly marked as male even &#34;
                                                 + &#34;though they are actually neutral.&#34;)
                        count_used_male += 1
                    else:
                        if &#34;warning&#34; not in word_data:
                            word_data[&#34;warning&#34;] = set()
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                        word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; neither has a male nor a female version, so &#34;
                                                 + &#34;it is used as its own neutral version.&#34;)
                        count_used_female += 1
                    lwarn(word_data[&#34;warning&#34;])

        lwarn(count, &#34;instances found.&#34;)
        lwarn(count_male, &#34;instances where male words where used as their own neutral version,&#34;)
        lwarn(count_used_male, &#34;instances where a male version of a word was used as its neutral version,&#34;)
        lwarn(count_used_female, &#34;instances where a female word was used as its own neutral version.&#34;)

        return graph

    @staticmethod
    def create_full_graph_from_web() -&gt; GeneratedGenderNounData:
        &#34;&#34;&#34;A pipeline that combines all methods of this method collection to pull a graph of gendered words from the web
        and automatically fill all holes this graph has left open.&#34;&#34;&#34;

        graph = GenderNounDataHandler.load_from_web()
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.remove_words_that_are_not_nouns(graph)

        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_sure_all_referenced_words_exist(graph)
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_all_links_two_sided(graph)

        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words(graph)
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_all_links_two_sided(graph, log_clashs=True)

        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators(graph)
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_all_links_two_sided(graph)

        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.find_words_with_no_neutral_form(graph)
        return graph</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.load_from_web"><code class="name flex">
<span>def <span class="ident">load_from_web</span></span>(<span>) â€‘>Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a JSON object describing the differently gendered versions of every gendered noun.
Word with no wordnet_senseno-attribute (that are not from wordnet) are ignored, and words with "other" as gender
are re-gendered as "neutral".</p>
<p>The data used for this is taken from <a href="https://github.com/ecmonsen/gendered_words">https://github.com/ecmonsen/gendered_words</a>
(which is not by me; see the repository for the license).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L141-L176" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def load_from_web() -&gt; GeneratedGenderNounData:
    &#34;&#34;&#34;Creates a JSON object describing the differently gendered versions of every gendered noun.
    Word with no wordnet_senseno-attribute (that are not from wordnet) are ignored, and words with &#34;other&#34; as gender
    are re-gendered as &#34;neutral&#34;.

    The data used for this is taken from https://github.com/ecmonsen/gendered_words
    (which is not by me; see the repository for the license).&#34;&#34;&#34;

    grammatical_genders = {&#34;m&#34;: &#34;male&#34;, &#34;f&#34;: &#34;female&#34;, &#34;n&#34;: &#34;neutral&#34;}

    # load from the web, in a completely wrong format that we have yet to change:
    raw_json: OriginalGenderNounData = json.loads(requests.get(
        &#34;https://raw.githubusercontent.com/phseiff/gendered_words/master/gendered_words.json&#34;).text)

    # change the format:
    result = dict()
    for word in raw_json:
        if &#34;wordnet_senseno&#34; in word:
            result[word[&#34;word&#34;]] = {&#34;gender_map&#34;: dict()}
            if &#34;gender_map&#34; in word:
                for short, long in grammatical_genders.items():
                    if short in word[&#34;gender_map&#34;]:
                        result[word[&#34;word&#34;]][&#34;gender_map&#34;][long] = word[&#34;gender_map&#34;][short][0][&#34;word&#34;].replace(
                            &#34; &#34;, &#34;_&#34;)
            if word[&#34;gender&#34;] == &#34;o&#34;:
                lwarn(&#34;Found an \&#34;other\&#34;-word! It&#39;s \&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34;.&#34;)
                result[word[&#34;word&#34;]][&#34;gender&#34;] = &#34;neutral&#34;
            else:
                result[word[&#34;word&#34;]][&#34;gender&#34;] = grammatical_genders[word[&#34;gender&#34;]]
        else:
            lwarn(&#34;\&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34; ignored because it is not part of wordnet and therefore not a hyponyms &#34;
                  + &#34;for a person.&#34;)

    lwarn(len(result), &#34;words found.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.load_from_disk"><code class="name flex">
<span>def <span class="ident">load_from_disk</span></span>(<span>file_name:Â str) â€‘>Â (typing.Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>],Â typing.Dict[str,Â str])</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the gendered nouns from a piece of json data contained in the given file.
The json object in this file must have a data-attribute, which contains the actual gendered noun data, and may
contain an arbitrary amount of meta data in the form of strings mapped to strings, which will be returned as a
dict as the second return value.
The first return value is the actual gendered noun data, with the only change being that the
<code>warnings</code>-attribute of every noun is converted from a list to a set.
This assumes the gendered noun data to be of the same type as the data used throughout all the other methods
of this class, NOT the format of the repository from which <code>load_from_web</code> loads its data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L178-L197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def load_from_disk(file_name: str) -&gt; (GeneratedGenderNounData, Dict[str, str]):
    &#34;&#34;&#34;Loads the gendered nouns from a piece of json data contained in the given file.
    The json object in this file must have a data-attribute, which contains the actual gendered noun data, and may
    contain an arbitrary amount of meta data in the form of strings mapped to strings, which will be returned as a
    dict as the second return value.
    The first return value is the actual gendered noun data, with the only change being that the
    `warnings`-attribute of every noun is converted from a list to a set.
    This assumes the gendered noun data to be of the same type as the data used throughout all the other methods
    of this class, NOT the format of the repository from which `load_from_web` loads its data.&#34;&#34;&#34;
    with open(file_name, &#34;r&#34;) as f:
        code = f.read()
    meta_data = json.loads(code)
    actual_data = meta_data[&#34;data&#34;]
    del meta_data[&#34;data&#34;]

    for word_data in actual_data.values():
        if &#34;warning&#34; in word_data:
            word_data[&#34;warning&#34;] = set(word_data[&#34;warning&#34;])
    return actual_data, meta_data</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.save_to_disk"><code class="name flex">
<span>def <span class="ident">save_to_disk</span></span>(<span>graph:Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>], file_name:Â str, **meta_data:Â Dict[str,Â str]) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the given gendered nouns data to the given file as json. The data is saved without any modifications,
except for the <code>warnings</code>-attribute of all noun data, which is converted from a set to a list to be compatible
with standard json format, in the data-attribute of the resulting json file.
<code>meta_data</code> may be used to describe additional meta data in the form of strings of the resulting file.
This assumes the given data to be of the same type as the data used throughout all the other methods of this
class, NOT the format of the repository from which <code>load_from_web</code> loads its data.
The data saved with this method can be read again with <code>load_from_disk</code>, so that <code>save_to_disk(data, file_name)</code>
implies <code>load_from_disk(file_name) == data</code>.
This method is guaranteed to not change the given data in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L199-L218" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def save_to_disk(graph: GeneratedGenderNounData, file_name: str, **meta_data: Dict[str, str]) -&gt; None:
    &#34;&#34;&#34;Saves the given gendered nouns data to the given file as json. The data is saved without any modifications,
    except for the `warnings`-attribute of all noun data, which is converted from a set to a list to be compatible
    with standard json format, in the data-attribute of the resulting json file.
    `meta_data` may be used to describe additional meta data in the form of strings of the resulting file.
    This assumes the given data to be of the same type as the data used throughout all the other methods of this
    class, NOT the format of the repository from which `load_from_web` loads its data.
    The data saved with this method can be read again with `load_from_disk`, so that `save_to_disk(data, file_name)`
    implies `load_from_disk(file_name) == data`.
    This method is guaranteed to not change the given data in-place.&#34;&#34;&#34;
    graph_copy: dict = copy.deepcopy(graph)
    for word_data in graph_copy.values():
        if &#34;warning&#34; in word_data:
            word_data[&#34;warning&#34;] = list(word_data[&#34;warning&#34;])
            word_data[&#34;warning&#34;].sort()
    resulting_data: dict = copy.deepcopy(meta_data)
    resulting_data[&#34;data&#34;] = graph_copy
    with open(file_name, &#34;w&#34;) as f:
        json.dump(resulting_data, f, indent=4, sort_keys=True)</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.remove_words_that_are_not_nouns"><code class="name flex">
<span>def <span class="ident">remove_words_that_are_not_nouns</span></span>(<span>graph:Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]) â€‘>Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes all elements that are not nouns from the graph. Words that are not nouns, but whose gendered versions
contain nouns for some reason, are not purged by this.
Returns the result.
This step should usually do nothing, since all words that are not nouns should already be filtered out when
the data is read via load_from_web, but this uses an undocumented feature of the online data set it uses, so
this function ensures that changes of that feature don't break this code.</p>
<p>This step may or may not change the given object in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L220-L245" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def remove_words_that_are_not_nouns(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
    &#34;&#34;&#34;Removes all elements that are not nouns from the graph. Words that are not nouns, but whose gendered versions
    contain nouns for some reason, are not purged by this.
    Returns the result.
    This step should usually do nothing, since all words that are not nouns should already be filtered out when
    the data is read via load_from_web, but this uses an undocumented feature of the online data set it uses, so
    this function ensures that changes of that feature don&#39;t break this code.

    This step may or may not change the given object in-place.&#34;&#34;&#34;

    grammatical_genders = [&#34;male&#34;, &#34;female&#34;, &#34;neutral&#34;]

    count = 0
    for word_name, word_data in list(graph.items()):
        is_noun = is_a_noun(word_name)
        for grammatical_gender in grammatical_genders:
            if grammatical_gender in word_data[&#34;gender_map&#34;]:
                is_noun = is_noun or is_a_noun(word_data[&#34;gender_map&#34;][grammatical_gender])
        if not is_noun:
            lwarn(&#34;Deleting \&#34;&#34; + word_name + &#34;\&#34;, since it is not a noun!&#34;)
            count += 1
            del graph[word_name]

    lwarn(count, &#34;words deleted.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.make_sure_all_referenced_words_exist"><code class="name flex">
<span>def <span class="ident">make_sure_all_referenced_words_exist</span></span>(<span>graph:Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]) â€‘>Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a version of the graph where every word linked as a differently gendered version of a word exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L247-L265" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def make_sure_all_referenced_words_exist(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
    &#34;&#34;&#34;Returns a version of the graph where every word linked as a differently gendered version of a word exists.&#34;&#34;&#34;

    count = 0
    for word_name, word_data in list(graph.items()):
        for gender_name, link_name in word_data[&#34;gender_map&#34;].items():
            if link_name not in graph:
                lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; lists \&#34;&#34; + link_name + &#34;\&#34; as its &#34; + gender_name + &#34; version, but \&#34;&#34;
                      + link_name + &#34;\&#34; does not exist in the word data file.&#34;)
                count += 1
                graph[link_name] = {&#34;gender&#34;: gender_name, &#34;gender_map&#34;: {word_data[&#34;gender&#34;]: word_name}}
            # # Commented out, since it is already covered by create_extra_links_to_gender_ambiguous_words():
            # if graph[link_name][&#34;gender&#34;] != gender_name:
            #     lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is \&#34;&#34; + word_name + &#34;\&#34;s &#34; + gender_name + &#34;s version, but is not &#34;
            #           + gender_name + &#34;.&#34;)

    lwarn(count, &#34;new words created.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.choose_better_word"><code class="name flex">
<span>def <span class="ident">choose_better_word</span></span>(<span>option1, option2, log=False)</span>
</code></dt>
<dd>
<div class="desc"><p>There are cases where a word has two different gendered versions for the same gender;
for example, "foremother" and "ancestress" are both female words for an ancestor. In these cases, the "better"
one will be chosen according to this pipeline.
This is relevant for <code>make_all_links_two_sided</code>, for example (see docstring).</p>
<p>If <code>log</code> is set, having to resort to alphabetical decisions is logged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L267-L294" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def choose_better_word(option1, option2, log=False):
    &#34;&#34;&#34;There are cases where a word has two different gendered versions for the same gender;
    for example, &#34;foremother&#34; and &#34;ancestress&#34; are both female words for an ancestor. In these cases, the &#34;better&#34;
    one will be chosen according to this pipeline.
    This is relevant for `make_all_links_two_sided`, for example (see docstring).

    If `log` is set, having to resort to alphabetical decisions is logged.&#34;&#34;&#34;

    # ToDo: Add further rules to this, or better yet, make manual (no automated data!) PRs to
    #  https://github.com/phseiff/gendered-words to clear up all these unnecessary unclearnesses.
    bad_things_in_order_of_badness: List[Callable[[str], int]] = [
        # the sooner the lambda, the worse it is:
        lambda word: len([c for c in word if c == &#34;_&#34;]),
        lambda word: int(word.endswith(&#34;man&#34;) or word.endswith(&#34;woman&#34;)),
        lambda word: int(word.endswith(&#34;person&#34;)),
        lambda word: int(word.endswith(&#34;mother&#34;) or word.endswith(&#34;father&#34;)),
        lambda word: int(word.endswith(&#34;parent&#34;))
    ]
    for badness_meter in bad_things_in_order_of_badness:
        if badness_meter(option1) &gt; badness_meter(option2):
            return option2
        elif badness_meter(option2) &gt; badness_meter(option1):
            return option1
    # otherwise, return the alphabetically first one:
    if log:
        lwarn(&#34;Had to alphabetically decide between&#34;, option1, &#34;and&#34;, option2)
    return sorted([option1, option2])[0]</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.make_all_links_two_sided"><code class="name flex">
<span>def <span class="ident">make_all_links_two_sided</span></span>(<span>graph:Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>], log_clashs=False) â€‘>Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a version of the graph where every word linked to links back to the word linking to it, if this words
gender is not yet in its gender mapping.
This also goes for triangles where a links to b and c, but b and c are not linked.</p>
<p>If <code>log_clashs</code> is set to True, clashes are logged (these are cases where there are multiple versions available
for the gendered version of a word). This should only be enabled before
<code>create_gendered_versions_for_words_that_end_with_gender_indicators</code> is called on the data for the first time,
since afterwards, multiple words might be connected that wheren't conntected before. One example would be that
"wonder_woman" and "wonder_girl" are both considered female, and both will get "wonder_person" assigned as their
neutral version by <code>create_gendered_versions_for_words_that_end_with_gender_indicators</code>. This is not an issue
since one of them already links to "wonder_boy", and the other one to "wonder_man" from the beginning, but
they will still be considered clashing by the algorithm, so calling <code>make_all_links_two_sided</code> with
<code>log_clashs</code> set to True after applying <code>create_gendered_versions_for_words_that_end_with_gender_indicators</code> to
the data will create logs for two words that don't clash more than linguistically necessary.</p>
<p>If <code>infect_warnings</code> isn't explicitely set to False, all warnings added to a word are "passed" to every word
it's linked to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L296-L437" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def make_all_links_two_sided(graph: GeneratedGenderNounData, log_clashs=False)\
        -&gt; GeneratedGenderNounData:
    &#34;&#34;&#34;Returns a version of the graph where every word linked to links back to the word linking to it, if this words
    gender is not yet in its gender mapping.
    This also goes for triangles where a links to b and c, but b and c are not linked.

    If `log_clashs` is set to True, clashes are logged (these are cases where there are multiple versions available
    for the gendered version of a word). This should only be enabled before
    `create_gendered_versions_for_words_that_end_with_gender_indicators` is called on the data for the first time,
    since afterwards, multiple words might be connected that wheren&#39;t conntected before. One example would be that
    &#34;wonder_woman&#34; and &#34;wonder_girl&#34; are both considered female, and both will get &#34;wonder_person&#34; assigned as their
    neutral version by `create_gendered_versions_for_words_that_end_with_gender_indicators`. This is not an issue
    since one of them already links to &#34;wonder_boy&#34;, and the other one to &#34;wonder_man&#34; from the beginning, but
    they will still be considered clashing by the algorithm, so calling `make_all_links_two_sided` with
    `log_clashs` set to True after applying `create_gendered_versions_for_words_that_end_with_gender_indicators` to
     the data will create logs for two words that don&#39;t clash more than linguistically necessary.

     If `infect_warnings` isn&#39;t explicitely set to False, all warnings added to a word are &#34;passed&#34; to every word
     it&#39;s linked to.&#34;&#34;&#34;

    count = 0

    # makes sure we do not report a clash twice.
    already_reported_clashes: Set[str] = set()

    def assign_value_or_use_old_one(gender_dict, gender, value):
        &#34;&#34;&#34;Assigns a gendered version (`value`) to the given `gender` in the `gender_dict`.
        If there is already a value for the given gender, a decision is made whether to replace the old value in the
        gender dict with the newfound alternative one, and we then log the decision if `log_clashs` is set, and
        collect information required to build a warning to attach to the word to indicate that there was an
        algorithmic choose between two options.&#34;&#34;&#34;
        if gender in gender_dict and gender_dict[gender] != value:
            # log the clash if it wasn&#39;t logged yet:
            clash_report = value + &#34; clashes with &#34; + gender_dict[gender]
            if log_clashs and clash_report not in already_reported_clashes:
                lwarn(clash_report)
                already_reported_clashes.add(clash_report)

            # choose the better of both options (keep the old word or rather use the new one):
            chosen_option = GenderNounDataHandler.choose_better_word(value, gender_dict[gender], log=log_clashs)
        else:
            chosen_option = value

        gender_dict[gender] = chosen_option
        gender_dict_alts[gender] |= {chosen_option, value}

    def get_all_connected_words(word_name, data: Union[Set[str], None] = None):
        &#34;&#34;&#34;Returns a set of all words that are indirectly or directly linked to the given word.&#34;&#34;&#34;
        if not data:
            data = {word_name}
        for link_name in graph[word_name][&#34;gender_map&#34;].values():
            if link_name not in data:
                data.add(link_name)
                get_all_connected_words(link_name, data)
            if link_name in link_groups:
                data |= link_groups[link_name]
        return data

    link_groups: Dict[str, Set[str]] = dict()
    words_we_already_visited: Set[str] = set()
    # first iteration is to make FULL links groups of connected words before we start linking words to each other:
    for word_name, word_data in graph.items():
        if word_name not in words_we_already_visited:

            # create group of all words that are linked to this word (including those that are once removed):
            link_group = get_all_connected_words(word_name)
            for link_name in link_group:
                if link_name in link_groups:
                    link_groups[link_name] |= link_group
                else:
                    link_groups[link_name] = link_group

            # add these words to the visited words now:
            words_we_already_visited |= link_group

    # second iteration is to actually do the linking:
    words_we_already_visited: Set[str] = set()
    for word_name in graph.keys():
        # if we did not visit this word yet:
        if word_name not in words_we_already_visited:
            link_group = link_groups[word_name]
            words_we_already_visited |= link_group

            # create a gender-dict for all of them:
            genders_we_are_very_sure_about: Set[GeneratedDataGender] = set()
            gender_dict: Dict[GeneratedDataGender, str] = dict()
            gender_dict_alts: Dict[GeneratedDataGender, Set[str]] = {&#34;female&#34;: set(), &#34;male&#34;: set(),
                                                                     &#34;neutral&#34;: set()}
            for link_name in link_group:
                # add gender of the individual...
                gender = graph[link_name][&#34;gender&#34;]
                if gender in genders_we_are_very_sure_about:
                    assign_value_or_use_old_one(gender_dict, gender, link_name)
                else:
                    gender_dict_alts[gender] = {link_name}
                    gender_dict[gender] = link_name
                genders_we_are_very_sure_about.add(gender)

                # ...as well as genders it specifies in its gender_map, but only if we couldn&#39;t find these otherwise
                for gender, link_name2 in graph[link_name][&#34;gender_map&#34;].items():
                    if gender not in genders_we_are_very_sure_about:
                        assign_value_or_use_old_one(gender_dict, gender, link_name2)

            # link words with each other, so each word gets the full gender dict to call its own,
            # but only for genders it does not have in its own original gender dict yet, so manual links in the
            # already given data take precedence:
            for link_name in link_group:
                for gender, link_name2 in gender_dict.items():
                    if gender not in graph[link_name][&#34;gender_map&#34;] and gender != graph[link_name][&#34;gender&#34;]:
                        graph[link_name][&#34;gender_map&#34;][gender] = link_name2
                        lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is (indirectly) linked to \&#34;&#34; + link_name2
                              + &#34;\&#34;, which is &#34; + graph[link_name2][&#34;gender&#34;], &#34; but \&#34;&#34; + link_name
                              + &#34;\&#34; has no &#34; + graph[link_name2][&#34;gender&#34;] + &#34; version.&#34;)
                        count += 1

                        # if the newly added link was chosen between two possible words algorithmically, add this as
                        # a warning:
                        if gender_dict_alts[gender] != {link_name2}:
                            if &#34;warning&#34; not in graph[link_name]:
                                graph[link_name][&#34;warning&#34;] = set()
                            alt_values = sorted(list(gender_dict_alts[gender]))
                            alt_values_str = &#34;, &#34;.join(alt_values[:-1]) + &#34; and &#34; + alt_values[-1]
                            new_warning = (alt_values_str + &#34; would&#39;ve all been good values for the &#34; + gender + &#34; &#34;
                                           + &#34;version of \&#34;&#34; + link_name + &#34;\&#34;, but \&#34;&#34; + link_name2
                                           + &#34;\&#34; was automatically chosen based on an algorithm.&#34;)
                            lwarn(new_warning)
                            graph[link_name][&#34;warning&#34;].add(new_warning)

            # infect linked words with the warnings of the words they&#39;re linked to:
            link_group_warnings = set()
            for link_name in link_group:
                if &#34;warning&#34; in graph[link_name]:
                    link_group_warnings |= graph[link_name][&#34;warning&#34;]
            if link_group_warnings:
                for link_name in link_group:
                    if &#34;warning&#34; not in graph[link_name]:
                        graph[link_name][&#34;warning&#34;] = set()
                    graph[link_name][&#34;warning&#34;] |= link_group_warnings

    lwarn(count, &#34;links created.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words"><code class="name flex">
<span>def <span class="ident">create_extra_links_to_gender_ambiguous_words</span></span>(<span>graph:Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]) â€‘>Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>There may be some words A with gender x, that list another word B as their gender-y-version, but don't have
any gender-z-version, and word B is listet as gender z for some reason.
This method returns a version of the given graph where A links to B as its gender-z-version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L439-L457" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def create_extra_links_to_gender_ambiguous_words(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
    &#34;&#34;&#34;There may be some words A with gender x, that list another word B as their gender-y-version, but don&#39;t have
    any gender-z-version, and word B is listet as gender z for some reason.
    This method returns a version of the given graph where A links to B as its gender-z-version.&#34;&#34;&#34;

    count = 0
    for word_name, word_data in graph.items():
        for gender_name, link_name in list(word_data[&#34;gender_map&#34;].items()):
            if graph[link_name][&#34;gender&#34;] not in word_data[&#34;gender_map&#34;]:
                if graph[link_name][&#34;gender&#34;] != word_data[&#34;gender&#34;]:
                    word_data[&#34;gender_map&#34;][graph[link_name][&#34;gender&#34;]] = link_name
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have a &#34; + graph[link_name][&#34;gender&#34;] + &#34; version, but a &#34;
                          + &#34;word it links to as its &#34; + gender_name + &#34; version is &#34; + graph[link_name][&#34;gender&#34;]
                          + &#34;.&#34;)
                    count += 1

    lwarn(count, &#34;links created.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators"><code class="name flex">
<span>def <span class="ident">create_gendered_versions_for_words_that_end_with_gender_indicators</span></span>(<span>graph:Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]) â€‘>Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Some words end on "-man" or "-woman", or similar things like "boy" or "maid", but don't have a male/female/
neutral version. This method returns a version of the graph where every word of these has a male, female as well
as neutral version. It also ensures that the resulting word doesn't end with "_" due to having its end or
beginning removed, and that it doesn't create "empty" words.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L459-L564" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def create_gendered_versions_for_words_that_end_with_gender_indicators(graph: GeneratedGenderNounData)\
        -&gt; GeneratedGenderNounData:
    &#34;&#34;&#34;Some words end on &#34;-man&#34; or &#34;-woman&#34;, or similar things like &#34;boy&#34; or &#34;maid&#34;, but don&#39;t have a male/female/
    neutral version. This method returns a version of the graph where every word of these has a male, female as well
    as neutral version. It also ensures that the resulting word doesn&#39;t end with &#34;_&#34; due to having its end or
    beginning removed, and that it doesn&#39;t create &#34;empty&#34; words.&#34;&#34;&#34;

    # ToDo: better suggestions regarding the maid/maiden/boy/girl-stuff are welcome!
    # ToDo: running replacement strategies like this when creating a tag with a GenderedNoun-object for an unknown
    #  noun might be a good idea... this would, however, require figuring out a words gender, so the table we have
    #  here would have to be accessible outside this function.
    #  Feel free to submit a pull request for this, or an issue if you see this fitting!
    gender_indicator_tuples_table = [
        (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;&#34;)]),

        (&#34;end&#34;,   [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;bean&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),  # or butler? domestic?
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)]),

        (&#34;start&#34;, [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;bean&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)])
    ]

    words_created = 0
    links_created = 0
    for word_name, word_data in list(graph.items()):
        for end_or_start, gender_indicator_tuples in gender_indicator_tuples_table:
            created_corresponding_gendered_versions = False
            for gender, gender_indicator in gender_indicator_tuples:
                if (((end_or_start == &#34;end&#34; and word_name.endswith(gender_indicator))
                        or (end_or_start == &#34;start&#34; and word_name.startswith(gender_indicator)))
                        and gender_indicator):
                    not_applicable = False
                    if gender != &#34;neutral&#34;:
                        other_gender_indicator_tuples = [
                            t for t in gender_indicator_tuples if t != (gender, gender_indicator)]
                        for other_gender, other_gender_indicator in other_gender_indicator_tuples:
                            if other_gender not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
                                # figure out the potential new word:
                                if end_or_start == &#34;end&#34;:
                                    new_gendered_version = (word_name[:-len(gender_indicator)]
                                                            + other_gender_indicator)
                                else:
                                    new_gendered_version = (other_gender_indicator
                                                            + word_name[len(gender_indicator):])
                                new_gendered_version = new_gendered_version.lstrip(&#34;_&#34;).rstrip(&#34;_&#34;)
                                if new_gendered_version == &#34;&#34;:
                                    not_applicable = True
                                    continue
                                # create the new word or link to it:
                                lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; ends with \&#34;-&#34; + gender_indicator
                                      + &#34;\&#34;, but it has no &#34; + other_gender + &#34; version. &#34;, end=&#34;&#34;)
                                word_data[&#34;gender_map&#34;][other_gender] = new_gendered_version
                                links_created += 1
                                if new_gendered_version not in graph:
                                    lwarn(&#34;Creating one as \&#34;&#34; + new_gendered_version + &#34;\&#34;!&#34;)
                                    words_created += 1
                                    graph[new_gendered_version] = {
                                        &#34;gender&#34;: other_gender,
                                        &#34;gender_map&#34;: dict(),
                                        &#34;warning&#34;: {&#34;\&#34;&#34; + new_gendered_version
                                                    + &#34;\&#34; was automatically generated as the &#34; + other_gender
                                                    + &#34; version of a word due to the &#34;
                                                    + (&#34;ending&#34; if end_or_start == &#34;end&#34; else &#34;beginning&#34;)
                                                    + &#34; of said &#34; + &#34;word.&#34;}
                                    }
                                else:
                                    lwarn(&#34;Linking to \&#34;&#34; + new_gendered_version + &#34;\&#34;.&#34;)
                                # Add a new warning that a link was created between those two:
                                if &#34;warning&#34; not in word_data:
                                    word_data[&#34;warning&#34;] = set()
                                word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + new_gendered_version
                                                         + &#34;\&#34; was automatically linked to \&#34;&#34; + word_name
                                                         + &#34;\&#34; as its &#34; + gender + &#34; version due to the &#34;
                                                         + (&#34;ending&#34; if end_or_start == &#34;end&#34; else &#34;beginning&#34;)
                                                         + &#34; of said &#34; + &#34;word.&#34;)

                    if not not_applicable:
                        created_corresponding_gendered_versions = True
                        break
            if created_corresponding_gendered_versions:
                break

    lwarn(words_created, &#34;new words created.&#34;)
    lwarn(links_created, &#34;new links created.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.find_words_with_no_neutral_form"><code class="name flex">
<span>def <span class="ident">find_words_with_no_neutral_form</span></span>(<span>graph:Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]) â€‘>Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Informs about every word that does not have a neutral version, and uses this word as its own neutral version.
Gives each of these words a neutral form by using the male version of the word by default and the female version
if there is no male one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L566-L615" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def find_words_with_no_neutral_form(graph: GeneratedGenderNounData) -&gt; GeneratedGenderNounData:
    &#34;&#34;&#34;Informs about every word that does not have a neutral version, and uses this word as its own neutral version.
    Gives each of these words a neutral form by using the male version of the word by default and the female version
    if there is no male one.&#34;&#34;&#34;

    count_male = 0
    count_used_male = 0
    count_used_female = 0
    count = 0
    for word_name, word_data in list(graph.items()):
        if word_data[&#34;gender&#34;] != &#34;neutral&#34;:
            if &#34;neutral&#34; not in word_data[&#34;gender_map&#34;]:
                lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; is neither neutral, nor does it link to a neutral version.&#34;)
                count += 1
                if word_data[&#34;gender&#34;] == &#34;male&#34;:
                    word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                    if &#34;warning&#34; not in word_data:
                        word_data[&#34;warning&#34;] = set()
                    word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                             + &#34;neutral version, and since it is male, it&#39;s automatically used as &#34;
                                             + &#34;own neutral version. This is done because lots of words in the &#34;
                                             + &#34;database are wrongly marked as male even though they are actually &#34;
                                             + &#34;neutral.&#34;)
                    count_male += 1
                elif &#34;male&#34; in word_data[&#34;gender_map&#34;]:
                    word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_data[&#34;gender_map&#34;][&#34;male&#34;]
                    if &#34;warning&#34; not in word_data:
                        word_data[&#34;warning&#34;] = set()
                    word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                             + &#34;neutral version, and since it has a male version, this version is &#34;
                                             + &#34;automatically used as its neutral version. This is done because &#34;
                                             + &#34;lots of words in the  database are wrongly marked as male even &#34;
                                             + &#34;though they are actually neutral.&#34;)
                    count_used_male += 1
                else:
                    if &#34;warning&#34; not in word_data:
                        word_data[&#34;warning&#34;] = set()
                    word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                    word_data[&#34;warning&#34;].add(&#34;\&#34;&#34; + word_name + &#34;\&#34; neither has a male nor a female version, so &#34;
                                             + &#34;it is used as its own neutral version.&#34;)
                    count_used_female += 1
                lwarn(word_data[&#34;warning&#34;])

    lwarn(count, &#34;instances found.&#34;)
    lwarn(count_male, &#34;instances where male words where used as their own neutral version,&#34;)
    lwarn(count_used_male, &#34;instances where a male version of a word was used as its neutral version,&#34;)
    lwarn(count_used_female, &#34;instances where a female word was used as its own neutral version.&#34;)

    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.create_full_graph_from_web"><code class="name flex">
<span>def <span class="ident">create_full_graph_from_web</span></span>(<span>) â€‘>Â Dict[str,Â <a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>A pipeline that combines all methods of this method collection to pull a graph of gendered words from the web
and automatically fill all holes this graph has left open.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L617-L643" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def create_full_graph_from_web() -&gt; GeneratedGenderNounData:
    &#34;&#34;&#34;A pipeline that combines all methods of this method collection to pull a graph of gendered words from the web
    and automatically fill all holes this graph has left open.&#34;&#34;&#34;

    graph = GenderNounDataHandler.load_from_web()
    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.remove_words_that_are_not_nouns(graph)

    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.make_sure_all_referenced_words_exist(graph)
    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.make_all_links_two_sided(graph)

    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words(graph)
    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.make_all_links_two_sided(graph, log_clashs=True)

    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators(graph)
    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.make_all_links_two_sided(graph)

    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.find_words_with_no_neutral_form(graph)
    return graph</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.gender_nouns.GenderedNoun"><code class="flex name class">
<span>class <span class="ident">GenderedNoun</span></span>
<span>(</span><span>word:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of a gendered noun, with methods to get gendered equivalents of it.</p>
<p>Generates an object to get gendered versions of the given noun for different genders.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L677-L734" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GenderedNoun:
    &#34;&#34;&#34;A representation of a gendered noun, with methods to get gendered equivalents of it.&#34;&#34;&#34;

    def __init__(self, word: str):
        &#34;&#34;&#34;Generates an object to get gendered versions of the given noun for different genders.&#34;&#34;&#34;

        # save the full word, but lookup the word in lowercase:
        self.word = word

        # raise warnings if the word is not a word/ noun/ person noun:
        if word not in GENDER_DICT:
            if not is_a_word(word):
                warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known word, so gender*render might not&#34;
                                                      + &#34; be able to gender it correctly.&#34;, warnings.NotAWordWarning)
            elif not is_a_noun(word):
                warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known noun, so gender*render might not&#34;
                                                      + &#34; be able to gender it correctly.&#34;, warnings.NotANounWarning)
            else:
                warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a hyponym for person, so gender*render &#34;
                                                      + &#34;might not be able to gender it correctly.&#34;,
                                                      warnings.NotAPersonNounWarning)
        elif &#34;warning&#34; in GENDER_DICT[word]:
            warnings.WarningManager.raise_warning(&#34;warnings for \&#34;&#34; + word + &#34;\&#34;:\n&#34;
                                                  + &#34;\n&#34;.join(list(GENDER_DICT[word][&#34;warning&#34;])),
                                                  warnings.NounGenderingGuessingsWarning)
            # ToDo: Maybe only print those warnings that contain `&#34;\&#34;&#34; + word + &#34;\&#34;&#34;` in them? This would require
            #  reviewing all warnings attached to words by this modules code, to be sure this actually prints all
            #  relevant warnings, as well as injecting some trivial code here and generally discussing this idea in an
            #  issue.
            #  See also the comment in test/test_gender_nouns in test_create_full_graph_from_web.

    def render_noun(self, gender: GeneratedDataGender) -&gt; str:
        &#34;&#34;&#34;Returns the correctly gendered version of itself as a string. gender must be either &#34;male&#34;, &#34;female&#34; or
        &#34;neutral&#34;.&#34;&#34;&#34;  # ToDo: Re-test this since capitalization is no longer supported.

        # return the correctly gendered version of the word:
        word = self.word
        if word in GENDER_DICT:
            word_data = GENDER_DICT[word]
            # look for the neutral version if there is no version of the given gender:
            if gender not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
                gender = &#34;neutral&#34;
            # return the word if it is the right gender:
            if GENDER_DICT[word][&#34;gender&#34;] == gender:
                result = word
            # otherwise, return the correctly gendered version from the gender_map:
            else:
                result = word_data[&#34;gender_map&#34;][gender]
        else:
            result = self.word
        return result.replace(&#34;_&#34;, &#34; &#34;)

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Checks whether two GenderedNoun-representations are identical, based on what noun they represent.&#34;&#34;&#34;
        if isinstance(other, self.__class__):
            return self.word == other.word
        else:
            return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gender_render.gender_nouns.GenderedNoun.render_noun"><code class="name flex">
<span>def <span class="ident">render_noun</span></span>(<span>self, gender:Â typing_extensions.Literal['female',Â 'male',Â 'neutral']) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the correctly gendered version of itself as a string. gender must be either "male", "female" or
"neutral".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/gender_nouns.py#L708-L727" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def render_noun(self, gender: GeneratedDataGender) -&gt; str:
    &#34;&#34;&#34;Returns the correctly gendered version of itself as a string. gender must be either &#34;male&#34;, &#34;female&#34; or
    &#34;neutral&#34;.&#34;&#34;&#34;  # ToDo: Re-test this since capitalization is no longer supported.

    # return the correctly gendered version of the word:
    word = self.word
    if word in GENDER_DICT:
        word_data = GENDER_DICT[word]
        # look for the neutral version if there is no version of the given gender:
        if gender not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
            gender = &#34;neutral&#34;
        # return the word if it is the right gender:
        if GENDER_DICT[word][&#34;gender&#34;] == gender:
            result = word
        # otherwise, return the correctly gendered version from the gender_map:
        else:
            result = word_data[&#34;gender_map&#34;][gender]
    else:
        result = self.word
    return result.replace(&#34;_&#34;, &#34; &#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="gender*render home" href="https://phseiff.com/gender-render">
<img src="https://phseiff.com/gender-render/docs/images/header-logo.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gender_render" href="index.html">gender_render</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gender_render.gender_nouns.is_a_word" href="#gender_render.gender_nouns.is_a_word">is_a_word</a></code></li>
<li><code><a title="gender_render.gender_nouns.is_a_noun" href="#gender_render.gender_nouns.is_a_noun">is_a_noun</a></code></li>
<li><code><a title="gender_render.gender_nouns.is_a_person_noun" href="#gender_render.gender_nouns.is_a_person_noun">is_a_person_noun</a></code></li>
<li><code><a title="gender_render.gender_nouns.lwarn" href="#gender_render.gender_nouns.lwarn">lwarn</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gender_render.gender_nouns.OriginalDataGenderedVersionInfo" href="#gender_render.gender_nouns.OriginalDataGenderedVersionInfo">OriginalDataGenderedVersionInfo</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.OriginalDataGenderedVersionInfo.parts_of_speech" href="#gender_render.gender_nouns.OriginalDataGenderedVersionInfo.parts_of_speech">parts_of_speech</a></code></li>
<li><code><a title="gender_render.gender_nouns.OriginalDataGenderedVersionInfo.word" href="#gender_render.gender_nouns.OriginalDataGenderedVersionInfo.word">word</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.gender_nouns.OriginalDataGenderMapping" href="#gender_render.gender_nouns.OriginalDataGenderMapping">OriginalDataGenderMapping</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.OriginalDataGenderMapping.f" href="#gender_render.gender_nouns.OriginalDataGenderMapping.f">f</a></code></li>
<li><code><a title="gender_render.gender_nouns.OriginalDataGenderMapping.m" href="#gender_render.gender_nouns.OriginalDataGenderMapping.m">m</a></code></li>
<li><code><a title="gender_render.gender_nouns.OriginalDataGenderMapping.n" href="#gender_render.gender_nouns.OriginalDataGenderMapping.n">n</a></code></li>
<li><code><a title="gender_render.gender_nouns.OriginalDataGenderMapping.h" href="#gender_render.gender_nouns.OriginalDataGenderMapping.h">h</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.gender_nouns.OriginalDataWord" href="#gender_render.gender_nouns.OriginalDataWord">OriginalDataWord</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.OriginalDataWord.word" href="#gender_render.gender_nouns.OriginalDataWord.word">word</a></code></li>
<li><code><a title="gender_render.gender_nouns.OriginalDataWord.wordnet_senseno" href="#gender_render.gender_nouns.OriginalDataWord.wordnet_senseno">wordnet_senseno</a></code></li>
<li><code><a title="gender_render.gender_nouns.OriginalDataWord.gender" href="#gender_render.gender_nouns.OriginalDataWord.gender">gender</a></code></li>
<li><code><a title="gender_render.gender_nouns.OriginalDataWord.gender_map" href="#gender_render.gender_nouns.OriginalDataWord.gender_map">gender_map</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.gender_nouns.GeneratedDataGenderMapping" href="#gender_render.gender_nouns.GeneratedDataGenderMapping">GeneratedDataGenderMapping</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.GeneratedDataGenderMapping.neutral" href="#gender_render.gender_nouns.GeneratedDataGenderMapping.neutral">neutral</a></code></li>
<li><code><a title="gender_render.gender_nouns.GeneratedDataGenderMapping.male" href="#gender_render.gender_nouns.GeneratedDataGenderMapping.male">male</a></code></li>
<li><code><a title="gender_render.gender_nouns.GeneratedDataGenderMapping.female" href="#gender_render.gender_nouns.GeneratedDataGenderMapping.female">female</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.gender_nouns.GeneratedDataWord" href="#gender_render.gender_nouns.GeneratedDataWord">GeneratedDataWord</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.GeneratedDataWord.gender" href="#gender_render.gender_nouns.GeneratedDataWord.gender">gender</a></code></li>
<li><code><a title="gender_render.gender_nouns.GeneratedDataWord.gender_map" href="#gender_render.gender_nouns.GeneratedDataWord.gender_map">gender_map</a></code></li>
<li><code><a title="gender_render.gender_nouns.GeneratedDataWord.warning" href="#gender_render.gender_nouns.GeneratedDataWord.warning">warning</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.gender_nouns.GenderNounDataHandler" href="#gender_render.gender_nouns.GenderNounDataHandler">GenderNounDataHandler</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.load_from_web" href="#gender_render.gender_nouns.GenderNounDataHandler.load_from_web">load_from_web</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.load_from_disk" href="#gender_render.gender_nouns.GenderNounDataHandler.load_from_disk">load_from_disk</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.save_to_disk" href="#gender_render.gender_nouns.GenderNounDataHandler.save_to_disk">save_to_disk</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.remove_words_that_are_not_nouns" href="#gender_render.gender_nouns.GenderNounDataHandler.remove_words_that_are_not_nouns">remove_words_that_are_not_nouns</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.make_sure_all_referenced_words_exist" href="#gender_render.gender_nouns.GenderNounDataHandler.make_sure_all_referenced_words_exist">make_sure_all_referenced_words_exist</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.choose_better_word" href="#gender_render.gender_nouns.GenderNounDataHandler.choose_better_word">choose_better_word</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.make_all_links_two_sided" href="#gender_render.gender_nouns.GenderNounDataHandler.make_all_links_two_sided">make_all_links_two_sided</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words" href="#gender_render.gender_nouns.GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words">create_extra_links_to_gender_ambiguous_words</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators" href="#gender_render.gender_nouns.GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators">create_gendered_versions_for_words_that_end_with_gender_indicators</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.find_words_with_no_neutral_form" href="#gender_render.gender_nouns.GenderNounDataHandler.find_words_with_no_neutral_form">find_words_with_no_neutral_form</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.create_full_graph_from_web" href="#gender_render.gender_nouns.GenderNounDataHandler.create_full_graph_from_web">create_full_graph_from_web</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.gender_nouns.GenderedNoun" href="#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.GenderedNoun.render_noun" href="#gender_render.gender_nouns.GenderedNoun.render_noun">render_noun</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
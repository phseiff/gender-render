<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gender_render.gender_nouns API documentation</title>
<meta name="description" content="Functions to gender nouns with gender bias correctly." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gender_render.gender_nouns</code></h1>
</header>
<section id="section-intro">
<p>Functions to gender nouns with gender bias correctly.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Functions to gender nouns with gender bias correctly.
&#34;&#34;&#34;

import requests
import json
import warnings as builtin_warnings

from . import warnings

# functions to check for the validity of (gendered) words/nouns:

try:
    import nltk
    try:
        nltk.data.find(&#34;corpora/words&#34;)
        nltk.data.find(&#34;corpora/wordnet&#34;)
    except LookupError:
        nltk.download(&#39;words&#39;)
        nltk.download(&#39;wordnet&#39;)
    from nltk.corpus import wordnet as wn
    person_synsets = set(wn.synsets(&#34;person&#34;)) | set(wn.synsets(&#34;people&#34;))
    english_person_nouns = (
        set([w.lower() for p in person_synsets for s in p.closure(lambda s: s.hyponyms()) for w in s.lemma_names()]))
    english_nouns = set(w.name().split(&#34;.&#34;)[0].lower() for w in wn.all_synsets(&#34;n&#34;)) | english_person_nouns
    english_vocab = set(w.lower() for w in nltk.corpus.words.words()) | english_nouns

    def is_a_word(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english word.&#34;&#34;&#34;
        return set(word.lower().split(&#34;_&#34;)).issubset(english_vocab) or word.lower() in english_vocab

    def is_a_noun(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english noun.&#34;&#34;&#34;
        return set(word.lower().split(&#34;_&#34;)).issubset(english_nouns) or word.lower() in english_nouns

    def is_a_person_noun(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english person noun.&#34;&#34;&#34;
        return set(word.lower().split(&#34;_&#34;)).issubset(english_person_nouns) or word.lower() in english_person_nouns

except ImportError:
    builtin_warnings.warn(&#34;The nltk-module is not installed. Some types of helpful hints and warnings may not be &#34;
                          + &#34;raised, but otherwise, this is not an issue.&#34;)

    def is_a_word(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english word.&#34;&#34;&#34;
        return True

    def is_a_noun(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english noun.&#34;&#34;&#34;
        return True

    def is_a_person_noun(word: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether the given word is a valid english person noun.&#34;&#34;&#34;
        return True

# a helper function for logging:


def lwarn(*text, sep=&#34; &#34;, end=&#34;\n&#34;):
    &#34;&#34;&#34;Prints the given text, but only if the &#34;BuildingGenderedNounDataLogging&#34;-warning is enabled.
    The name &#34;lwarn&#34; is supposed to stand for &#34;log warning&#34;.&#34;&#34;&#34;
    warnings.WarningManager.raise_warning(sep.join([str(t) for t in text]) + end,
                                          warnings.BuildingGenderedNounDataLogging)

# a pipeline for creating files that describe differently gendered versions of gendered nouns:


class GenderNounDataHandler:
    &#34;&#34;&#34;Bundles several static methods to handle and create data that describes the differently gendered versions of
    gendered nouns.
    These methods form a pipeline used for creating a full linked graph of gendered nouns.
    All methods of the pipeline print extensive logs, and may or may not modify their input in-place.&#34;&#34;&#34;

    @staticmethod
    def load_from_web() -&gt; dict:
        &#34;&#34;&#34;Creates a JSON object describing the differently gendered versions of every gendered noun.
        Word with no wordnet_senseno-attribute (that are not from wordnet) are ignored.

        The data used for this is taken from https://github.com/ecmonsen/gendered_words
        (which is not by me; see the repository for the license).&#34;&#34;&#34;

        grammatical_genders = {&#34;m&#34;: &#34;male&#34;, &#34;f&#34;: &#34;female&#34;, &#34;n&#34;: &#34;neutral&#34;}

        # load from the web, in a completely wrong format that we have yet to change:
        raw_json = json.loads(requests.get(
            &#34;https://raw.githubusercontent.com/ecmonsen/gendered_words/master/gendered_words.json&#34;).text)

        # change the format:
        result = dict()
        for word in raw_json:
            if &#34;wordnet_senseno&#34; in word:
                result[word[&#34;word&#34;]] = {&#34;gender_map&#34;: dict()}
                if &#34;gender_map&#34; in word:
                    for short, long in grammatical_genders.items():
                        if short in word[&#34;gender_map&#34;]:
                            result[word[&#34;word&#34;]][&#34;gender_map&#34;][long] = word[&#34;gender_map&#34;][short][0][&#34;word&#34;]
                if word[&#34;gender&#34;] == &#34;o&#34;:
                    lwarn(&#34;Found an \&#34;other\&#34;-word! It&#39;s \&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34;.&#34;)
                    result[word[&#34;word&#34;]][&#34;gender&#34;] = &#34;neutral&#34;
                else:
                    result[word[&#34;word&#34;]][&#34;gender&#34;] = grammatical_genders[word[&#34;gender&#34;]]
            else:
                lwarn(&#34;\&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34; ignored because it is not part of wordnet and therefore not a hyponym &#34;
                      + &#34;for a person.&#34;)

        lwarn(len(result), &#34;words found.&#34;)
        return result

    @staticmethod
    def remove_words_that_are_not_nouns(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Removes all elements that are not nouns from the graph.
        Returns the result.
        This step should usually do nothing, since all words that are not nouns should already be filtered out when
        the data is read via load_from_web, but this uses an undocumented feature of the online data set it uses, so
        this function ensures that changes of that feature don&#39;t break this code.&#34;&#34;&#34;

        grammatical_genders = [&#34;male&#34;, &#34;female&#34;, &#34;neutral&#34;]

        count = 0
        for word_name, word_data in list(graph.items()):
            is_noun = is_a_noun(word_name)
            for grammatical_gender in grammatical_genders:
                if grammatical_gender in word_data[&#34;gender_map&#34;]:
                    is_noun = is_noun or is_a_noun(word_data[&#34;gender_map&#34;][grammatical_gender])
            if not is_noun:
                lwarn(&#34;Deleting \&#34;&#34; + word_name + &#34;\&#34;, since it is not a noun!&#34;)
                count += 1
                del graph[word_name]

        lwarn(count, &#34;words deleted.&#34;)
        return graph

    @staticmethod
    def make_sure_all_referenced_words_exist(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Returns a version of the graph where every word linked as a differently gendered version of a word exists.&#34;&#34;&#34;

        count = 0
        for word_name, word_data in list(graph.items()):
            for gender_name, link_name in word_data[&#34;gender_map&#34;].items():
                if link_name not in graph:
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; lists \&#34;&#34; + link_name + &#34;\&#34; as its &#34; + gender_name + &#34; version, but \&#34;&#34;
                          + link_name + &#34;\&#34; does not exist in the word data file.&#34;)
                    count += 1
                    graph[link_name] = {&#34;gender&#34;: gender_name, &#34;gender_map&#34;: {word_data[&#34;gender&#34;]: word_name}}
                # # Commented out, since it is already covered by create_extra_links_to_gender_ambiguous_words():
                # if graph[link_name][&#34;gender&#34;] != gender_name:
                #     lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is \&#34;&#34; + word_name + &#34;\&#34;s &#34; + gender_name + &#34;s version, but is not &#34;
                #           + gender_name + &#34;.&#34;)

        lwarn(count, &#34;new words created.&#34;)
        return graph

    @staticmethod
    def make_all_links_two_sided(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Returns a version of the graph where every word linked to links back to the word linking to it, if this words
        gender is not yet in its gender mapping.
        This also goes for triangles where a links to b and c, but b and c are not linked.&#34;&#34;&#34;

        count = 0
        words_we_already_visited = set()
        for word_name, word_data in graph.items():
            # check if we already visited this word:
            word_is_first_word_of_group = True
            for gender_name, link_name in list(word_data[&#34;gender_map&#34;].items()):
                if link_name in words_we_already_visited:
                    word_is_first_word_of_group = False
            words_we_already_visited.add(word_name)
            # if we did not visit this word yet:
            if word_is_first_word_of_group:
                # create group of all words that are linked to this word (including those that are once removed):
                link_group = {word_name}
                for link_name in word_data[&#34;gender_map&#34;].values():
                    link_group.add(link_name)
                for link_name in list(link_group):
                    for link_name2 in graph[link_name][&#34;gender_map&#34;].values():
                        link_group.add(link_name2)
                # links them with each other:
                for link_name in link_group:
                    for link_name2 in link_group:
                        if link_name != link_name2:
                            if graph[link_name2][&#34;gender&#34;] not in graph[link_name][&#34;gender_map&#34;]:
                                graph[link_name][&#34;gender_map&#34;][graph[link_name2][&#34;gender&#34;]] = link_name2
                                lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is indirectly linked to \&#34;&#34; + link_name2 + &#34;\&#34;, which is &#34;
                                      + graph[link_name2][&#34;gender&#34;], &#34; but \&#34;&#34; + link_name + &#34;\&#34; has no &#34;
                                      + graph[link_name2][&#34;gender&#34;] + &#34; version.&#34;)
                                count += 1
                                # this implies that after all warnings are set, make_all_links_two_sided may only be
                                # called one more time:
                                if &#34;warning&#34; in graph[link_name2]:
                                    if &#34;warning&#34; not in graph[link_name]:
                                        graph[link_name][&#34;warning&#34;] = &#34;&#34;
                                    graph[link_name][&#34;warning&#34;] += graph[link_name2][&#34;warning&#34;]
            else:
                continue

        lwarn(count, &#34;links created.&#34;)
        return graph

    @staticmethod
    def create_extra_links_to_gender_ambiguous_words(graph: dict) -&gt; dict:
        &#34;&#34;&#34;There may be some words A with gender x, that list another word B as their gender-y-version, but don&#39;t have
        any gender-z-version, and word B is listet as gender z for some reason.
        This method returns a version of the given graph where A links to B as its gender-z-version.&#34;&#34;&#34;

        count = 0
        for word_name, world_data in graph.items():
            for gender_name, link_name in list(world_data[&#34;gender_map&#34;].items()):
                if graph[link_name][&#34;gender&#34;] not in world_data[&#34;gender_map&#34;]:
                    world_data[&#34;gender_map&#34;][graph[link_name][&#34;gender&#34;]] = link_name
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have a &#34; + graph[link_name][&#34;gender&#34;] + &#34; version, but a &#34;
                          + &#34;word it links to as its &#34; + gender_name + &#34; version is &#34; + graph[link_name][&#34;gender&#34;]
                          + &#34;.&#34;)
                    count += 1

        lwarn(count, &#34;links created.&#34;)
        return graph

    @staticmethod
    def create_gendered_versions_for_words_that_end_with_gender_indicators(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Some words end on &#34;-man&#34; or &#34;-woman&#34;, or similar things like &#34;boy&#34; or &#34;maid&#34;, but don&#39;t have a male/female/
        neutral version. This method returns a version of the graph where every word of these has a male, female as well
        as neutral version.&#34;&#34;&#34;

        # ToDo: better suggestions regarding the maid/maiden/boy/girl-stuff are welcome!
        # ToDo: running replacement strategies like this when creating a tag with a GenderedNoun-object for an unknown
        #  noun might be a good idea... this would, however, require figuring out a words gender, so the table we have
        #  here would have to be accessible outside this function.
        #  Feel free to submit a pull request for this, or an issue if you see this fitting!
        gender_indicator_tuples_table = [
            (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;&#34;)]),

            (&#34;end&#34;,   [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)]),

            (&#34;start&#34;, [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
            (&#34;start&#34;,  [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)])
        ]

        words_created = 0
        links_created = 0
        for word_name, word_data in list(graph.items()):
            for end_or_start, gender_indicator_tuples in gender_indicator_tuples_table:
                created_corresponding_gendered_versions = False
                for gender_name, gender_indicator in gender_indicator_tuples:
                    if (((end_or_start == &#34;end&#34; and word_name.endswith(gender_indicator))
                            or (end_or_start == &#34;start&#34; and word_name.startswith(gender_indicator)))
                            and gender_indicator):
                        if gender_name != &#34;neutral&#34;:
                            other_gender_indicator_tuples = [
                                t for t in gender_indicator_tuples if t != (gender_name, gender_indicator)]
                            for other_gender_name, other_gender_indicator in other_gender_indicator_tuples:
                                if other_gender_name not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
                                    if end_or_start == &#34;end&#34;:
                                        new_gendered_version = (word_name[:-len(gender_indicator)]
                                                                + other_gender_indicator)
                                    else:
                                        new_gendered_version = (other_gender_indicator
                                                                + word_name[len(gender_indicator):])
                                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; ends with \&#34;-&#34; + gender_indicator
                                          + &#34;\&#34;, but it has no &#34; + other_gender_name + &#34; version. &#34;, end=&#34;&#34;)
                                    word_data[&#34;gender_map&#34;][other_gender_name] = new_gendered_version
                                    links_created += 1
                                    if new_gendered_version not in graph:
                                        lwarn(&#34;Creating one as \&#34;&#34; + new_gendered_version + &#34;\&#34;!&#34;)
                                        words_created += 1
                                        graph[new_gendered_version] = {
                                            &#34;gender&#34;: other_gender_name,
                                            &#34;gender_map&#34;: dict(),
                                            &#34;warning&#34;: (&#34;\&#34;&#34; + new_gendered_version
                                                        + &#34; was automatically generated as the &#34; + other_gender_name
                                                        + &#34; version of \&#34;&#34; + word_name + &#34;\&#34; due to the ending of said &#34;
                                                        + &#34;word.&#34;)
                                        }
                                    else:
                                        lwarn(&#34;Linking to \&#34;&#34; + new_gendered_version + &#34;\&#34;.&#34;)
                        created_corresponding_gendered_versions = True
                        break
                if created_corresponding_gendered_versions:
                    break

        lwarn(words_created, &#34;new words created.&#34;)
        lwarn(links_created, &#34;new links created.&#34;)
        return graph

    @staticmethod
    def find_words_with_no_neutral_form(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Informs about every word that does not have a neutral version, and uses this word as its own neutral version.
        Gives each of these words a neutral form by using the male version of the word by default and the female version
        if there is no male one.&#34;&#34;&#34;

        count_male = 0
        count_used_male = 0
        count_used_female = 0
        count = 0
        for word_name, word_data in list(graph.items()):
            if word_data[&#34;gender&#34;] != &#34;neutral&#34;:
                if &#34;neutral&#34; not in word_data[&#34;gender_map&#34;]:
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; is neither neutral, nor does it link to a neutral version.&#34;)
                    count += 1
                    if word_data[&#34;gender&#34;] == &#34;male&#34;:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name,
                        word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                                + &#34;neutral version, and since it is male, it&#39;s automatically used as &#34;
                                                + &#34;own neutral version. This is done because lots of words in the &#34;
                                                + &#34;database are wrongly marked as male even though they are actually &#34;
                                                + &#34;neutral.&#34;)
                        count_male += 1
                    elif &#34;male&#34; in word_data[&#34;gender_map&#34;]:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_data[&#34;gender_map&#34;][&#34;male&#34;]
                        word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                                + &#34;neutral version, and since it has a male version, this version is &#34;
                                                + &#34;automatically used as its neutral version. This is done because &#34;
                                                + &#34;lots of words in the  database are wrongly marked as male even &#34;
                                                + &#34;though they are actually neutral.&#34;)
                        count_used_male += 1
                    else:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                        word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; neither has a male nor a female version, so &#34;
                                                + &#34;it is used as its own neutral version.&#34;)
                        count_used_female += 1
                    lwarn(word_data[&#34;warning&#34;])

        lwarn(count, &#34;instances found.&#34;)
        lwarn(count_male, &#34;instances where male words where used as their own neutral version,&#34;)
        lwarn(count_used_male, &#34;instances where a male version of a word was used as its neutral version,&#34;)
        lwarn(count_used_female, &#34;instances where a female word was used as its own neutral version.&#34;)

        return graph

    @staticmethod
    def create_full_graph_from_web() -&gt; dict:
        &#34;&#34;&#34;A pipeline that combines all methods of this method collection to pull a graph of gendered words from the web
        and automatically fill all holes this graph has left open.&#34;&#34;&#34;

        graph = GenderNounDataHandler.load_from_web()
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.remove_words_that_are_not_nouns(graph)

        for method in (
                GenderNounDataHandler.make_sure_all_referenced_words_exist,
                GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words,
                GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators,
        ):
            lwarn(&#34;&#34;)
            graph = method(graph)
            lwarn(&#34;&#34;)
            graph = GenderNounDataHandler.make_all_links_two_sided(graph)

        lwarn(&#34;&#34;)
        GenderNounDataHandler.find_words_with_no_neutral_form(graph)
        return graph


# the final dict:

GENDER_DICT: dict = GenderNounDataHandler.create_full_graph_from_web()


# Representation of a not-yet correctly gendered noun:

class GenderedNoun:
    &#34;&#34;&#34;A representation of a gendered noun, with methods to get gendered equivalents of it.&#34;&#34;&#34;

    def __init__(self, word: str):
        &#34;&#34;&#34;Generates an object to get gendered versions of the given noun for different genders.&#34;&#34;&#34;

        self.word = word

        # raise warnings if the word is not a word/ noun/ person noun:
        if not is_a_word(word):
            warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known word, so gender*render might not be &#34;
                                                  + &#34;able to gender it correctly.&#34;, warnings.NotAWordWarning)
        elif not is_a_noun(word):
            warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known noun, so gender*render might not be &#34;
                                                  + &#34;able to gender it correctly.&#34;, warnings.NotAWordWarning)
        elif not is_a_person_noun(word):
            warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known word for a profession or person, so &#34;
                                                  + &#34;gender*render might not be able to gender it correctly.&#34;,
                                                  warnings.NotAWordWarning)
        elif &#34;warning&#34; in GENDER_DICT[self.word]:
            warnings.WarningManager.raise_warning(GENDER_DICT[self.word][&#34;warning&#34;],
                                                  warnings.NounGenderingGuessingsWarning)

    def render_noun(self, gender: str) -&gt; str:
        &#34;&#34;&#34;Returns the correctly gendered version of itself as a string. g must be either &#34;male&#34;, &#34;female&#34; or
        &#34;neutral&#34;.
        Capitalisation of the first letter is identical between out- and input.&#34;&#34;&#34;
        if self.word[0].isupper():  # ToDo: Maybe add support for all-caps-writing?
            uppercase = True
        else:
            uppercase = False
        if self.word in GENDER_DICT:
            if GENDER_DICT[self.word][&#34;gender&#34;] == gender:
                return self.word
            else:
                gender_map = GENDER_DICT[self.word.lower()][&#34;gender_map&#34;]
                if gender not in gender_map:
                    gender = &#34;neural&#34;
                result = gender_map[gender]
                if uppercase:
                    return result[0].upper() + result[1:]
                else:
                    return result
        else:
            return self.word</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gender_render.gender_nouns.is_a_word"><code class="name flex">
<span>def <span class="ident">is_a_word</span></span>(<span>word: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given word is a valid english word.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_a_word(word: str) -&gt; bool:
    &#34;&#34;&#34;Checks whether the given word is a valid english word.&#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.is_a_noun"><code class="name flex">
<span>def <span class="ident">is_a_noun</span></span>(<span>word: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given word is a valid english noun.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_a_noun(word: str) -&gt; bool:
    &#34;&#34;&#34;Checks whether the given word is a valid english noun.&#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.is_a_person_noun"><code class="name flex">
<span>def <span class="ident">is_a_person_noun</span></span>(<span>word: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given word is a valid english person noun.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_a_person_noun(word: str) -&gt; bool:
    &#34;&#34;&#34;Checks whether the given word is a valid english person noun.&#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.lwarn"><code class="name flex">
<span>def <span class="ident">lwarn</span></span>(<span>*text, sep=' ', end='\n')</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the given text, but only if the "BuildingGenderedNounDataLogging"-warning is enabled.
The name "lwarn" is supposed to stand for "log warning".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lwarn(*text, sep=&#34; &#34;, end=&#34;\n&#34;):
    &#34;&#34;&#34;Prints the given text, but only if the &#34;BuildingGenderedNounDataLogging&#34;-warning is enabled.
    The name &#34;lwarn&#34; is supposed to stand for &#34;log warning&#34;.&#34;&#34;&#34;
    warnings.WarningManager.raise_warning(sep.join([str(t) for t in text]) + end,
                                          warnings.BuildingGenderedNounDataLogging)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gender_render.gender_nouns.GenderNounDataHandler"><code class="flex name class">
<span>class <span class="ident">GenderNounDataHandler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Bundles several static methods to handle and create data that describes the differently gendered versions of
gendered nouns.
These methods form a pipeline used for creating a full linked graph of gendered nouns.
All methods of the pipeline print extensive logs, and may or may not modify their input in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenderNounDataHandler:
    &#34;&#34;&#34;Bundles several static methods to handle and create data that describes the differently gendered versions of
    gendered nouns.
    These methods form a pipeline used for creating a full linked graph of gendered nouns.
    All methods of the pipeline print extensive logs, and may or may not modify their input in-place.&#34;&#34;&#34;

    @staticmethod
    def load_from_web() -&gt; dict:
        &#34;&#34;&#34;Creates a JSON object describing the differently gendered versions of every gendered noun.
        Word with no wordnet_senseno-attribute (that are not from wordnet) are ignored.

        The data used for this is taken from https://github.com/ecmonsen/gendered_words
        (which is not by me; see the repository for the license).&#34;&#34;&#34;

        grammatical_genders = {&#34;m&#34;: &#34;male&#34;, &#34;f&#34;: &#34;female&#34;, &#34;n&#34;: &#34;neutral&#34;}

        # load from the web, in a completely wrong format that we have yet to change:
        raw_json = json.loads(requests.get(
            &#34;https://raw.githubusercontent.com/ecmonsen/gendered_words/master/gendered_words.json&#34;).text)

        # change the format:
        result = dict()
        for word in raw_json:
            if &#34;wordnet_senseno&#34; in word:
                result[word[&#34;word&#34;]] = {&#34;gender_map&#34;: dict()}
                if &#34;gender_map&#34; in word:
                    for short, long in grammatical_genders.items():
                        if short in word[&#34;gender_map&#34;]:
                            result[word[&#34;word&#34;]][&#34;gender_map&#34;][long] = word[&#34;gender_map&#34;][short][0][&#34;word&#34;]
                if word[&#34;gender&#34;] == &#34;o&#34;:
                    lwarn(&#34;Found an \&#34;other\&#34;-word! It&#39;s \&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34;.&#34;)
                    result[word[&#34;word&#34;]][&#34;gender&#34;] = &#34;neutral&#34;
                else:
                    result[word[&#34;word&#34;]][&#34;gender&#34;] = grammatical_genders[word[&#34;gender&#34;]]
            else:
                lwarn(&#34;\&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34; ignored because it is not part of wordnet and therefore not a hyponym &#34;
                      + &#34;for a person.&#34;)

        lwarn(len(result), &#34;words found.&#34;)
        return result

    @staticmethod
    def remove_words_that_are_not_nouns(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Removes all elements that are not nouns from the graph.
        Returns the result.
        This step should usually do nothing, since all words that are not nouns should already be filtered out when
        the data is read via load_from_web, but this uses an undocumented feature of the online data set it uses, so
        this function ensures that changes of that feature don&#39;t break this code.&#34;&#34;&#34;

        grammatical_genders = [&#34;male&#34;, &#34;female&#34;, &#34;neutral&#34;]

        count = 0
        for word_name, word_data in list(graph.items()):
            is_noun = is_a_noun(word_name)
            for grammatical_gender in grammatical_genders:
                if grammatical_gender in word_data[&#34;gender_map&#34;]:
                    is_noun = is_noun or is_a_noun(word_data[&#34;gender_map&#34;][grammatical_gender])
            if not is_noun:
                lwarn(&#34;Deleting \&#34;&#34; + word_name + &#34;\&#34;, since it is not a noun!&#34;)
                count += 1
                del graph[word_name]

        lwarn(count, &#34;words deleted.&#34;)
        return graph

    @staticmethod
    def make_sure_all_referenced_words_exist(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Returns a version of the graph where every word linked as a differently gendered version of a word exists.&#34;&#34;&#34;

        count = 0
        for word_name, word_data in list(graph.items()):
            for gender_name, link_name in word_data[&#34;gender_map&#34;].items():
                if link_name not in graph:
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; lists \&#34;&#34; + link_name + &#34;\&#34; as its &#34; + gender_name + &#34; version, but \&#34;&#34;
                          + link_name + &#34;\&#34; does not exist in the word data file.&#34;)
                    count += 1
                    graph[link_name] = {&#34;gender&#34;: gender_name, &#34;gender_map&#34;: {word_data[&#34;gender&#34;]: word_name}}
                # # Commented out, since it is already covered by create_extra_links_to_gender_ambiguous_words():
                # if graph[link_name][&#34;gender&#34;] != gender_name:
                #     lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is \&#34;&#34; + word_name + &#34;\&#34;s &#34; + gender_name + &#34;s version, but is not &#34;
                #           + gender_name + &#34;.&#34;)

        lwarn(count, &#34;new words created.&#34;)
        return graph

    @staticmethod
    def make_all_links_two_sided(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Returns a version of the graph where every word linked to links back to the word linking to it, if this words
        gender is not yet in its gender mapping.
        This also goes for triangles where a links to b and c, but b and c are not linked.&#34;&#34;&#34;

        count = 0
        words_we_already_visited = set()
        for word_name, word_data in graph.items():
            # check if we already visited this word:
            word_is_first_word_of_group = True
            for gender_name, link_name in list(word_data[&#34;gender_map&#34;].items()):
                if link_name in words_we_already_visited:
                    word_is_first_word_of_group = False
            words_we_already_visited.add(word_name)
            # if we did not visit this word yet:
            if word_is_first_word_of_group:
                # create group of all words that are linked to this word (including those that are once removed):
                link_group = {word_name}
                for link_name in word_data[&#34;gender_map&#34;].values():
                    link_group.add(link_name)
                for link_name in list(link_group):
                    for link_name2 in graph[link_name][&#34;gender_map&#34;].values():
                        link_group.add(link_name2)
                # links them with each other:
                for link_name in link_group:
                    for link_name2 in link_group:
                        if link_name != link_name2:
                            if graph[link_name2][&#34;gender&#34;] not in graph[link_name][&#34;gender_map&#34;]:
                                graph[link_name][&#34;gender_map&#34;][graph[link_name2][&#34;gender&#34;]] = link_name2
                                lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is indirectly linked to \&#34;&#34; + link_name2 + &#34;\&#34;, which is &#34;
                                      + graph[link_name2][&#34;gender&#34;], &#34; but \&#34;&#34; + link_name + &#34;\&#34; has no &#34;
                                      + graph[link_name2][&#34;gender&#34;] + &#34; version.&#34;)
                                count += 1
                                # this implies that after all warnings are set, make_all_links_two_sided may only be
                                # called one more time:
                                if &#34;warning&#34; in graph[link_name2]:
                                    if &#34;warning&#34; not in graph[link_name]:
                                        graph[link_name][&#34;warning&#34;] = &#34;&#34;
                                    graph[link_name][&#34;warning&#34;] += graph[link_name2][&#34;warning&#34;]
            else:
                continue

        lwarn(count, &#34;links created.&#34;)
        return graph

    @staticmethod
    def create_extra_links_to_gender_ambiguous_words(graph: dict) -&gt; dict:
        &#34;&#34;&#34;There may be some words A with gender x, that list another word B as their gender-y-version, but don&#39;t have
        any gender-z-version, and word B is listet as gender z for some reason.
        This method returns a version of the given graph where A links to B as its gender-z-version.&#34;&#34;&#34;

        count = 0
        for word_name, world_data in graph.items():
            for gender_name, link_name in list(world_data[&#34;gender_map&#34;].items()):
                if graph[link_name][&#34;gender&#34;] not in world_data[&#34;gender_map&#34;]:
                    world_data[&#34;gender_map&#34;][graph[link_name][&#34;gender&#34;]] = link_name
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have a &#34; + graph[link_name][&#34;gender&#34;] + &#34; version, but a &#34;
                          + &#34;word it links to as its &#34; + gender_name + &#34; version is &#34; + graph[link_name][&#34;gender&#34;]
                          + &#34;.&#34;)
                    count += 1

        lwarn(count, &#34;links created.&#34;)
        return graph

    @staticmethod
    def create_gendered_versions_for_words_that_end_with_gender_indicators(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Some words end on &#34;-man&#34; or &#34;-woman&#34;, or similar things like &#34;boy&#34; or &#34;maid&#34;, but don&#39;t have a male/female/
        neutral version. This method returns a version of the graph where every word of these has a male, female as well
        as neutral version.&#34;&#34;&#34;

        # ToDo: better suggestions regarding the maid/maiden/boy/girl-stuff are welcome!
        # ToDo: running replacement strategies like this when creating a tag with a GenderedNoun-object for an unknown
        #  noun might be a good idea... this would, however, require figuring out a words gender, so the table we have
        #  here would have to be accessible outside this function.
        #  Feel free to submit a pull request for this, or an issue if you see this fitting!
        gender_indicator_tuples_table = [
            (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;&#34;)]),

            (&#34;end&#34;,   [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
            (&#34;end&#34;,   [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)]),

            (&#34;start&#34;, [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
            (&#34;start&#34;, [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
            (&#34;start&#34;,  [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)])
        ]

        words_created = 0
        links_created = 0
        for word_name, word_data in list(graph.items()):
            for end_or_start, gender_indicator_tuples in gender_indicator_tuples_table:
                created_corresponding_gendered_versions = False
                for gender_name, gender_indicator in gender_indicator_tuples:
                    if (((end_or_start == &#34;end&#34; and word_name.endswith(gender_indicator))
                            or (end_or_start == &#34;start&#34; and word_name.startswith(gender_indicator)))
                            and gender_indicator):
                        if gender_name != &#34;neutral&#34;:
                            other_gender_indicator_tuples = [
                                t for t in gender_indicator_tuples if t != (gender_name, gender_indicator)]
                            for other_gender_name, other_gender_indicator in other_gender_indicator_tuples:
                                if other_gender_name not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
                                    if end_or_start == &#34;end&#34;:
                                        new_gendered_version = (word_name[:-len(gender_indicator)]
                                                                + other_gender_indicator)
                                    else:
                                        new_gendered_version = (other_gender_indicator
                                                                + word_name[len(gender_indicator):])
                                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; ends with \&#34;-&#34; + gender_indicator
                                          + &#34;\&#34;, but it has no &#34; + other_gender_name + &#34; version. &#34;, end=&#34;&#34;)
                                    word_data[&#34;gender_map&#34;][other_gender_name] = new_gendered_version
                                    links_created += 1
                                    if new_gendered_version not in graph:
                                        lwarn(&#34;Creating one as \&#34;&#34; + new_gendered_version + &#34;\&#34;!&#34;)
                                        words_created += 1
                                        graph[new_gendered_version] = {
                                            &#34;gender&#34;: other_gender_name,
                                            &#34;gender_map&#34;: dict(),
                                            &#34;warning&#34;: (&#34;\&#34;&#34; + new_gendered_version
                                                        + &#34; was automatically generated as the &#34; + other_gender_name
                                                        + &#34; version of \&#34;&#34; + word_name + &#34;\&#34; due to the ending of said &#34;
                                                        + &#34;word.&#34;)
                                        }
                                    else:
                                        lwarn(&#34;Linking to \&#34;&#34; + new_gendered_version + &#34;\&#34;.&#34;)
                        created_corresponding_gendered_versions = True
                        break
                if created_corresponding_gendered_versions:
                    break

        lwarn(words_created, &#34;new words created.&#34;)
        lwarn(links_created, &#34;new links created.&#34;)
        return graph

    @staticmethod
    def find_words_with_no_neutral_form(graph: dict) -&gt; dict:
        &#34;&#34;&#34;Informs about every word that does not have a neutral version, and uses this word as its own neutral version.
        Gives each of these words a neutral form by using the male version of the word by default and the female version
        if there is no male one.&#34;&#34;&#34;

        count_male = 0
        count_used_male = 0
        count_used_female = 0
        count = 0
        for word_name, word_data in list(graph.items()):
            if word_data[&#34;gender&#34;] != &#34;neutral&#34;:
                if &#34;neutral&#34; not in word_data[&#34;gender_map&#34;]:
                    lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; is neither neutral, nor does it link to a neutral version.&#34;)
                    count += 1
                    if word_data[&#34;gender&#34;] == &#34;male&#34;:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name,
                        word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                                + &#34;neutral version, and since it is male, it&#39;s automatically used as &#34;
                                                + &#34;own neutral version. This is done because lots of words in the &#34;
                                                + &#34;database are wrongly marked as male even though they are actually &#34;
                                                + &#34;neutral.&#34;)
                        count_male += 1
                    elif &#34;male&#34; in word_data[&#34;gender_map&#34;]:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_data[&#34;gender_map&#34;][&#34;male&#34;]
                        word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                                + &#34;neutral version, and since it has a male version, this version is &#34;
                                                + &#34;automatically used as its neutral version. This is done because &#34;
                                                + &#34;lots of words in the  database are wrongly marked as male even &#34;
                                                + &#34;though they are actually neutral.&#34;)
                        count_used_male += 1
                    else:
                        word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                        word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; neither has a male nor a female version, so &#34;
                                                + &#34;it is used as its own neutral version.&#34;)
                        count_used_female += 1
                    lwarn(word_data[&#34;warning&#34;])

        lwarn(count, &#34;instances found.&#34;)
        lwarn(count_male, &#34;instances where male words where used as their own neutral version,&#34;)
        lwarn(count_used_male, &#34;instances where a male version of a word was used as its neutral version,&#34;)
        lwarn(count_used_female, &#34;instances where a female word was used as its own neutral version.&#34;)

        return graph

    @staticmethod
    def create_full_graph_from_web() -&gt; dict:
        &#34;&#34;&#34;A pipeline that combines all methods of this method collection to pull a graph of gendered words from the web
        and automatically fill all holes this graph has left open.&#34;&#34;&#34;

        graph = GenderNounDataHandler.load_from_web()
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.remove_words_that_are_not_nouns(graph)

        for method in (
                GenderNounDataHandler.make_sure_all_referenced_words_exist,
                GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words,
                GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators,
        ):
            lwarn(&#34;&#34;)
            graph = method(graph)
            lwarn(&#34;&#34;)
            graph = GenderNounDataHandler.make_all_links_two_sided(graph)

        lwarn(&#34;&#34;)
        GenderNounDataHandler.find_words_with_no_neutral_form(graph)
        return graph</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.load_from_web"><code class="name flex">
<span>def <span class="ident">load_from_web</span></span>(<span>) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a JSON object describing the differently gendered versions of every gendered noun.
Word with no wordnet_senseno-attribute (that are not from wordnet) are ignored.</p>
<p>The data used for this is taken from <a href="https://github.com/ecmonsen/gendered_words">https://github.com/ecmonsen/gendered_words</a>
(which is not by me; see the repository for the license).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_web() -&gt; dict:
    &#34;&#34;&#34;Creates a JSON object describing the differently gendered versions of every gendered noun.
    Word with no wordnet_senseno-attribute (that are not from wordnet) are ignored.

    The data used for this is taken from https://github.com/ecmonsen/gendered_words
    (which is not by me; see the repository for the license).&#34;&#34;&#34;

    grammatical_genders = {&#34;m&#34;: &#34;male&#34;, &#34;f&#34;: &#34;female&#34;, &#34;n&#34;: &#34;neutral&#34;}

    # load from the web, in a completely wrong format that we have yet to change:
    raw_json = json.loads(requests.get(
        &#34;https://raw.githubusercontent.com/ecmonsen/gendered_words/master/gendered_words.json&#34;).text)

    # change the format:
    result = dict()
    for word in raw_json:
        if &#34;wordnet_senseno&#34; in word:
            result[word[&#34;word&#34;]] = {&#34;gender_map&#34;: dict()}
            if &#34;gender_map&#34; in word:
                for short, long in grammatical_genders.items():
                    if short in word[&#34;gender_map&#34;]:
                        result[word[&#34;word&#34;]][&#34;gender_map&#34;][long] = word[&#34;gender_map&#34;][short][0][&#34;word&#34;]
            if word[&#34;gender&#34;] == &#34;o&#34;:
                lwarn(&#34;Found an \&#34;other\&#34;-word! It&#39;s \&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34;.&#34;)
                result[word[&#34;word&#34;]][&#34;gender&#34;] = &#34;neutral&#34;
            else:
                result[word[&#34;word&#34;]][&#34;gender&#34;] = grammatical_genders[word[&#34;gender&#34;]]
        else:
            lwarn(&#34;\&#34;&#34; + word[&#34;word&#34;] + &#34;\&#34; ignored because it is not part of wordnet and therefore not a hyponym &#34;
                  + &#34;for a person.&#34;)

    lwarn(len(result), &#34;words found.&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.remove_words_that_are_not_nouns"><code class="name flex">
<span>def <span class="ident">remove_words_that_are_not_nouns</span></span>(<span>graph: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Removes all elements that are not nouns from the graph.
Returns the result.
This step should usually do nothing, since all words that are not nouns should already be filtered out when
the data is read via load_from_web, but this uses an undocumented feature of the online data set it uses, so
this function ensures that changes of that feature don't break this code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_words_that_are_not_nouns(graph: dict) -&gt; dict:
    &#34;&#34;&#34;Removes all elements that are not nouns from the graph.
    Returns the result.
    This step should usually do nothing, since all words that are not nouns should already be filtered out when
    the data is read via load_from_web, but this uses an undocumented feature of the online data set it uses, so
    this function ensures that changes of that feature don&#39;t break this code.&#34;&#34;&#34;

    grammatical_genders = [&#34;male&#34;, &#34;female&#34;, &#34;neutral&#34;]

    count = 0
    for word_name, word_data in list(graph.items()):
        is_noun = is_a_noun(word_name)
        for grammatical_gender in grammatical_genders:
            if grammatical_gender in word_data[&#34;gender_map&#34;]:
                is_noun = is_noun or is_a_noun(word_data[&#34;gender_map&#34;][grammatical_gender])
        if not is_noun:
            lwarn(&#34;Deleting \&#34;&#34; + word_name + &#34;\&#34;, since it is not a noun!&#34;)
            count += 1
            del graph[word_name]

    lwarn(count, &#34;words deleted.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.make_sure_all_referenced_words_exist"><code class="name flex">
<span>def <span class="ident">make_sure_all_referenced_words_exist</span></span>(<span>graph: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a version of the graph where every word linked as a differently gendered version of a word exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def make_sure_all_referenced_words_exist(graph: dict) -&gt; dict:
    &#34;&#34;&#34;Returns a version of the graph where every word linked as a differently gendered version of a word exists.&#34;&#34;&#34;

    count = 0
    for word_name, word_data in list(graph.items()):
        for gender_name, link_name in word_data[&#34;gender_map&#34;].items():
            if link_name not in graph:
                lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; lists \&#34;&#34; + link_name + &#34;\&#34; as its &#34; + gender_name + &#34; version, but \&#34;&#34;
                      + link_name + &#34;\&#34; does not exist in the word data file.&#34;)
                count += 1
                graph[link_name] = {&#34;gender&#34;: gender_name, &#34;gender_map&#34;: {word_data[&#34;gender&#34;]: word_name}}
            # # Commented out, since it is already covered by create_extra_links_to_gender_ambiguous_words():
            # if graph[link_name][&#34;gender&#34;] != gender_name:
            #     lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is \&#34;&#34; + word_name + &#34;\&#34;s &#34; + gender_name + &#34;s version, but is not &#34;
            #           + gender_name + &#34;.&#34;)

    lwarn(count, &#34;new words created.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.make_all_links_two_sided"><code class="name flex">
<span>def <span class="ident">make_all_links_two_sided</span></span>(<span>graph: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a version of the graph where every word linked to links back to the word linking to it, if this words
gender is not yet in its gender mapping.
This also goes for triangles where a links to b and c, but b and c are not linked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def make_all_links_two_sided(graph: dict) -&gt; dict:
    &#34;&#34;&#34;Returns a version of the graph where every word linked to links back to the word linking to it, if this words
    gender is not yet in its gender mapping.
    This also goes for triangles where a links to b and c, but b and c are not linked.&#34;&#34;&#34;

    count = 0
    words_we_already_visited = set()
    for word_name, word_data in graph.items():
        # check if we already visited this word:
        word_is_first_word_of_group = True
        for gender_name, link_name in list(word_data[&#34;gender_map&#34;].items()):
            if link_name in words_we_already_visited:
                word_is_first_word_of_group = False
        words_we_already_visited.add(word_name)
        # if we did not visit this word yet:
        if word_is_first_word_of_group:
            # create group of all words that are linked to this word (including those that are once removed):
            link_group = {word_name}
            for link_name in word_data[&#34;gender_map&#34;].values():
                link_group.add(link_name)
            for link_name in list(link_group):
                for link_name2 in graph[link_name][&#34;gender_map&#34;].values():
                    link_group.add(link_name2)
            # links them with each other:
            for link_name in link_group:
                for link_name2 in link_group:
                    if link_name != link_name2:
                        if graph[link_name2][&#34;gender&#34;] not in graph[link_name][&#34;gender_map&#34;]:
                            graph[link_name][&#34;gender_map&#34;][graph[link_name2][&#34;gender&#34;]] = link_name2
                            lwarn(&#34;\&#34;&#34; + link_name + &#34;\&#34; is indirectly linked to \&#34;&#34; + link_name2 + &#34;\&#34;, which is &#34;
                                  + graph[link_name2][&#34;gender&#34;], &#34; but \&#34;&#34; + link_name + &#34;\&#34; has no &#34;
                                  + graph[link_name2][&#34;gender&#34;] + &#34; version.&#34;)
                            count += 1
                            # this implies that after all warnings are set, make_all_links_two_sided may only be
                            # called one more time:
                            if &#34;warning&#34; in graph[link_name2]:
                                if &#34;warning&#34; not in graph[link_name]:
                                    graph[link_name][&#34;warning&#34;] = &#34;&#34;
                                graph[link_name][&#34;warning&#34;] += graph[link_name2][&#34;warning&#34;]
        else:
            continue

    lwarn(count, &#34;links created.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words"><code class="name flex">
<span>def <span class="ident">create_extra_links_to_gender_ambiguous_words</span></span>(<span>graph: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>There may be some words A with gender x, that list another word B as their gender-y-version, but don't have
any gender-z-version, and word B is listet as gender z for some reason.
This method returns a version of the given graph where A links to B as its gender-z-version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_extra_links_to_gender_ambiguous_words(graph: dict) -&gt; dict:
    &#34;&#34;&#34;There may be some words A with gender x, that list another word B as their gender-y-version, but don&#39;t have
    any gender-z-version, and word B is listet as gender z for some reason.
    This method returns a version of the given graph where A links to B as its gender-z-version.&#34;&#34;&#34;

    count = 0
    for word_name, world_data in graph.items():
        for gender_name, link_name in list(world_data[&#34;gender_map&#34;].items()):
            if graph[link_name][&#34;gender&#34;] not in world_data[&#34;gender_map&#34;]:
                world_data[&#34;gender_map&#34;][graph[link_name][&#34;gender&#34;]] = link_name
                lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have a &#34; + graph[link_name][&#34;gender&#34;] + &#34; version, but a &#34;
                      + &#34;word it links to as its &#34; + gender_name + &#34; version is &#34; + graph[link_name][&#34;gender&#34;]
                      + &#34;.&#34;)
                count += 1

    lwarn(count, &#34;links created.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators"><code class="name flex">
<span>def <span class="ident">create_gendered_versions_for_words_that_end_with_gender_indicators</span></span>(<span>graph: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Some words end on "-man" or "-woman", or similar things like "boy" or "maid", but don't have a male/female/
neutral version. This method returns a version of the graph where every word of these has a male, female as well
as neutral version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_gendered_versions_for_words_that_end_with_gender_indicators(graph: dict) -&gt; dict:
    &#34;&#34;&#34;Some words end on &#34;-man&#34; or &#34;-woman&#34;, or similar things like &#34;boy&#34; or &#34;maid&#34;, but don&#39;t have a male/female/
    neutral version. This method returns a version of the graph where every word of these has a male, female as well
    as neutral version.&#34;&#34;&#34;

    # ToDo: better suggestions regarding the maid/maiden/boy/girl-stuff are welcome!
    # ToDo: running replacement strategies like this when creating a tag with a GenderedNoun-object for an unknown
    #  noun might be a good idea... this would, however, require figuring out a words gender, so the table we have
    #  here would have to be accessible outside this function.
    #  Feel free to submit a pull request for this, or an issue if you see this fitting!
    gender_indicator_tuples_table = [
        (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;&#34;)]),

        (&#34;end&#34;,   [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
        (&#34;end&#34;,   [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)]),

        (&#34;start&#34;, [(&#34;female&#34;, &#34;woman&#34;),    (&#34;male&#34;, &#34;man&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;girl&#34;),     (&#34;male&#34;, &#34;boy&#34;),        (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;maiden&#34;),   (&#34;male&#34;, &#34;gentleman&#34;),  (&#34;neutral&#34;, &#34;gentleperson&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;maid&#34;),     (&#34;male&#34;, &#34;manservant&#34;), (&#34;neutral&#34;, &#34;servant&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;aunt&#34;),     (&#34;male&#34;, &#34;uncle&#34;),      (&#34;neutral&#34;, &#34;auncle&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;daughter&#34;), (&#34;male&#34;, &#34;son&#34;),        (&#34;neutral&#34;, &#34;child&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;mother&#34;),   (&#34;male&#34;, &#34;father&#34;),     (&#34;neutral&#34;, &#34;parent&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;wife&#34;),     (&#34;male&#34;, &#34;husband&#34;),    (&#34;neutral&#34;, &#34;spouse&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;niece&#34;),    (&#34;male&#34;, &#34;nephew&#34;),     (&#34;neutral&#34;, &#34;nibling&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;female&#34;),   (&#34;male&#34;, &#34;male&#34;),       (&#34;neutral&#34;, &#34;person&#34;)]),
        (&#34;start&#34;, [(&#34;female&#34;, &#34;sister&#34;),   (&#34;male&#34;, &#34;brother&#34;),    (&#34;neutral&#34;, &#34;sibling&#34;)]),
        (&#34;start&#34;,  [(&#34;female&#34;, &#34;queen&#34;),    (&#34;male&#34;, &#34;king&#34;),       (&#34;neutral&#34;, &#34;monarch&#34;)])
    ]

    words_created = 0
    links_created = 0
    for word_name, word_data in list(graph.items()):
        for end_or_start, gender_indicator_tuples in gender_indicator_tuples_table:
            created_corresponding_gendered_versions = False
            for gender_name, gender_indicator in gender_indicator_tuples:
                if (((end_or_start == &#34;end&#34; and word_name.endswith(gender_indicator))
                        or (end_or_start == &#34;start&#34; and word_name.startswith(gender_indicator)))
                        and gender_indicator):
                    if gender_name != &#34;neutral&#34;:
                        other_gender_indicator_tuples = [
                            t for t in gender_indicator_tuples if t != (gender_name, gender_indicator)]
                        for other_gender_name, other_gender_indicator in other_gender_indicator_tuples:
                            if other_gender_name not in set(word_data[&#34;gender_map&#34;].keys()) | {word_data[&#34;gender&#34;]}:
                                if end_or_start == &#34;end&#34;:
                                    new_gendered_version = (word_name[:-len(gender_indicator)]
                                                            + other_gender_indicator)
                                else:
                                    new_gendered_version = (other_gender_indicator
                                                            + word_name[len(gender_indicator):])
                                lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; ends with \&#34;-&#34; + gender_indicator
                                      + &#34;\&#34;, but it has no &#34; + other_gender_name + &#34; version. &#34;, end=&#34;&#34;)
                                word_data[&#34;gender_map&#34;][other_gender_name] = new_gendered_version
                                links_created += 1
                                if new_gendered_version not in graph:
                                    lwarn(&#34;Creating one as \&#34;&#34; + new_gendered_version + &#34;\&#34;!&#34;)
                                    words_created += 1
                                    graph[new_gendered_version] = {
                                        &#34;gender&#34;: other_gender_name,
                                        &#34;gender_map&#34;: dict(),
                                        &#34;warning&#34;: (&#34;\&#34;&#34; + new_gendered_version
                                                    + &#34; was automatically generated as the &#34; + other_gender_name
                                                    + &#34; version of \&#34;&#34; + word_name + &#34;\&#34; due to the ending of said &#34;
                                                    + &#34;word.&#34;)
                                    }
                                else:
                                    lwarn(&#34;Linking to \&#34;&#34; + new_gendered_version + &#34;\&#34;.&#34;)
                    created_corresponding_gendered_versions = True
                    break
            if created_corresponding_gendered_versions:
                break

    lwarn(words_created, &#34;new words created.&#34;)
    lwarn(links_created, &#34;new links created.&#34;)
    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.find_words_with_no_neutral_form"><code class="name flex">
<span>def <span class="ident">find_words_with_no_neutral_form</span></span>(<span>graph: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Informs about every word that does not have a neutral version, and uses this word as its own neutral version.
Gives each of these words a neutral form by using the male version of the word by default and the female version
if there is no male one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def find_words_with_no_neutral_form(graph: dict) -&gt; dict:
    &#34;&#34;&#34;Informs about every word that does not have a neutral version, and uses this word as its own neutral version.
    Gives each of these words a neutral form by using the male version of the word by default and the female version
    if there is no male one.&#34;&#34;&#34;

    count_male = 0
    count_used_male = 0
    count_used_female = 0
    count = 0
    for word_name, word_data in list(graph.items()):
        if word_data[&#34;gender&#34;] != &#34;neutral&#34;:
            if &#34;neutral&#34; not in word_data[&#34;gender_map&#34;]:
                lwarn(&#34;\&#34;&#34; + word_name + &#34;\&#34; is neither neutral, nor does it link to a neutral version.&#34;)
                count += 1
                if word_data[&#34;gender&#34;] == &#34;male&#34;:
                    word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name,
                    word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                            + &#34;neutral version, and since it is male, it&#39;s automatically used as &#34;
                                            + &#34;own neutral version. This is done because lots of words in the &#34;
                                            + &#34;database are wrongly marked as male even though they are actually &#34;
                                            + &#34;neutral.&#34;)
                    count_male += 1
                elif &#34;male&#34; in word_data[&#34;gender_map&#34;]:
                    word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_data[&#34;gender_map&#34;][&#34;male&#34;]
                    word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; does not have an explicit, human-picked &#34;
                                            + &#34;neutral version, and since it has a male version, this version is &#34;
                                            + &#34;automatically used as its neutral version. This is done because &#34;
                                            + &#34;lots of words in the  database are wrongly marked as male even &#34;
                                            + &#34;though they are actually neutral.&#34;)
                    count_used_male += 1
                else:
                    word_data[&#34;gender_map&#34;][&#34;neutral&#34;] = word_name
                    word_data[&#34;warning&#34;] = (&#34;\&#34;&#34; + word_name + &#34;\&#34; neither has a male nor a female version, so &#34;
                                            + &#34;it is used as its own neutral version.&#34;)
                    count_used_female += 1
                lwarn(word_data[&#34;warning&#34;])

    lwarn(count, &#34;instances found.&#34;)
    lwarn(count_male, &#34;instances where male words where used as their own neutral version,&#34;)
    lwarn(count_used_male, &#34;instances where a male version of a word was used as its neutral version,&#34;)
    lwarn(count_used_female, &#34;instances where a female word was used as its own neutral version.&#34;)

    return graph</code></pre>
</details>
</dd>
<dt id="gender_render.gender_nouns.GenderNounDataHandler.create_full_graph_from_web"><code class="name flex">
<span>def <span class="ident">create_full_graph_from_web</span></span>(<span>) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>A pipeline that combines all methods of this method collection to pull a graph of gendered words from the web
and automatically fill all holes this graph has left open.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_full_graph_from_web() -&gt; dict:
    &#34;&#34;&#34;A pipeline that combines all methods of this method collection to pull a graph of gendered words from the web
    and automatically fill all holes this graph has left open.&#34;&#34;&#34;

    graph = GenderNounDataHandler.load_from_web()
    lwarn(&#34;&#34;)
    graph = GenderNounDataHandler.remove_words_that_are_not_nouns(graph)

    for method in (
            GenderNounDataHandler.make_sure_all_referenced_words_exist,
            GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words,
            GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators,
    ):
        lwarn(&#34;&#34;)
        graph = method(graph)
        lwarn(&#34;&#34;)
        graph = GenderNounDataHandler.make_all_links_two_sided(graph)

    lwarn(&#34;&#34;)
    GenderNounDataHandler.find_words_with_no_neutral_form(graph)
    return graph</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.gender_nouns.GenderedNoun"><code class="flex name class">
<span>class <span class="ident">GenderedNoun</span></span>
<span>(</span><span>word: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of a gendered noun, with methods to get gendered equivalents of it.</p>
<p>Generates an object to get gendered versions of the given noun for different genders.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenderedNoun:
    &#34;&#34;&#34;A representation of a gendered noun, with methods to get gendered equivalents of it.&#34;&#34;&#34;

    def __init__(self, word: str):
        &#34;&#34;&#34;Generates an object to get gendered versions of the given noun for different genders.&#34;&#34;&#34;

        self.word = word

        # raise warnings if the word is not a word/ noun/ person noun:
        if not is_a_word(word):
            warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known word, so gender*render might not be &#34;
                                                  + &#34;able to gender it correctly.&#34;, warnings.NotAWordWarning)
        elif not is_a_noun(word):
            warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known noun, so gender*render might not be &#34;
                                                  + &#34;able to gender it correctly.&#34;, warnings.NotAWordWarning)
        elif not is_a_person_noun(word):
            warnings.WarningManager.raise_warning(&#34;\&#34;&#34; + word + &#34;\&#34; is not a known word for a profession or person, so &#34;
                                                  + &#34;gender*render might not be able to gender it correctly.&#34;,
                                                  warnings.NotAWordWarning)
        elif &#34;warning&#34; in GENDER_DICT[self.word]:
            warnings.WarningManager.raise_warning(GENDER_DICT[self.word][&#34;warning&#34;],
                                                  warnings.NounGenderingGuessingsWarning)

    def render_noun(self, gender: str) -&gt; str:
        &#34;&#34;&#34;Returns the correctly gendered version of itself as a string. g must be either &#34;male&#34;, &#34;female&#34; or
        &#34;neutral&#34;.
        Capitalisation of the first letter is identical between out- and input.&#34;&#34;&#34;
        if self.word[0].isupper():  # ToDo: Maybe add support for all-caps-writing?
            uppercase = True
        else:
            uppercase = False
        if self.word in GENDER_DICT:
            if GENDER_DICT[self.word][&#34;gender&#34;] == gender:
                return self.word
            else:
                gender_map = GENDER_DICT[self.word.lower()][&#34;gender_map&#34;]
                if gender not in gender_map:
                    gender = &#34;neural&#34;
                result = gender_map[gender]
                if uppercase:
                    return result[0].upper() + result[1:]
                else:
                    return result
        else:
            return self.word</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gender_render.gender_nouns.GenderedNoun.render_noun"><code class="name flex">
<span>def <span class="ident">render_noun</span></span>(<span>self, gender: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the correctly gendered version of itself as a string. g must be either "male", "female" or
"neutral".
Capitalisation of the first letter is identical between out- and input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_noun(self, gender: str) -&gt; str:
    &#34;&#34;&#34;Returns the correctly gendered version of itself as a string. g must be either &#34;male&#34;, &#34;female&#34; or
    &#34;neutral&#34;.
    Capitalisation of the first letter is identical between out- and input.&#34;&#34;&#34;
    if self.word[0].isupper():  # ToDo: Maybe add support for all-caps-writing?
        uppercase = True
    else:
        uppercase = False
    if self.word in GENDER_DICT:
        if GENDER_DICT[self.word][&#34;gender&#34;] == gender:
            return self.word
        else:
            gender_map = GENDER_DICT[self.word.lower()][&#34;gender_map&#34;]
            if gender not in gender_map:
                gender = &#34;neural&#34;
            result = gender_map[gender]
            if uppercase:
                return result[0].upper() + result[1:]
            else:
                return result
    else:
        return self.word</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gender_render" href="index.html">gender_render</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gender_render.gender_nouns.is_a_word" href="#gender_render.gender_nouns.is_a_word">is_a_word</a></code></li>
<li><code><a title="gender_render.gender_nouns.is_a_noun" href="#gender_render.gender_nouns.is_a_noun">is_a_noun</a></code></li>
<li><code><a title="gender_render.gender_nouns.is_a_person_noun" href="#gender_render.gender_nouns.is_a_person_noun">is_a_person_noun</a></code></li>
<li><code><a title="gender_render.gender_nouns.lwarn" href="#gender_render.gender_nouns.lwarn">lwarn</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gender_render.gender_nouns.GenderNounDataHandler" href="#gender_render.gender_nouns.GenderNounDataHandler">GenderNounDataHandler</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.load_from_web" href="#gender_render.gender_nouns.GenderNounDataHandler.load_from_web">load_from_web</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.remove_words_that_are_not_nouns" href="#gender_render.gender_nouns.GenderNounDataHandler.remove_words_that_are_not_nouns">remove_words_that_are_not_nouns</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.make_sure_all_referenced_words_exist" href="#gender_render.gender_nouns.GenderNounDataHandler.make_sure_all_referenced_words_exist">make_sure_all_referenced_words_exist</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.make_all_links_two_sided" href="#gender_render.gender_nouns.GenderNounDataHandler.make_all_links_two_sided">make_all_links_two_sided</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words" href="#gender_render.gender_nouns.GenderNounDataHandler.create_extra_links_to_gender_ambiguous_words">create_extra_links_to_gender_ambiguous_words</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators" href="#gender_render.gender_nouns.GenderNounDataHandler.create_gendered_versions_for_words_that_end_with_gender_indicators">create_gendered_versions_for_words_that_end_with_gender_indicators</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.find_words_with_no_neutral_form" href="#gender_render.gender_nouns.GenderNounDataHandler.find_words_with_no_neutral_form">find_words_with_no_neutral_form</a></code></li>
<li><code><a title="gender_render.gender_nouns.GenderNounDataHandler.create_full_graph_from_web" href="#gender_render.gender_nouns.GenderNounDataHandler.create_full_graph_from_web">create_full_graph_from_web</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.gender_nouns.GenderedNoun" href="#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a></code></h4>
<ul class="">
<li><code><a title="gender_render.gender_nouns.GenderedNoun.render_noun" href="#gender_render.gender_nouns.GenderedNoun.render_noun">render_noun</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
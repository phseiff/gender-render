<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gender_render.parse_templates API documentation</title>
<meta name="description" content="Parser functions for gender*render templates." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gender_render.parse_templates</code></h1>
</header>
<section id="section-intro">
<p>Parser functions for gender*render templates.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Parser functions for gender*render templates.
&#34;&#34;&#34;

from typing import Tuple, Callable, List, Dict, Union, FrozenSet

from . import errors
from . import handle_context_values
from . import gender_nouns

# Some helpful type hints:


ParsedTemplate = List[Union[str, List[Tuple[str, List[str]]]]]
&#34;&#34;&#34;A type hint describing a parsed template as it is returned by most of the methods of GRParser.
Note that not any structure build according to this constructor is valid, since some aspects cannot be described
by Python type hints.&#34;&#34;&#34;

ParsedTemplateRefined = List[Union[str, Dict[str, Union[str, List[str], gender_nouns.GenderedNoun]]]]
&#34;&#34;&#34;A type similar to GRParser.ParsedTemplate that makes the sections of tags easier accessible by making them
dicts instead of lists of tuples.&#34;&#34;&#34;

# definitions of words and word groups accepted by the finite state machine:


class Chars:
    &#34;&#34;&#34;Helper to categorize characters.&#34;&#34;&#34;
    escape_char = &#34;\\&#34;
    whitespace_chars = &#34;\t\n \u200B&#34;
    special_chars = &#34;:*{}\\&#34;
    ws = &#34;whitespace&#34;
    char = &#34;non-special chars&#34;

    @staticmethod
    def type(c: str) -&gt; str:
        &#34;&#34;&#34;Returns the type of character c, which determines how states in the finite state machine that describes
        gender*render syntax transition to each other.
        This is either Chars.ws (whitespace), a special character or Chars.char (anything else).&#34;&#34;&#34;
        if c in Chars.special_chars:
            return c
        elif c in Chars.whitespace_chars:
            return Chars.ws
        else:
            return Chars.char

    @staticmethod
    def escape_gr_string(s: str) -&gt; str:
        &#34;&#34;&#34;Escapes all special gender*render characters in a string, such as {, }, \\, : and *, with backslashs.&#34;&#34;&#34;
        i = len(s) - 1
        while i &gt; -1:
            if s[i] in Chars.special_chars:
                s = s[:i] + &#34;\\&#34; + s[i:]
            i -= 1
        return s

# definitions of states of the finite state machine:


class States:
    &#34;&#34;&#34;Combines values for all sections the finite state machine that describes the syntax can be in, as well as
    methods to handle the special escaped/unescaped versions of all states.&#34;&#34;&#34;

    # Currently, the read character is...
    not_within_tags = &#34;...not part of any tag&#34;

    in_empty_section = &#34;...in a yet empty section&#34;
    in_not_empty_section = &#34;...in a not anymore empty section&#34;
    in_section_with_one_finished_word = &#34;...in a section which already contains a finished word&#34;

    in_empty_value_section = &#34;...in a yet empty value section&#34;
    in_not_empty_value_section = &#34;...in a not empty value section&#34;

    escaped = &#34;...and escaped&#34;

    @staticmethod
    def escape(state: str) -&gt; str:
        &#34;&#34;&#34;Converts an unescaped state to its escaped equivalent.&#34;&#34;&#34;
        assert not States.is_escaped(state)
        return state + States.escaped

    @staticmethod
    def unescape(state: str) -&gt; str:
        &#34;&#34;&#34;Convert an escaped state to its unescaped equivalent.&#34;&#34;&#34;
        assert States.is_escaped(state)
        return state[:len(state)-len(States.escaped)]

    @staticmethod
    def is_escaped(state: str) -&gt; bool:
        &#34;&#34;&#34;Checks is the current char is an escaped char.&#34;&#34;&#34;
        return state.endswith(States.escaped)

    @staticmethod
    def switch_escapement(state: str) -&gt; str:
        &#34;&#34;&#34;Returns the escaped or unescaped state of the given state, depending on whether it is currently escaped or
        not.&#34;&#34;&#34;
        return States.escape(state) if not States.is_escaped(state) else States.unescape(state)

# the finite state machine, but without the escaped versions of all states since these are handled separately:


class StateTransitioner:
    &#34;&#34;&#34;Translates between states using a finite state machine.
    This does not take into account the ability to escape characters.&#34;&#34;&#34;

    state_transitions = {
        States.not_within_tags: {
            &#34;{&#34;: (States.in_empty_section,
                lambda r, c: r+[[(&#34;&#34;, [])]]),
            Chars.char: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c]),
            Chars.ws: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c])  # ToDo: Add this to graphic in spec.tex!
        },
        States.in_empty_section: {
            Chars.ws: (States.in_empty_section,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0]+c, r[-1][-1][1])]])
        },
        States.in_not_empty_section: {
            &#34;:&#34;: (States.in_empty_value_section,
                lambda r, c: r),
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]])], &#34;&#34;]),
            Chars.ws: (States.in_section_with_one_finished_word,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0]+c, r[-1][-1][1])]])
        },
        States.in_section_with_one_finished_word: {
            &#34;:&#34;: (States.in_empty_value_section,
                lambda r, c: r),
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])], &#34;&#34;]),
            Chars.ws: (States.in_section_with_one_finished_word,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]])]])
        },
        States.in_empty_value_section: {
            Chars.ws: (States.in_empty_value_section,  # ToDo: Add this to graphic in spec.tex!
                lambda r, c: r),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1][:-1]+[
                    ((r[-1][-1][1][-1]+c) if len(r[-1][-1][1]) &gt; 0 else c)
                ])]])
        },
        States.in_not_empty_value_section: {
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1]+[(&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r+[&#34;&#34;]),
            Chars.ws: (States.in_not_empty_value_section,
                lambda r, c: r[:-1] + [r[-1][:-1] + [(r[-1][-1][0], r[-1][-1][1]
                       + ([&#34;&#34;] if r[-1][-1][1][-1] != &#34;&#34; else []))]]),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1][:-1]+[(r[-1][-1][1][-1]+c)])]])
        }
    }

    @staticmethod
    def transition_state(state: str, char: str) -&gt; Tuple[str, Callable[[ParsedTemplate, str], ParsedTemplate]]:
        &#34;&#34;&#34;For a given state s and a given character c, returns the next state s2 and a function that takes a
        list representation of the already-parsed data and c and returns a modified, extended duplicate of the data
        based on c.&#34;&#34;&#34;
        type_of_char = Chars.type(char)
        if type_of_char in StateTransitioner.state_transitions[state]:
            return StateTransitioner.state_transitions[state][type_of_char]
        else:
            raise errors.SyntaxError(&#34;Parsing error: \&#34;&#34; + type_of_char + &#34;\&#34; may not occur if it is &#34; + state[3:])

# define different section types:


class SectionTypes:
    &#34;&#34;&#34;Capsules a mapping of priorities to section types and methods to assign section types to un-typed sections.&#34;&#34;&#34;

    section_types_w_priorities = [
        (&#34;context&#34;, 1000., True),
        (&#34;id&#34;, 700., False)
    ]
    &#34;&#34;&#34;All supported section types as a list of tuples in the form of (name, priority, can_have_multiple_values)&#34;&#34;&#34;

    @staticmethod
    def section_type_accepts_multiple_values(section_type: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether a section type can have multiple whitespace-separated values.&#34;&#34;&#34;
        return SectionTypes.section_type_exists(section_type) and bool(
            [i for i in range(len(SectionTypes.section_types_w_priorities))
             if SectionTypes.section_types_w_priorities[i][0] == section_type
             and SectionTypes.section_types_w_priorities[i][2] is True]
        )

    @staticmethod
    def section_type_exists(section_type: str) -&gt; bool:
        &#34;&#34;&#34;Checks if a section type exists.&#34;&#34;&#34;
        return bool(
            [i for i in range(len(SectionTypes.section_types_w_priorities))
             if SectionTypes.section_types_w_priorities[i][0] == section_type]
        )

    @staticmethod
    def create_section_types_for_untyped_tag(section_types: List[str]) -&gt; List[str]:
        &#34;&#34;&#34;Receives a list of section types in a tag (in chronological order) and assigns section types to those
        section without a section type, in accordance with the priorities of section types and the specification.
        Returns the typed section type list.
        Raises errors if section matching can not be done, or if no context section could be found.&#34;&#34;&#34;
        result = list()

        # get all explicitly specified section types into a set:
        already_used = set()
        if len(section_types) &gt; len(SectionTypes.section_types_w_priorities):
            raise errors.SyntaxPostprocessingError(&#34;Tag contains more sections than there are section types.&#34;)
        for section_type in filter(lambda x: x != &#34;&#34;, section_types):
            if section_type in already_used:
                raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; used twice in a tag.&#34;)
            elif not SectionTypes.section_type_exists(section_type):
                raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; does not exist.&#34;)
            else:
                already_used.add(section_type)

        # create a section priority queue without these element:
        available_sections_types = [s for s in SectionTypes.section_types_w_priorities if s[0] not in already_used]
        available_sections_types.sort(key=lambda s: s[1])

        # iterate over all declared section types from the left to the right:
        for section_type in reversed(section_types):
            if section_type == &#34;&#34;:
                result.insert(0, available_sections_types.pop()[0])
            else:
                result.insert(0, section_type)

        # raise an error if there is no context value:
        if &#34;context&#34; not in result:
            raise errors.SyntaxPostprocessingError(&#34;Tag misses a \&#34;context\&#34;-section.&#34;)

        return result


# translate the content of gender*render templates into basic parsed lists:


class GRParser:
    &#34;&#34;&#34;Unites several static methods of a pipeline for parsing gender*render templates from strings into a list format
    and refining this representation to the maximum extend possible without additionally seeing the corresponding
    gender*render pronoun data.&#34;&#34;&#34;

    @staticmethod
    def parse_gr_template_from_str(template: str, debug_log=False) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a gender*render template as a string and returns it as an easily readable list representation.
        This does only syntactic parsing in accordance to the defining finite state machine;
        further steps in the parsing pipeline are implemented by other methods of this parser.

        The resulting output is of the following structure:
        * value of a section: represented by lists of strings
        * type of section: represented by a string
        * section: tuple of type representation and value representation
        * tag: list of section representation
        * template: list, where every uneven element represents a tag and every even element is a string

        Special characters are all unescaped in the parsed version of the template.&#34;&#34;&#34;

        result = [&#34;&#34;]
        s = States.not_within_tags
        line_no = 1
        char_no = 1
        # iterate over all characters:
        for i in range(len(template)):
            c = template[i]
            # increment char count for SyntaxError raising:
            if c == &#34;\n&#34;:
                line_no += 1
                char_no = 1
            else:
                char_no += 1

            # log:
            if debug_log:
                print(&#34;c:&#34;, c)
                print(&#34;s:&#34;, s)
                print(&#34;char type:&#34;, Chars.type(c))
                print(&#34;result:&#34;, result)

            # do the work of the finite state machine:
            type_of_char = Chars.type(c)
            if States.is_escaped(s):
                s = States.unescape(s)
                result = StateTransitioner.state_transitions[s][Chars.char][1](result, c)
            else:
                if type_of_char == Chars.escape_char:
                    s = States.escape(s)
                else:
                    try:
                        s, processing_function = StateTransitioner.transition_state(s, c)
                        result = processing_function(result, c)
                    except errors.SyntaxError:
                        raise errors.SyntaxError(
                            &#34;The given gender*render template has invalid syntax.&#34;,
                            (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[line_no - 1])
                        )

        # raise an error if the template ends unproperly:
        if States.is_escaped(s):
            raise errors.SyntaxError(&#34;The template ends with an unescaped escape character, please escape it.&#34;,
                                     (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))
        elif s != States.not_within_tags:
            raise errors.SyntaxError(&#34;A tag opens, but is not finished properly.&#34;,
                                     (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))

        return result

    @staticmethod
    def assign_types_to_all_sections(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and assigns every section of undefined
        type a section type.&#34;&#34;&#34;
        result = parsed_template.copy()
        for i in range(1, len(result), 2):
            old_section_types = [section[0] for section in result[i]]
            new_section_types = SectionTypes.create_section_types_for_untyped_tag(old_section_types)
            result[i] = [(new_section_types[s], result[i][s][1]) for s in range(len(result[i]))]
        return result

    @staticmethod
    def split_tags_with_multiple_context_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and splits every tag into a sequence of
        tags, one for every context value of the tag.
        This assumes that every section was already assigned a type by GRParser.assign_types_to_all_sections, and may
        lead to wrong results otherwise.&#34;&#34;&#34;
        result = parsed_template.copy()
        for i in reversed(range(1, len(result), 2)):
            tag_without_context_section = [section for section in result[i] if section[0] != &#34;context&#34;]
            tag_but_only_context_section = [section for section in result[i] if section[0] == &#34;context&#34;]

            # split tag into one tag for every context value:
            context_values = tag_but_only_context_section.pop()[1]
            sequence_of_tags = [
                (tag_without_context_section.copy() + [(&#34;context&#34;, [context_value])])
                for context_value in context_values
            ]
            for j in reversed(range(1, len(sequence_of_tags))):
                sequence_of_tags.insert(j, &#34;&#34;)
            result[i:i+1] = sequence_of_tags

        return result

    @staticmethod
    def convert_tags_to_indexable_dicts(parsed_template: ParsedTemplate) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and converts every tag from a
        representation a la &#34;[(a, b), (c, d)]&#34; to a representation a la &#34;{a: b, c: d}&#34;.
        This makes the value of specific types of sections easier to access by other methods.
        Note that the result returned by this method is different in that it is not accepted by the other methods of
        GRParser, and that this method should thus be the last method in this pipeline to be used.
        Raises an error if a section has multiple values yet accepts only one.&#34;&#34;&#34;
        result = parsed_template.copy()
        for i in range(len(parsed_template)):
            if i % 2:  # is a tag
                new_tag = dict()
                for section_type, section_values in parsed_template[i]:
                    if SectionTypes.section_type_accepts_multiple_values(section_type) and section_type != &#34;context&#34;:
                        new_tag[section_type] = section_values
                    else:
                        if len(section_values) &gt; 1:
                            raise errors.SyntaxPostprocessingError(&#34;Tag no. &#34; + str(i / 2) + &#34;(&#34;
                                                                   + ReGRParser.unparse_gr_tag(parsed_template[i])
                                                                   + &#34;) has multiple values in \&#34;&#34;
                                                                   + section_type +
                                                                   &#34;\&#34;-section even though this type of section does&#34;
                                                                   + &#34; not support this.&#34;)
                        else:
                            new_tag[section_type] = section_values[0]
                result[i] = new_tag

        return result

    @staticmethod
    def convert_context_values_to_canonicals(parsed_template: ParsedTemplateRefined) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Converts a parsed template as returned by GRParser.convert_tags_to_indexable_dicts to a parsed template
        where every context value is canonical.&#34;&#34;&#34;
        result = parsed_template.copy()
        for i in range(1, len(parsed_template), 2):
            result[i][&#34;context&#34;] = handle_context_values.ContextValues.get_canonical(result[i][&#34;context&#34;])
        return result

    @staticmethod
    def full_parsing_pipeline(template: str) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Walks template through the full parsing pipeline defined by GRParser, and returns the result.&#34;&#34;&#34;
        template = GRParser.parse_gr_template_from_str(template)
        template = GRParser.assign_types_to_all_sections(template)
        template = GRParser.split_tags_with_multiple_context_values(template)
        template = GRParser.convert_tags_to_indexable_dicts(template)
        template = GRParser.convert_context_values_to_canonicals(template)
        return template

    @staticmethod
    def get_all_specified_id_values(parsed_template: ParsedTemplateRefined) -&gt; FrozenSet[str]:
        &#34;&#34;&#34;Returns a frozen set of all id values explicitly specified by tags in the parsed template.&#34;&#34;&#34;
        return frozenset(
            parsed_template[i][&#34;id&#34;] for i in range(1, len(parsed_template), 2) if &#34;id&#34; in parsed_template[i]
        )

    @staticmethod
    def pronoun_data_contains_unspecified_ids(parsed_template: ParsedTemplateRefined) -&gt; bool:
        &#34;&#34;&#34;Returns whether the parsed template contains tags with unspecified id value.&#34;&#34;&#34;
        return bool(list(
            parsed_template[i] for i in range(1, len(parsed_template), 2) if &#34;id&#34; not in parsed_template[i]
        ))

# functions to reverse parsed templates for testing and simplification purposes:


class ReGRParser:
    &#34;&#34;&#34;Bundles methods to get a valid gender*render template from &#34;&#34;&#34;

    @staticmethod
    def unparse_gr_tag(tag_representation: list) -&gt; str:
        return &#34;{&#34; + &#34;*&#34;.join([(
                            ((Chars.escape_gr_string(section[0]) + &#34;:&#34;) if section[0] else &#34;&#34;)
                            + &#34; &#34;.join([Chars.escape_gr_string(value) for value in section[1]])
                        ) for section in tag_representation]) + &#34;}&#34;

    @staticmethod
    def unparse_gr_template_from_parsed_gr_template(parsed_template: list) -&gt; str:
        &#34;&#34;&#34;Takes the result of any method of the GRParser class and returns a template (as a string) that corresponds to
        the given parsed template.
        This may be used for testing purposes or to simplify gender*render templates.&#34;&#34;&#34;
        result = str()
        for i in range(len(parsed_template)):
            if i % 2:  # is a tag
                result += ReGRParser.unparse_gr_tag(parsed_template[i])
            else:  # is a string
                result += Chars.escape_gr_string(parsed_template[i])
        return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gender_render.parse_templates.List"><code class="flex name class">
<span>class <span class="ident">ParsedTemplate</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>list() -&gt; new empty list
list(iterable) -&gt; new list initialized from iterable's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class List(list, MutableSequence[T], extra=list):

    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if cls._gorg is List:
            raise TypeError(&#34;Type List cannot be instantiated; &#34;
                            &#34;use list() instead&#34;)
        return _generic_new(list, cls, *args, **kwds)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.List</li>
<li>builtins.list</li>
<li>typing.MutableSequence</li>
<li>collections.abc.MutableSequence</li>
<li>typing.Sequence</li>
<li>collections.abc.Sequence</li>
<li>typing.Reversible</li>
<li>collections.abc.Reversible</li>
<li>typing.Collection</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>typing.Iterable</li>
<li>collections.abc.Iterable</li>
<li>typing.Container</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="gender_render.parse_templates.List"><code class="flex name class">
<span>class <span class="ident">ParsedTemplateRefined</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>list() -&gt; new empty list
list(iterable) -&gt; new list initialized from iterable's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class List(list, MutableSequence[T], extra=list):

    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if cls._gorg is List:
            raise TypeError(&#34;Type List cannot be instantiated; &#34;
                            &#34;use list() instead&#34;)
        return _generic_new(list, cls, *args, **kwds)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.List</li>
<li>builtins.list</li>
<li>typing.MutableSequence</li>
<li>collections.abc.MutableSequence</li>
<li>typing.Sequence</li>
<li>collections.abc.Sequence</li>
<li>typing.Reversible</li>
<li>collections.abc.Reversible</li>
<li>typing.Collection</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>typing.Iterable</li>
<li>collections.abc.Iterable</li>
<li>typing.Container</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="gender_render.parse_templates.Chars"><code class="flex name class">
<span>class <span class="ident">Chars</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper to categorize characters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chars:
    &#34;&#34;&#34;Helper to categorize characters.&#34;&#34;&#34;
    escape_char = &#34;\\&#34;
    whitespace_chars = &#34;\t\n \u200B&#34;
    special_chars = &#34;:*{}\\&#34;
    ws = &#34;whitespace&#34;
    char = &#34;non-special chars&#34;

    @staticmethod
    def type(c: str) -&gt; str:
        &#34;&#34;&#34;Returns the type of character c, which determines how states in the finite state machine that describes
        gender*render syntax transition to each other.
        This is either Chars.ws (whitespace), a special character or Chars.char (anything else).&#34;&#34;&#34;
        if c in Chars.special_chars:
            return c
        elif c in Chars.whitespace_chars:
            return Chars.ws
        else:
            return Chars.char

    @staticmethod
    def escape_gr_string(s: str) -&gt; str:
        &#34;&#34;&#34;Escapes all special gender*render characters in a string, such as {, }, \\, : and *, with backslashs.&#34;&#34;&#34;
        i = len(s) - 1
        while i &gt; -1:
            if s[i] in Chars.special_chars:
                s = s[:i] + &#34;\\&#34; + s[i:]
            i -= 1
        return s</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.parse_templates.Chars.escape_char"><code class="name">var <span class="ident">escape_char</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.Chars.whitespace_chars"><code class="name">var <span class="ident">whitespace_chars</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.Chars.special_chars"><code class="name">var <span class="ident">special_chars</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.Chars.ws"><code class="name">var <span class="ident">ws</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.Chars.char"><code class="name">var <span class="ident">char</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.Chars.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>c: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the type of character c, which determines how states in the finite state machine that describes
gender*render syntax transition to each other.
This is either Chars.ws (whitespace), a special character or Chars.char (anything else).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def type(c: str) -&gt; str:
    &#34;&#34;&#34;Returns the type of character c, which determines how states in the finite state machine that describes
    gender*render syntax transition to each other.
    This is either Chars.ws (whitespace), a special character or Chars.char (anything else).&#34;&#34;&#34;
    if c in Chars.special_chars:
        return c
    elif c in Chars.whitespace_chars:
        return Chars.ws
    else:
        return Chars.char</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.Chars.escape_gr_string"><code class="name flex">
<span>def <span class="ident">escape_gr_string</span></span>(<span>s: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Escapes all special gender<em>render characters in a string, such as {, }, \, : and </em>, with backslashs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def escape_gr_string(s: str) -&gt; str:
    &#34;&#34;&#34;Escapes all special gender*render characters in a string, such as {, }, \\, : and *, with backslashs.&#34;&#34;&#34;
    i = len(s) - 1
    while i &gt; -1:
        if s[i] in Chars.special_chars:
            s = s[:i] + &#34;\\&#34; + s[i:]
        i -= 1
    return s</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.States"><code class="flex name class">
<span>class <span class="ident">States</span></span>
</code></dt>
<dd>
<div class="desc"><p>Combines values for all sections the finite state machine that describes the syntax can be in, as well as
methods to handle the special escaped/unescaped versions of all states.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class States:
    &#34;&#34;&#34;Combines values for all sections the finite state machine that describes the syntax can be in, as well as
    methods to handle the special escaped/unescaped versions of all states.&#34;&#34;&#34;

    # Currently, the read character is...
    not_within_tags = &#34;...not part of any tag&#34;

    in_empty_section = &#34;...in a yet empty section&#34;
    in_not_empty_section = &#34;...in a not anymore empty section&#34;
    in_section_with_one_finished_word = &#34;...in a section which already contains a finished word&#34;

    in_empty_value_section = &#34;...in a yet empty value section&#34;
    in_not_empty_value_section = &#34;...in a not empty value section&#34;

    escaped = &#34;...and escaped&#34;

    @staticmethod
    def escape(state: str) -&gt; str:
        &#34;&#34;&#34;Converts an unescaped state to its escaped equivalent.&#34;&#34;&#34;
        assert not States.is_escaped(state)
        return state + States.escaped

    @staticmethod
    def unescape(state: str) -&gt; str:
        &#34;&#34;&#34;Convert an escaped state to its unescaped equivalent.&#34;&#34;&#34;
        assert States.is_escaped(state)
        return state[:len(state)-len(States.escaped)]

    @staticmethod
    def is_escaped(state: str) -&gt; bool:
        &#34;&#34;&#34;Checks is the current char is an escaped char.&#34;&#34;&#34;
        return state.endswith(States.escaped)

    @staticmethod
    def switch_escapement(state: str) -&gt; str:
        &#34;&#34;&#34;Returns the escaped or unescaped state of the given state, depending on whether it is currently escaped or
        not.&#34;&#34;&#34;
        return States.escape(state) if not States.is_escaped(state) else States.unescape(state)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.parse_templates.States.not_within_tags"><code class="name">var <span class="ident">not_within_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_empty_section"><code class="name">var <span class="ident">in_empty_section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_not_empty_section"><code class="name">var <span class="ident">in_not_empty_section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_section_with_one_finished_word"><code class="name">var <span class="ident">in_section_with_one_finished_word</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_empty_value_section"><code class="name">var <span class="ident">in_empty_value_section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_not_empty_value_section"><code class="name">var <span class="ident">in_not_empty_value_section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.escaped"><code class="name">var <span class="ident">escaped</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.States.escape"><code class="name flex">
<span>def <span class="ident">escape</span></span>(<span>state: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts an unescaped state to its escaped equivalent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def escape(state: str) -&gt; str:
    &#34;&#34;&#34;Converts an unescaped state to its escaped equivalent.&#34;&#34;&#34;
    assert not States.is_escaped(state)
    return state + States.escaped</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.States.unescape"><code class="name flex">
<span>def <span class="ident">unescape</span></span>(<span>state: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an escaped state to its unescaped equivalent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unescape(state: str) -&gt; str:
    &#34;&#34;&#34;Convert an escaped state to its unescaped equivalent.&#34;&#34;&#34;
    assert States.is_escaped(state)
    return state[:len(state)-len(States.escaped)]</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.States.is_escaped"><code class="name flex">
<span>def <span class="ident">is_escaped</span></span>(<span>state: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks is the current char is an escaped char.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_escaped(state: str) -&gt; bool:
    &#34;&#34;&#34;Checks is the current char is an escaped char.&#34;&#34;&#34;
    return state.endswith(States.escaped)</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.States.switch_escapement"><code class="name flex">
<span>def <span class="ident">switch_escapement</span></span>(<span>state: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the escaped or unescaped state of the given state, depending on whether it is currently escaped or
not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def switch_escapement(state: str) -&gt; str:
    &#34;&#34;&#34;Returns the escaped or unescaped state of the given state, depending on whether it is currently escaped or
    not.&#34;&#34;&#34;
    return States.escape(state) if not States.is_escaped(state) else States.unescape(state)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.StateTransitioner"><code class="flex name class">
<span>class <span class="ident">StateTransitioner</span></span>
</code></dt>
<dd>
<div class="desc"><p>Translates between states using a finite state machine.
This does not take into account the ability to escape characters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateTransitioner:
    &#34;&#34;&#34;Translates between states using a finite state machine.
    This does not take into account the ability to escape characters.&#34;&#34;&#34;

    state_transitions = {
        States.not_within_tags: {
            &#34;{&#34;: (States.in_empty_section,
                lambda r, c: r+[[(&#34;&#34;, [])]]),
            Chars.char: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c]),
            Chars.ws: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c])  # ToDo: Add this to graphic in spec.tex!
        },
        States.in_empty_section: {
            Chars.ws: (States.in_empty_section,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0]+c, r[-1][-1][1])]])
        },
        States.in_not_empty_section: {
            &#34;:&#34;: (States.in_empty_value_section,
                lambda r, c: r),
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]])], &#34;&#34;]),
            Chars.ws: (States.in_section_with_one_finished_word,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0]+c, r[-1][-1][1])]])
        },
        States.in_section_with_one_finished_word: {
            &#34;:&#34;: (States.in_empty_value_section,
                lambda r, c: r),
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])], &#34;&#34;]),
            Chars.ws: (States.in_section_with_one_finished_word,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]])]])
        },
        States.in_empty_value_section: {
            Chars.ws: (States.in_empty_value_section,  # ToDo: Add this to graphic in spec.tex!
                lambda r, c: r),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1][:-1]+[
                    ((r[-1][-1][1][-1]+c) if len(r[-1][-1][1]) &gt; 0 else c)
                ])]])
        },
        States.in_not_empty_value_section: {
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1]+[(&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r+[&#34;&#34;]),
            Chars.ws: (States.in_not_empty_value_section,
                lambda r, c: r[:-1] + [r[-1][:-1] + [(r[-1][-1][0], r[-1][-1][1]
                       + ([&#34;&#34;] if r[-1][-1][1][-1] != &#34;&#34; else []))]]),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1][:-1]+[(r[-1][-1][1][-1]+c)])]])
        }
    }

    @staticmethod
    def transition_state(state: str, char: str) -&gt; Tuple[str, Callable[[ParsedTemplate, str], ParsedTemplate]]:
        &#34;&#34;&#34;For a given state s and a given character c, returns the next state s2 and a function that takes a
        list representation of the already-parsed data and c and returns a modified, extended duplicate of the data
        based on c.&#34;&#34;&#34;
        type_of_char = Chars.type(char)
        if type_of_char in StateTransitioner.state_transitions[state]:
            return StateTransitioner.state_transitions[state][type_of_char]
        else:
            raise errors.SyntaxError(&#34;Parsing error: \&#34;&#34; + type_of_char + &#34;\&#34; may not occur if it is &#34; + state[3:])</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.parse_templates.StateTransitioner.state_transitions"><code class="name">var <span class="ident">state_transitions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.StateTransitioner.transition_state"><code class="name flex">
<span>def <span class="ident">transition_state</span></span>(<span>state: str, char: str) ‑> Tuple[str, Callable[[<a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]], str], <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>For a given state s and a given character c, returns the next state s2 and a function that takes a
list representation of the already-parsed data and c and returns a modified, extended duplicate of the data
based on c.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def transition_state(state: str, char: str) -&gt; Tuple[str, Callable[[ParsedTemplate, str], ParsedTemplate]]:
    &#34;&#34;&#34;For a given state s and a given character c, returns the next state s2 and a function that takes a
    list representation of the already-parsed data and c and returns a modified, extended duplicate of the data
    based on c.&#34;&#34;&#34;
    type_of_char = Chars.type(char)
    if type_of_char in StateTransitioner.state_transitions[state]:
        return StateTransitioner.state_transitions[state][type_of_char]
    else:
        raise errors.SyntaxError(&#34;Parsing error: \&#34;&#34; + type_of_char + &#34;\&#34; may not occur if it is &#34; + state[3:])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.SectionTypes"><code class="flex name class">
<span>class <span class="ident">SectionTypes</span></span>
</code></dt>
<dd>
<div class="desc"><p>Capsules a mapping of priorities to section types and methods to assign section types to un-typed sections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SectionTypes:
    &#34;&#34;&#34;Capsules a mapping of priorities to section types and methods to assign section types to un-typed sections.&#34;&#34;&#34;

    section_types_w_priorities = [
        (&#34;context&#34;, 1000., True),
        (&#34;id&#34;, 700., False)
    ]
    &#34;&#34;&#34;All supported section types as a list of tuples in the form of (name, priority, can_have_multiple_values)&#34;&#34;&#34;

    @staticmethod
    def section_type_accepts_multiple_values(section_type: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether a section type can have multiple whitespace-separated values.&#34;&#34;&#34;
        return SectionTypes.section_type_exists(section_type) and bool(
            [i for i in range(len(SectionTypes.section_types_w_priorities))
             if SectionTypes.section_types_w_priorities[i][0] == section_type
             and SectionTypes.section_types_w_priorities[i][2] is True]
        )

    @staticmethod
    def section_type_exists(section_type: str) -&gt; bool:
        &#34;&#34;&#34;Checks if a section type exists.&#34;&#34;&#34;
        return bool(
            [i for i in range(len(SectionTypes.section_types_w_priorities))
             if SectionTypes.section_types_w_priorities[i][0] == section_type]
        )

    @staticmethod
    def create_section_types_for_untyped_tag(section_types: List[str]) -&gt; List[str]:
        &#34;&#34;&#34;Receives a list of section types in a tag (in chronological order) and assigns section types to those
        section without a section type, in accordance with the priorities of section types and the specification.
        Returns the typed section type list.
        Raises errors if section matching can not be done, or if no context section could be found.&#34;&#34;&#34;
        result = list()

        # get all explicitly specified section types into a set:
        already_used = set()
        if len(section_types) &gt; len(SectionTypes.section_types_w_priorities):
            raise errors.SyntaxPostprocessingError(&#34;Tag contains more sections than there are section types.&#34;)
        for section_type in filter(lambda x: x != &#34;&#34;, section_types):
            if section_type in already_used:
                raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; used twice in a tag.&#34;)
            elif not SectionTypes.section_type_exists(section_type):
                raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; does not exist.&#34;)
            else:
                already_used.add(section_type)

        # create a section priority queue without these element:
        available_sections_types = [s for s in SectionTypes.section_types_w_priorities if s[0] not in already_used]
        available_sections_types.sort(key=lambda s: s[1])

        # iterate over all declared section types from the left to the right:
        for section_type in reversed(section_types):
            if section_type == &#34;&#34;:
                result.insert(0, available_sections_types.pop()[0])
            else:
                result.insert(0, section_type)

        # raise an error if there is no context value:
        if &#34;context&#34; not in result:
            raise errors.SyntaxPostprocessingError(&#34;Tag misses a \&#34;context\&#34;-section.&#34;)

        return result</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.parse_templates.SectionTypes.section_types_w_priorities"><code class="name">var <span class="ident">section_types_w_priorities</span></code></dt>
<dd>
<div class="desc"><p>All supported section types as a list of tuples in the form of (name, priority, can_have_multiple_values)</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.SectionTypes.section_type_accepts_multiple_values"><code class="name flex">
<span>def <span class="ident">section_type_accepts_multiple_values</span></span>(<span>section_type: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a section type can have multiple whitespace-separated values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def section_type_accepts_multiple_values(section_type: str) -&gt; bool:
    &#34;&#34;&#34;Checks whether a section type can have multiple whitespace-separated values.&#34;&#34;&#34;
    return SectionTypes.section_type_exists(section_type) and bool(
        [i for i in range(len(SectionTypes.section_types_w_priorities))
         if SectionTypes.section_types_w_priorities[i][0] == section_type
         and SectionTypes.section_types_w_priorities[i][2] is True]
    )</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.SectionTypes.section_type_exists"><code class="name flex">
<span>def <span class="ident">section_type_exists</span></span>(<span>section_type: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a section type exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def section_type_exists(section_type: str) -&gt; bool:
    &#34;&#34;&#34;Checks if a section type exists.&#34;&#34;&#34;
    return bool(
        [i for i in range(len(SectionTypes.section_types_w_priorities))
         if SectionTypes.section_types_w_priorities[i][0] == section_type]
    )</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.SectionTypes.create_section_types_for_untyped_tag"><code class="name flex">
<span>def <span class="ident">create_section_types_for_untyped_tag</span></span>(<span>section_types: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a list of section types in a tag (in chronological order) and assigns section types to those
section without a section type, in accordance with the priorities of section types and the specification.
Returns the typed section type list.
Raises errors if section matching can not be done, or if no context section could be found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_section_types_for_untyped_tag(section_types: List[str]) -&gt; List[str]:
    &#34;&#34;&#34;Receives a list of section types in a tag (in chronological order) and assigns section types to those
    section without a section type, in accordance with the priorities of section types and the specification.
    Returns the typed section type list.
    Raises errors if section matching can not be done, or if no context section could be found.&#34;&#34;&#34;
    result = list()

    # get all explicitly specified section types into a set:
    already_used = set()
    if len(section_types) &gt; len(SectionTypes.section_types_w_priorities):
        raise errors.SyntaxPostprocessingError(&#34;Tag contains more sections than there are section types.&#34;)
    for section_type in filter(lambda x: x != &#34;&#34;, section_types):
        if section_type in already_used:
            raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; used twice in a tag.&#34;)
        elif not SectionTypes.section_type_exists(section_type):
            raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; does not exist.&#34;)
        else:
            already_used.add(section_type)

    # create a section priority queue without these element:
    available_sections_types = [s for s in SectionTypes.section_types_w_priorities if s[0] not in already_used]
    available_sections_types.sort(key=lambda s: s[1])

    # iterate over all declared section types from the left to the right:
    for section_type in reversed(section_types):
        if section_type == &#34;&#34;:
            result.insert(0, available_sections_types.pop()[0])
        else:
            result.insert(0, section_type)

    # raise an error if there is no context value:
    if &#34;context&#34; not in result:
        raise errors.SyntaxPostprocessingError(&#34;Tag misses a \&#34;context\&#34;-section.&#34;)

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.GRParser"><code class="flex name class">
<span>class <span class="ident">GRParser</span></span>
</code></dt>
<dd>
<div class="desc"><p>Unites several static methods of a pipeline for parsing gender<em>render templates from strings into a list format
and refining this representation to the maximum extend possible without additionally seeing the corresponding
gender</em>render pronoun data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GRParser:
    &#34;&#34;&#34;Unites several static methods of a pipeline for parsing gender*render templates from strings into a list format
    and refining this representation to the maximum extend possible without additionally seeing the corresponding
    gender*render pronoun data.&#34;&#34;&#34;

    @staticmethod
    def parse_gr_template_from_str(template: str, debug_log=False) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a gender*render template as a string and returns it as an easily readable list representation.
        This does only syntactic parsing in accordance to the defining finite state machine;
        further steps in the parsing pipeline are implemented by other methods of this parser.

        The resulting output is of the following structure:
        * value of a section: represented by lists of strings
        * type of section: represented by a string
        * section: tuple of type representation and value representation
        * tag: list of section representation
        * template: list, where every uneven element represents a tag and every even element is a string

        Special characters are all unescaped in the parsed version of the template.&#34;&#34;&#34;

        result = [&#34;&#34;]
        s = States.not_within_tags
        line_no = 1
        char_no = 1
        # iterate over all characters:
        for i in range(len(template)):
            c = template[i]
            # increment char count for SyntaxError raising:
            if c == &#34;\n&#34;:
                line_no += 1
                char_no = 1
            else:
                char_no += 1

            # log:
            if debug_log:
                print(&#34;c:&#34;, c)
                print(&#34;s:&#34;, s)
                print(&#34;char type:&#34;, Chars.type(c))
                print(&#34;result:&#34;, result)

            # do the work of the finite state machine:
            type_of_char = Chars.type(c)
            if States.is_escaped(s):
                s = States.unescape(s)
                result = StateTransitioner.state_transitions[s][Chars.char][1](result, c)
            else:
                if type_of_char == Chars.escape_char:
                    s = States.escape(s)
                else:
                    try:
                        s, processing_function = StateTransitioner.transition_state(s, c)
                        result = processing_function(result, c)
                    except errors.SyntaxError:
                        raise errors.SyntaxError(
                            &#34;The given gender*render template has invalid syntax.&#34;,
                            (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[line_no - 1])
                        )

        # raise an error if the template ends unproperly:
        if States.is_escaped(s):
            raise errors.SyntaxError(&#34;The template ends with an unescaped escape character, please escape it.&#34;,
                                     (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))
        elif s != States.not_within_tags:
            raise errors.SyntaxError(&#34;A tag opens, but is not finished properly.&#34;,
                                     (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))

        return result

    @staticmethod
    def assign_types_to_all_sections(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and assigns every section of undefined
        type a section type.&#34;&#34;&#34;
        result = parsed_template.copy()
        for i in range(1, len(result), 2):
            old_section_types = [section[0] for section in result[i]]
            new_section_types = SectionTypes.create_section_types_for_untyped_tag(old_section_types)
            result[i] = [(new_section_types[s], result[i][s][1]) for s in range(len(result[i]))]
        return result

    @staticmethod
    def split_tags_with_multiple_context_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and splits every tag into a sequence of
        tags, one for every context value of the tag.
        This assumes that every section was already assigned a type by GRParser.assign_types_to_all_sections, and may
        lead to wrong results otherwise.&#34;&#34;&#34;
        result = parsed_template.copy()
        for i in reversed(range(1, len(result), 2)):
            tag_without_context_section = [section for section in result[i] if section[0] != &#34;context&#34;]
            tag_but_only_context_section = [section for section in result[i] if section[0] == &#34;context&#34;]

            # split tag into one tag for every context value:
            context_values = tag_but_only_context_section.pop()[1]
            sequence_of_tags = [
                (tag_without_context_section.copy() + [(&#34;context&#34;, [context_value])])
                for context_value in context_values
            ]
            for j in reversed(range(1, len(sequence_of_tags))):
                sequence_of_tags.insert(j, &#34;&#34;)
            result[i:i+1] = sequence_of_tags

        return result

    @staticmethod
    def convert_tags_to_indexable_dicts(parsed_template: ParsedTemplate) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and converts every tag from a
        representation a la &#34;[(a, b), (c, d)]&#34; to a representation a la &#34;{a: b, c: d}&#34;.
        This makes the value of specific types of sections easier to access by other methods.
        Note that the result returned by this method is different in that it is not accepted by the other methods of
        GRParser, and that this method should thus be the last method in this pipeline to be used.
        Raises an error if a section has multiple values yet accepts only one.&#34;&#34;&#34;
        result = parsed_template.copy()
        for i in range(len(parsed_template)):
            if i % 2:  # is a tag
                new_tag = dict()
                for section_type, section_values in parsed_template[i]:
                    if SectionTypes.section_type_accepts_multiple_values(section_type) and section_type != &#34;context&#34;:
                        new_tag[section_type] = section_values
                    else:
                        if len(section_values) &gt; 1:
                            raise errors.SyntaxPostprocessingError(&#34;Tag no. &#34; + str(i / 2) + &#34;(&#34;
                                                                   + ReGRParser.unparse_gr_tag(parsed_template[i])
                                                                   + &#34;) has multiple values in \&#34;&#34;
                                                                   + section_type +
                                                                   &#34;\&#34;-section even though this type of section does&#34;
                                                                   + &#34; not support this.&#34;)
                        else:
                            new_tag[section_type] = section_values[0]
                result[i] = new_tag

        return result

    @staticmethod
    def convert_context_values_to_canonicals(parsed_template: ParsedTemplateRefined) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Converts a parsed template as returned by GRParser.convert_tags_to_indexable_dicts to a parsed template
        where every context value is canonical.&#34;&#34;&#34;
        result = parsed_template.copy()
        for i in range(1, len(parsed_template), 2):
            result[i][&#34;context&#34;] = handle_context_values.ContextValues.get_canonical(result[i][&#34;context&#34;])
        return result

    @staticmethod
    def full_parsing_pipeline(template: str) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Walks template through the full parsing pipeline defined by GRParser, and returns the result.&#34;&#34;&#34;
        template = GRParser.parse_gr_template_from_str(template)
        template = GRParser.assign_types_to_all_sections(template)
        template = GRParser.split_tags_with_multiple_context_values(template)
        template = GRParser.convert_tags_to_indexable_dicts(template)
        template = GRParser.convert_context_values_to_canonicals(template)
        return template

    @staticmethod
    def get_all_specified_id_values(parsed_template: ParsedTemplateRefined) -&gt; FrozenSet[str]:
        &#34;&#34;&#34;Returns a frozen set of all id values explicitly specified by tags in the parsed template.&#34;&#34;&#34;
        return frozenset(
            parsed_template[i][&#34;id&#34;] for i in range(1, len(parsed_template), 2) if &#34;id&#34; in parsed_template[i]
        )

    @staticmethod
    def pronoun_data_contains_unspecified_ids(parsed_template: ParsedTemplateRefined) -&gt; bool:
        &#34;&#34;&#34;Returns whether the parsed template contains tags with unspecified id value.&#34;&#34;&#34;
        return bool(list(
            parsed_template[i] for i in range(1, len(parsed_template), 2) if &#34;id&#34; not in parsed_template[i]
        ))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.GRParser.parse_gr_template_from_str"><code class="name flex">
<span>def <span class="ident">parse_gr_template_from_str</span></span>(<span>template: str, debug_log=False) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a gender*render template as a string and returns it as an easily readable list representation.
This does only syntactic parsing in accordance to the defining finite state machine;
further steps in the parsing pipeline are implemented by other methods of this parser.</p>
<p>The resulting output is of the following structure:
* value of a section: represented by lists of strings
* type of section: represented by a string
* section: tuple of type representation and value representation
* tag: list of section representation
* template: list, where every uneven element represents a tag and every even element is a string</p>
<p>Special characters are all unescaped in the parsed version of the template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_gr_template_from_str(template: str, debug_log=False) -&gt; ParsedTemplate:
    &#34;&#34;&#34;Takes a gender*render template as a string and returns it as an easily readable list representation.
    This does only syntactic parsing in accordance to the defining finite state machine;
    further steps in the parsing pipeline are implemented by other methods of this parser.

    The resulting output is of the following structure:
    * value of a section: represented by lists of strings
    * type of section: represented by a string
    * section: tuple of type representation and value representation
    * tag: list of section representation
    * template: list, where every uneven element represents a tag and every even element is a string

    Special characters are all unescaped in the parsed version of the template.&#34;&#34;&#34;

    result = [&#34;&#34;]
    s = States.not_within_tags
    line_no = 1
    char_no = 1
    # iterate over all characters:
    for i in range(len(template)):
        c = template[i]
        # increment char count for SyntaxError raising:
        if c == &#34;\n&#34;:
            line_no += 1
            char_no = 1
        else:
            char_no += 1

        # log:
        if debug_log:
            print(&#34;c:&#34;, c)
            print(&#34;s:&#34;, s)
            print(&#34;char type:&#34;, Chars.type(c))
            print(&#34;result:&#34;, result)

        # do the work of the finite state machine:
        type_of_char = Chars.type(c)
        if States.is_escaped(s):
            s = States.unescape(s)
            result = StateTransitioner.state_transitions[s][Chars.char][1](result, c)
        else:
            if type_of_char == Chars.escape_char:
                s = States.escape(s)
            else:
                try:
                    s, processing_function = StateTransitioner.transition_state(s, c)
                    result = processing_function(result, c)
                except errors.SyntaxError:
                    raise errors.SyntaxError(
                        &#34;The given gender*render template has invalid syntax.&#34;,
                        (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[line_no - 1])
                    )

    # raise an error if the template ends unproperly:
    if States.is_escaped(s):
        raise errors.SyntaxError(&#34;The template ends with an unescaped escape character, please escape it.&#34;,
                                 (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))
    elif s != States.not_within_tags:
        raise errors.SyntaxError(&#34;A tag opens, but is not finished properly.&#34;,
                                 (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))

    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.assign_types_to_all_sections"><code class="name flex">
<span>def <span class="ident">assign_types_to_all_sections</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template (as it is created by all methods of GRParser) and assigns every section of undefined
type a section type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def assign_types_to_all_sections(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
    &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and assigns every section of undefined
    type a section type.&#34;&#34;&#34;
    result = parsed_template.copy()
    for i in range(1, len(result), 2):
        old_section_types = [section[0] for section in result[i]]
        new_section_types = SectionTypes.create_section_types_for_untyped_tag(old_section_types)
        result[i] = [(new_section_types[s], result[i][s][1]) for s in range(len(result[i]))]
    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.split_tags_with_multiple_context_values"><code class="name flex">
<span>def <span class="ident">split_tags_with_multiple_context_values</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template (as it is created by all methods of GRParser) and splits every tag into a sequence of
tags, one for every context value of the tag.
This assumes that every section was already assigned a type by GRParser.assign_types_to_all_sections, and may
lead to wrong results otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def split_tags_with_multiple_context_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
    &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and splits every tag into a sequence of
    tags, one for every context value of the tag.
    This assumes that every section was already assigned a type by GRParser.assign_types_to_all_sections, and may
    lead to wrong results otherwise.&#34;&#34;&#34;
    result = parsed_template.copy()
    for i in reversed(range(1, len(result), 2)):
        tag_without_context_section = [section for section in result[i] if section[0] != &#34;context&#34;]
        tag_but_only_context_section = [section for section in result[i] if section[0] == &#34;context&#34;]

        # split tag into one tag for every context value:
        context_values = tag_but_only_context_section.pop()[1]
        sequence_of_tags = [
            (tag_without_context_section.copy() + [(&#34;context&#34;, [context_value])])
            for context_value in context_values
        ]
        for j in reversed(range(1, len(sequence_of_tags))):
            sequence_of_tags.insert(j, &#34;&#34;)
        result[i:i+1] = sequence_of_tags

    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.convert_tags_to_indexable_dicts"><code class="name flex">
<span>def <span class="ident">convert_tags_to_indexable_dicts</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template (as it is created by all methods of GRParser) and converts every tag from a
representation a la "[(a, b), (c, d)]" to a representation a la "{a: b, c: d}".
This makes the value of specific types of sections easier to access by other methods.
Note that the result returned by this method is different in that it is not accepted by the other methods of
GRParser, and that this method should thus be the last method in this pipeline to be used.
Raises an error if a section has multiple values yet accepts only one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_tags_to_indexable_dicts(parsed_template: ParsedTemplate) -&gt; ParsedTemplateRefined:
    &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and converts every tag from a
    representation a la &#34;[(a, b), (c, d)]&#34; to a representation a la &#34;{a: b, c: d}&#34;.
    This makes the value of specific types of sections easier to access by other methods.
    Note that the result returned by this method is different in that it is not accepted by the other methods of
    GRParser, and that this method should thus be the last method in this pipeline to be used.
    Raises an error if a section has multiple values yet accepts only one.&#34;&#34;&#34;
    result = parsed_template.copy()
    for i in range(len(parsed_template)):
        if i % 2:  # is a tag
            new_tag = dict()
            for section_type, section_values in parsed_template[i]:
                if SectionTypes.section_type_accepts_multiple_values(section_type) and section_type != &#34;context&#34;:
                    new_tag[section_type] = section_values
                else:
                    if len(section_values) &gt; 1:
                        raise errors.SyntaxPostprocessingError(&#34;Tag no. &#34; + str(i / 2) + &#34;(&#34;
                                                               + ReGRParser.unparse_gr_tag(parsed_template[i])
                                                               + &#34;) has multiple values in \&#34;&#34;
                                                               + section_type +
                                                               &#34;\&#34;-section even though this type of section does&#34;
                                                               + &#34; not support this.&#34;)
                    else:
                        new_tag[section_type] = section_values[0]
            result[i] = new_tag

    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.convert_context_values_to_canonicals"><code class="name flex">
<span>def <span class="ident">convert_context_values_to_canonicals</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a parsed template as returned by GRParser.convert_tags_to_indexable_dicts to a parsed template
where every context value is canonical.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_context_values_to_canonicals(parsed_template: ParsedTemplateRefined) -&gt; ParsedTemplateRefined:
    &#34;&#34;&#34;Converts a parsed template as returned by GRParser.convert_tags_to_indexable_dicts to a parsed template
    where every context value is canonical.&#34;&#34;&#34;
    result = parsed_template.copy()
    for i in range(1, len(parsed_template), 2):
        result[i][&#34;context&#34;] = handle_context_values.ContextValues.get_canonical(result[i][&#34;context&#34;])
    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.full_parsing_pipeline"><code class="name flex">
<span>def <span class="ident">full_parsing_pipeline</span></span>(<span>template: str) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Walks template through the full parsing pipeline defined by GRParser, and returns the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def full_parsing_pipeline(template: str) -&gt; ParsedTemplateRefined:
    &#34;&#34;&#34;Walks template through the full parsing pipeline defined by GRParser, and returns the result.&#34;&#34;&#34;
    template = GRParser.parse_gr_template_from_str(template)
    template = GRParser.assign_types_to_all_sections(template)
    template = GRParser.split_tags_with_multiple_context_values(template)
    template = GRParser.convert_tags_to_indexable_dicts(template)
    template = GRParser.convert_context_values_to_canonicals(template)
    return template</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.get_all_specified_id_values"><code class="name flex">
<span>def <span class="ident">get_all_specified_id_values</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]) ‑> FrozenSet[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a frozen set of all id values explicitly specified by tags in the parsed template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_all_specified_id_values(parsed_template: ParsedTemplateRefined) -&gt; FrozenSet[str]:
    &#34;&#34;&#34;Returns a frozen set of all id values explicitly specified by tags in the parsed template.&#34;&#34;&#34;
    return frozenset(
        parsed_template[i][&#34;id&#34;] for i in range(1, len(parsed_template), 2) if &#34;id&#34; in parsed_template[i]
    )</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.pronoun_data_contains_unspecified_ids"><code class="name flex">
<span>def <span class="ident">pronoun_data_contains_unspecified_ids</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns whether the parsed template contains tags with unspecified id value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pronoun_data_contains_unspecified_ids(parsed_template: ParsedTemplateRefined) -&gt; bool:
    &#34;&#34;&#34;Returns whether the parsed template contains tags with unspecified id value.&#34;&#34;&#34;
    return bool(list(
        parsed_template[i] for i in range(1, len(parsed_template), 2) if &#34;id&#34; not in parsed_template[i]
    ))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.ReGRParser"><code class="flex name class">
<span>class <span class="ident">ReGRParser</span></span>
</code></dt>
<dd>
<div class="desc"><p>Bundles methods to get a valid gender*render template from</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReGRParser:
    &#34;&#34;&#34;Bundles methods to get a valid gender*render template from &#34;&#34;&#34;

    @staticmethod
    def unparse_gr_tag(tag_representation: list) -&gt; str:
        return &#34;{&#34; + &#34;*&#34;.join([(
                            ((Chars.escape_gr_string(section[0]) + &#34;:&#34;) if section[0] else &#34;&#34;)
                            + &#34; &#34;.join([Chars.escape_gr_string(value) for value in section[1]])
                        ) for section in tag_representation]) + &#34;}&#34;

    @staticmethod
    def unparse_gr_template_from_parsed_gr_template(parsed_template: list) -&gt; str:
        &#34;&#34;&#34;Takes the result of any method of the GRParser class and returns a template (as a string) that corresponds to
        the given parsed template.
        This may be used for testing purposes or to simplify gender*render templates.&#34;&#34;&#34;
        result = str()
        for i in range(len(parsed_template)):
            if i % 2:  # is a tag
                result += ReGRParser.unparse_gr_tag(parsed_template[i])
            else:  # is a string
                result += Chars.escape_gr_string(parsed_template[i])
        return result</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.ReGRParser.unparse_gr_tag"><code class="name flex">
<span>def <span class="ident">unparse_gr_tag</span></span>(<span>tag_representation: list) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unparse_gr_tag(tag_representation: list) -&gt; str:
    return &#34;{&#34; + &#34;*&#34;.join([(
                        ((Chars.escape_gr_string(section[0]) + &#34;:&#34;) if section[0] else &#34;&#34;)
                        + &#34; &#34;.join([Chars.escape_gr_string(value) for value in section[1]])
                    ) for section in tag_representation]) + &#34;}&#34;</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.ReGRParser.unparse_gr_template_from_parsed_gr_template"><code class="name flex">
<span>def <span class="ident">unparse_gr_template_from_parsed_gr_template</span></span>(<span>parsed_template: list) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the result of any method of the GRParser class and returns a template (as a string) that corresponds to
the given parsed template.
This may be used for testing purposes or to simplify gender*render templates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unparse_gr_template_from_parsed_gr_template(parsed_template: list) -&gt; str:
    &#34;&#34;&#34;Takes the result of any method of the GRParser class and returns a template (as a string) that corresponds to
    the given parsed template.
    This may be used for testing purposes or to simplify gender*render templates.&#34;&#34;&#34;
    result = str()
    for i in range(len(parsed_template)):
        if i % 2:  # is a tag
            result += ReGRParser.unparse_gr_tag(parsed_template[i])
        else:  # is a string
            result += Chars.escape_gr_string(parsed_template[i])
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gender_render" href="index.html">gender_render</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a></code></h4>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a></code></h4>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.Chars" href="#gender_render.parse_templates.Chars">Chars</a></code></h4>
<ul class="two-column">
<li><code><a title="gender_render.parse_templates.Chars.type" href="#gender_render.parse_templates.Chars.type">type</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.escape_gr_string" href="#gender_render.parse_templates.Chars.escape_gr_string">escape_gr_string</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.escape_char" href="#gender_render.parse_templates.Chars.escape_char">escape_char</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.whitespace_chars" href="#gender_render.parse_templates.Chars.whitespace_chars">whitespace_chars</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.special_chars" href="#gender_render.parse_templates.Chars.special_chars">special_chars</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.ws" href="#gender_render.parse_templates.Chars.ws">ws</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.char" href="#gender_render.parse_templates.Chars.char">char</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.States" href="#gender_render.parse_templates.States">States</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.States.escape" href="#gender_render.parse_templates.States.escape">escape</a></code></li>
<li><code><a title="gender_render.parse_templates.States.unescape" href="#gender_render.parse_templates.States.unescape">unescape</a></code></li>
<li><code><a title="gender_render.parse_templates.States.is_escaped" href="#gender_render.parse_templates.States.is_escaped">is_escaped</a></code></li>
<li><code><a title="gender_render.parse_templates.States.switch_escapement" href="#gender_render.parse_templates.States.switch_escapement">switch_escapement</a></code></li>
<li><code><a title="gender_render.parse_templates.States.not_within_tags" href="#gender_render.parse_templates.States.not_within_tags">not_within_tags</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_empty_section" href="#gender_render.parse_templates.States.in_empty_section">in_empty_section</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_not_empty_section" href="#gender_render.parse_templates.States.in_not_empty_section">in_not_empty_section</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_section_with_one_finished_word" href="#gender_render.parse_templates.States.in_section_with_one_finished_word">in_section_with_one_finished_word</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_empty_value_section" href="#gender_render.parse_templates.States.in_empty_value_section">in_empty_value_section</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_not_empty_value_section" href="#gender_render.parse_templates.States.in_not_empty_value_section">in_not_empty_value_section</a></code></li>
<li><code><a title="gender_render.parse_templates.States.escaped" href="#gender_render.parse_templates.States.escaped">escaped</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.StateTransitioner" href="#gender_render.parse_templates.StateTransitioner">StateTransitioner</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.StateTransitioner.transition_state" href="#gender_render.parse_templates.StateTransitioner.transition_state">transition_state</a></code></li>
<li><code><a title="gender_render.parse_templates.StateTransitioner.state_transitions" href="#gender_render.parse_templates.StateTransitioner.state_transitions">state_transitions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.SectionTypes" href="#gender_render.parse_templates.SectionTypes">SectionTypes</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.SectionTypes.section_type_accepts_multiple_values" href="#gender_render.parse_templates.SectionTypes.section_type_accepts_multiple_values">section_type_accepts_multiple_values</a></code></li>
<li><code><a title="gender_render.parse_templates.SectionTypes.section_type_exists" href="#gender_render.parse_templates.SectionTypes.section_type_exists">section_type_exists</a></code></li>
<li><code><a title="gender_render.parse_templates.SectionTypes.create_section_types_for_untyped_tag" href="#gender_render.parse_templates.SectionTypes.create_section_types_for_untyped_tag">create_section_types_for_untyped_tag</a></code></li>
<li><code><a title="gender_render.parse_templates.SectionTypes.section_types_w_priorities" href="#gender_render.parse_templates.SectionTypes.section_types_w_priorities">section_types_w_priorities</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.GRParser" href="#gender_render.parse_templates.GRParser">GRParser</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.GRParser.parse_gr_template_from_str" href="#gender_render.parse_templates.GRParser.parse_gr_template_from_str">parse_gr_template_from_str</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.assign_types_to_all_sections" href="#gender_render.parse_templates.GRParser.assign_types_to_all_sections">assign_types_to_all_sections</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.split_tags_with_multiple_context_values" href="#gender_render.parse_templates.GRParser.split_tags_with_multiple_context_values">split_tags_with_multiple_context_values</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.convert_tags_to_indexable_dicts" href="#gender_render.parse_templates.GRParser.convert_tags_to_indexable_dicts">convert_tags_to_indexable_dicts</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.convert_context_values_to_canonicals" href="#gender_render.parse_templates.GRParser.convert_context_values_to_canonicals">convert_context_values_to_canonicals</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.full_parsing_pipeline" href="#gender_render.parse_templates.GRParser.full_parsing_pipeline">full_parsing_pipeline</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.get_all_specified_id_values" href="#gender_render.parse_templates.GRParser.get_all_specified_id_values">get_all_specified_id_values</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.pronoun_data_contains_unspecified_ids" href="#gender_render.parse_templates.GRParser.pronoun_data_contains_unspecified_ids">pronoun_data_contains_unspecified_ids</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.ReGRParser" href="#gender_render.parse_templates.ReGRParser">ReGRParser</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.ReGRParser.unparse_gr_tag" href="#gender_render.parse_templates.ReGRParser.unparse_gr_tag">unparse_gr_tag</a></code></li>
<li><code><a title="gender_render.parse_templates.ReGRParser.unparse_gr_template_from_parsed_gr_template" href="#gender_render.parse_templates.ReGRParser.unparse_gr_template_from_parsed_gr_template">unparse_gr_template_from_parsed_gr_template</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
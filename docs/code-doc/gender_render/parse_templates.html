<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gender_render.parse_templates API documentation</title>
<meta name="description" content="Parser functions for gender*render templates." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/gender_render/parse_templates.html">
<link rel="icon" href="https://pdoc3.github.io/pdoc/logo.png">
</head>
<body>
<!-- The following github corner is taken from Tim Holman (copyright notice: Copyright (c) 2016 Tim Holman),
and licensed under MIT according to https://github.com/tholman/github-corners/blob/master/license.md -->
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<a href="https://github.com/phseiff/gender-render" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gender_render.parse_templates</code></h1>
</header>
<section id="section-intro">
<p>Parser functions for gender*render templates.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L0-L468" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Parser functions for gender*render templates.
&#34;&#34;&#34;

import copy
from typing import Tuple, Callable, List, Dict, Union, FrozenSet

from . import errors
from . import handle_context_values
from . import gender_nouns
from . import warnings

# Some helpful type hints:


ParsedTemplate = List[Union[str, List[Tuple[str, List[str]]]]]
&#34;&#34;&#34;A type hint describing a parsed template as it is returned by most of the methods of GRParser.
Note that not any structure build according to this constructor is valid, since some aspects cannot be described
by Python type hints.&#34;&#34;&#34;

ParsedTemplateRefined = List[Union[str, Dict[str, Union[str, List[str], gender_nouns.GenderedNoun]]]]
&#34;&#34;&#34;A type similar to GRParser.ParsedTemplate that makes the sections of tags easier accessible by making them
dicts instead of lists of tuples.&#34;&#34;&#34;

# definitions of words and word groups accepted by the finite state machine:


class Chars:
    &#34;&#34;&#34;Helper to categorize characters.&#34;&#34;&#34;
    escape_char = &#34;\\&#34;
    whitespace_chars = &#34;\t\n \u200B&#34;
    special_chars = &#34;:*{}\\&#34;
    ws = &#34;whitespace&#34;
    char = &#34;non-special chars&#34;

    @staticmethod
    def type(c: str) -&gt; str:
        &#34;&#34;&#34;Returns the type of character c, which determines how states in the finite state machine that describes
        gender*render syntax transition to each other.
        This is either Chars.ws (whitespace), a special character or Chars.char (anything else).&#34;&#34;&#34;
        if c in Chars.special_chars:
            return c
        elif c in Chars.whitespace_chars:
            return Chars.ws
        else:
            return Chars.char

    @staticmethod
    def escape_gr_string(s: str, strict: bool = True) -&gt; str:
        &#34;&#34;&#34;Escapes all special gender*render characters in a string, such as {, }, \\, : and *, as well as whitespace,
        with backslashs.
        if `strict` is set to False, only {, } and \\ are escaped; this may be used for strings that are supposed to go
        into gender*render templates, yet not into the inners of the tags themselves.&#34;&#34;&#34;
        i = len(s) - 1
        while i &gt; -1:
            if s[i] in ((Chars.special_chars + Chars.whitespace_chars) if strict else {&#34;\\&#34;, &#34;{&#34;, &#34;}&#34;}):
                s = s[:i] + &#34;\\&#34; + s[i:]
            i -= 1
        return s

# definitions of states of the finite state machine:


class States:
    &#34;&#34;&#34;Combines values for all sections the finite state machine that describes the syntax can be in, as well as
    methods to handle the special escaped/unescaped versions of all states.&#34;&#34;&#34;

    # Currently, the read character is...
    not_within_tags = &#34;...not part of any tag&#34;

    in_empty_section = &#34;...in a yet empty section&#34;
    in_not_empty_section = &#34;...in a not anymore empty section&#34;
    in_section_with_one_finished_word = &#34;...in a section which already contains a finished word&#34;

    in_empty_value_section = &#34;...in a yet empty value section&#34;
    in_not_empty_value_section = &#34;...in a not empty value section&#34;

    escaped = &#34;...and escaped&#34;

    @staticmethod
    def escape(state: str) -&gt; str:
        &#34;&#34;&#34;Converts an unescaped state to its escaped equivalent.&#34;&#34;&#34;
        assert not States.is_escaped(state)
        return state + States.escaped

    @staticmethod
    def unescape(state: str) -&gt; str:
        &#34;&#34;&#34;Convert an escaped state to its unescaped equivalent.&#34;&#34;&#34;
        assert States.is_escaped(state)
        return state[:len(state)-len(States.escaped)]

    @staticmethod
    def is_escaped(state: str) -&gt; bool:
        &#34;&#34;&#34;Checks is the current char is an escaped char.&#34;&#34;&#34;
        return state.endswith(States.escaped)

    @staticmethod
    def switch_escapement(state: str) -&gt; str:
        &#34;&#34;&#34;Returns the escaped or unescaped state of the given state, depending on whether it is currently escaped or
        not.&#34;&#34;&#34;
        return States.escape(state) if not States.is_escaped(state) else States.unescape(state)

# the finite state machine, but without the escaped versions of all states since these are handled separately:


class StateTransitioner:
    &#34;&#34;&#34;Translates between states using a finite state machine.
    This does not take into account the ability to escape characters.&#34;&#34;&#34;

    state_transitions: Dict[str, Dict[str, Tuple[str, Callable[[ParsedTemplate, str], ParsedTemplate]]]] = {
        States.not_within_tags: {
            &#34;{&#34;: (States.in_empty_section,
                lambda r, c: r+[[(&#34;&#34;, [])]]),
            Chars.char: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c]),
            Chars.ws: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c]),
            &#34;:&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c]),
            &#34;*&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c])
        },
        States.in_empty_section: {
            Chars.ws: (States.in_empty_section,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0]+c, r[-1][-1][1])]])
        },
        States.in_not_empty_section: {
            &#34;:&#34;: (States.in_empty_value_section,
                lambda r, c: r),
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]])], &#34;&#34;]),
            Chars.ws: (States.in_section_with_one_finished_word,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0]+c, r[-1][-1][1])]])
        },
        States.in_section_with_one_finished_word: {
            &#34;:&#34;: (States.in_empty_value_section,
                lambda r, c: r),
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]])], &#34;&#34;]),
            Chars.ws: (States.in_section_with_one_finished_word,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0], c])]])
        },
        States.in_empty_value_section: {
            Chars.ws: (States.in_empty_value_section,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1][:-1]+[
                    ((r[-1][-1][1][-1]+c) if len(r[-1][-1][1]) &gt; 0 else c)
                ])]])
        },
        States.in_not_empty_value_section: {
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], (r[-1][-1][1]
                       if r[-1][-1][1][-1] != &#34;&#34; else r[-1][-1][1][:-1])), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1]
                       if r[-1][-1][1][-1] != &#34;&#34; else r[-1][-1][1][:-1])]]+[&#34;&#34;]),
            Chars.ws: (States.in_not_empty_value_section,
                lambda r, c: r[:-1] + [r[-1][:-1] + [(r[-1][-1][0], r[-1][-1][1]
                       + ([&#34;&#34;] if r[-1][-1][1][-1] != &#34;&#34; else []))]]),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1][:-1]+[(r[-1][-1][1][-1]+c)])]])
        }
    }

    @staticmethod
    def transition_state(state: str, char: str) -&gt; Tuple[str, Callable[[ParsedTemplate, str], ParsedTemplate]]:
        &#34;&#34;&#34;For a given state s and a given character c, returns the next state s2 and a function that takes a
        list representation of the already-parsed data and c and returns a modified, extended duplicate of the data
        based on c.&#34;&#34;&#34;
        type_of_char = Chars.type(char)
        if type_of_char in StateTransitioner.state_transitions[state]:
            return StateTransitioner.state_transitions[state][type_of_char]
        else:
            raise errors.SyntaxError(&#34;Parsing error: \&#34;&#34; + type_of_char + &#34;\&#34; may not occur if it is &#34; + state[3:])

# define different section types:


class SectionTypes:
    &#34;&#34;&#34;Capsules a mapping of priorities to section types and methods to assign section types to un-typed sections.&#34;&#34;&#34;

    section_types_w_priorities = [
        (&#34;context&#34;, 1000., True),
        (&#34;id&#34;, 950., False)
    ]
    &#34;&#34;&#34;All supported section types as a list of tuples in the form of (name, priority, can_have_multiple_values)&#34;&#34;&#34;

    @staticmethod
    def section_type_accepts_multiple_values(section_type: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether a section type can have multiple whitespace-separated values.&#34;&#34;&#34;
        return SectionTypes.section_type_exists(section_type) and bool(
            [i for i in range(len(SectionTypes.section_types_w_priorities))
             if SectionTypes.section_types_w_priorities[i][0] == section_type
             and SectionTypes.section_types_w_priorities[i][2] is True]
        )

    @staticmethod
    def section_type_exists(section_type: str) -&gt; bool:
        &#34;&#34;&#34;Checks if a section type exists.&#34;&#34;&#34;
        return bool(
            [i for i in range(len(SectionTypes.section_types_w_priorities))
             if SectionTypes.section_types_w_priorities[i][0] == section_type]
        )

    @staticmethod
    def create_section_types_for_untyped_tag(section_types: List[str]) -&gt; List[str]:
        &#34;&#34;&#34;Receives a list of section types in a tag (in chronological order) and assigns section types to those
        section without a section type, in accordance with the priorities of section types and the specification.
        Returns the typed section type list.
        Raises errors if section matching can not be done, or if no context section could be found.&#34;&#34;&#34;
        result = list()

        # get all explicitly specified section types into a set:
        already_used = set()
        if len(section_types) &gt; len(SectionTypes.section_types_w_priorities):
            raise errors.SyntaxPostprocessingError(&#34;Tag contains more sections than there are section types.&#34;)
        for section_type in filter(lambda x: x != &#34;&#34;, section_types):
            if section_type in already_used:
                raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; used twice in a tag.&#34;)
            elif not SectionTypes.section_type_exists(section_type):
                raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; does not exist.&#34;)
            else:
                already_used.add(section_type)

        # create a section priority queue without these element:
        available_sections_types = [s for s in SectionTypes.section_types_w_priorities if s[0] not in already_used]
        available_sections_types.sort(key=lambda s: s[1])

        # iterate over all declared section types from the left to the right:
        for section_type in reversed(section_types):
            if section_type == &#34;&#34;:
                result.insert(0, available_sections_types.pop()[0])
            else:
                result.insert(0, section_type)

        # raise an error if there is no context value:
        if &#34;context&#34; not in result:
            raise errors.SyntaxPostprocessingError(&#34;Tag misses a \&#34;context\&#34;-section.&#34;)

        return result


# translate the content of gender*render templates into basic parsed lists:


class GRParser:
    &#34;&#34;&#34;Unites several static methods of a pipeline for parsing gender*render templates from strings into a list format
    and refining this representation to the maximum extend possible without additionally seeing the corresponding
    gender*render pronoun data.

    These functions are written to be executed in the order they are called by `full_parsing_pipeline`, and may or may
    not behave as expected when called on a value that didn&#39;t go through the other functions first.&#34;&#34;&#34;

    @staticmethod
    def parse_gr_template_from_str(template: str) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a gender*render template as a string and returns it as an easily readable list representation.
        This does only do syntactic parsing in accordance to the defining finite state machine;
        further steps in the parsing pipeline are implemented by other methods of this parser.

        The resulting output is of the following structure:
        * value of a section: represented by lists of strings
        * type of section: represented by a string
        * section: tuple of type representation and value representation
        * tag: list of section representation
        * template: list, where every uneven element represents a tag and every even element is a string

        Special characters are all unescaped in the parsed version of the template.&#34;&#34;&#34;

        result = [&#34;&#34;]
        s = States.not_within_tags
        line_no = 1
        char_no = 1
        # iterate over all characters:
        for i in range(len(template)):
            c = template[i]
            # increment char count for SyntaxError raising:
            if c == &#34;\n&#34;:
                line_no += 1
                char_no = 1
            else:
                char_no += 1

            # log:
            warnings.WarningManager.raise_warning(
                &#34;result: &#34; + str(result) + &#34;\n\n&#34;
                + &#34;c: \&#34;&#34; + c + &#34;\&#34;\n&#34;
                + &#34;s: &#34; + s + &#34;\n&#34;
                + &#34;char type: &#34; + Chars.type(c),
                warnings.GRSyntaxParsingLogging)

            # do the work of the finite state machine:
            type_of_char = Chars.type(c)
            if States.is_escaped(s):
                s = States.unescape(s)
                s, processing_function = StateTransitioner.state_transitions[s][Chars.char]
                result = processing_function(result, c)
            else:
                if type_of_char == Chars.escape_char:
                    s = States.escape(s)
                else:
                    try:
                        s, processing_function = StateTransitioner.transition_state(s, c)
                        result = processing_function(result, c)
                    except errors.SyntaxError:
                        raise errors.SyntaxError(
                            &#34;The given gender*render template has invalid syntax.&#34;,
                            (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[line_no - 1])
                        )

        # raise an error if the template ends unproperly:
        if States.is_escaped(s):
            raise errors.SyntaxError(&#34;The template ends with an unescaped escape character, please escape it.&#34;,
                                     (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))
        elif s != States.not_within_tags:
            raise errors.SyntaxError(&#34;A tag opens, but is not finished properly.&#34;,
                                     (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))

        return result

    @staticmethod
    def assign_types_to_all_sections(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and assigns every section of undefined
        type a section type.&#34;&#34;&#34;
        result = copy.deepcopy(parsed_template)
        for i in range(1, len(result), 2):
            old_section_types: List[str] = [section[0] for section in result[i]]
            new_section_types: List[str] = SectionTypes.create_section_types_for_untyped_tag(old_section_types)
            result[i] = [(new_section_types[s], result[i][s][1]) for s in range(len(new_section_types))]
        return result

    @staticmethod
    def split_tags_with_multiple_context_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and splits every tag into a sequence of
        tags, one for every context value of the tag.
        This assumes that every section was already assigned a type by GRParser.assign_types_to_all_sections, and may
        lead to wrong results otherwise.
        The context section is left the end of the tag by this procedure.&#34;&#34;&#34;
        result = copy.deepcopy(parsed_template)
        for i in reversed(range(1, len(result), 2)):
            tag_without_context_section = [section for section in result[i] if section[0] != &#34;context&#34;]
            tag_but_only_context_section = [section for section in result[i] if section[0] == &#34;context&#34;]

            # split tag into one tag for every context value:
            context_values = tag_but_only_context_section.pop()[1]
            sequence_of_tags = [
                (copy.deepcopy(tag_without_context_section) + [(&#34;context&#34;, [context_value])])
                for context_value in context_values
            ]
            for j in reversed(range(1, len(sequence_of_tags))):
                sequence_of_tags.insert(j, &#34; &#34;)
            result[i:i+1] = sequence_of_tags

        return result

    @staticmethod
    def make_sure_that_sections_dont_exceed_allowed_amount_of_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and raises an error if any tag that
        does not allow multiple values has multiple values. This should always be used before calling
        convert_tags_to_indxable_dicts.
        Returns the given dict afterwards.&#34;&#34;&#34;
        for i in range(len(parsed_template)):
            if i % 2:  # is a tag
                for section_type, section_values in parsed_template[i]:
                    if SectionTypes.section_type_accepts_multiple_values(section_type):
                        continue
                    elif len(section_values) &gt; 1:
                        raise errors.SyntaxPostprocessingError(&#34;Tag no. &#34; + str((i + 1) / 2) + &#34; (\&#34;&#34;
                                                               + ReGRParser.unparse_gr_tag(parsed_template[i])
                                                               + &#34;\&#34;) has multiple values in \&#34;&#34;
                                                               + section_type +
                                                               &#34;\&#34;-section even though this type of section does&#34;
                                                               + &#34; not support this.&#34;)
        return parsed_template

    @staticmethod
    def convert_tags_to_indexable_dicts(parsed_template: ParsedTemplate) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and converts every tag from a
        representation a la &#34;[(a, b), (c, d)]&#34; to a representation a la &#34;{a: b, c: d}&#34;.
        This makes the value of specific types of sections easier to access by other methods.
        Note that the result returned by this method is different in that it is not accepted by the other methods of
        GRParser, and that this method should thus be the last method in this pipeline to be used.
        Raises an error if a section has multiple values yet accepts only one.&#34;&#34;&#34;
        result = copy.deepcopy(parsed_template)
        for i in range(len(result)):
            if i % 2:  # is a tag
                new_tag = dict()
                for section_type, section_values in result[i]:
                    if not SectionTypes.section_type_accepts_multiple_values(section_type) or section_type == &#34;context&#34;:
                        new_tag[section_type] = section_values[0]
                    else:
                        new_tag[section_type] = section_values
                result[i] = new_tag

        return result

    @staticmethod
    def convert_context_values_to_canonicals(parsed_template: ParsedTemplateRefined) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Converts a parsed template as returned by GRParser.convert_tags_to_indexable_dicts to a parsed template
        where every context value is canonical.&#34;&#34;&#34;
        result = copy.deepcopy(parsed_template)
        for i in range(1, len(parsed_template), 2):
            result[i][&#34;context&#34;] = handle_context_values.ContextValues.get_canonical(result[i][&#34;context&#34;])
        return result

    @staticmethod
    def full_parsing_pipeline(template: str) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Walks template through the full parsing pipeline defined by GRParser, and returns the result.&#34;&#34;&#34;
        template = GRParser.parse_gr_template_from_str(template)
        template = GRParser.assign_types_to_all_sections(template)
        template = GRParser.split_tags_with_multiple_context_values(template)
        template = GRParser.make_sure_that_sections_dont_exceed_allowed_amount_of_values(template)
        template = GRParser.convert_tags_to_indexable_dicts(template)
        template = GRParser.convert_context_values_to_canonicals(template)
        return template

    @staticmethod
    def get_all_specified_id_values(parsed_template: ParsedTemplateRefined) -&gt; FrozenSet[str]:
        &#34;&#34;&#34;Returns a frozen set of all id values explicitly specified by tags in the parsed template.&#34;&#34;&#34;
        return frozenset(
            parsed_template[i][&#34;id&#34;] for i in range(1, len(parsed_template), 2) if &#34;id&#34; in parsed_template[i]
        )

    @staticmethod
    def template_contains_unspecified_ids(parsed_template: ParsedTemplateRefined) -&gt; bool:
        &#34;&#34;&#34;Returns whether the parsed template contains tags with unspecified id value.&#34;&#34;&#34;
        return bool(list(
            parsed_template[i] for i in range(1, len(parsed_template), 2) if &#34;id&#34; not in parsed_template[i]
        ))

# functions to reverse parsed templates for testing and simplification purposes:


class ReGRParser:
    &#34;&#34;&#34;Bundles methods to get a valid gender*render template from ParsedTemplate.&#34;&#34;&#34;

    @staticmethod
    def unparse_gr_tag(tag_representation: List[Tuple[str, List[str]]]) -&gt; str:
        return &#34;{&#34; + &#34;*&#34;.join([(
                            ((Chars.escape_gr_string(section[0]) + &#34;:&#34;) if section[0] else &#34;&#34;)
                            + &#34; &#34;.join([Chars.escape_gr_string(value) for value in section[1]])
                        ) for section in tag_representation]) + &#34;}&#34;

    @staticmethod
    def unparse_gr_template(parsed_template: ParsedTemplate) -&gt; str:
        &#34;&#34;&#34;Takes the result of any method of the GRParser class and returns a template (as a string) that corresponds to
        the given parsed template.
        This may be used for testing purposes or to simplify gender*render templates.&#34;&#34;&#34;
        result = str()
        for i in range(len(parsed_template)):
            if i % 2:  # is a tag
                result += ReGRParser.unparse_gr_tag(parsed_template[i])
            else:  # is a string
                result += Chars.escape_gr_string(parsed_template[i], strict=False)
        return result

    # ToDo: This set of methods is currently abandoned; if you want to implement some functions to also convert
    #  ParsedTemplateRefined to strings, feel free to make a pull request/ issue and maybe we can add an interface for
    #  it!</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gender_render.parse_templates.List"><code class="flex name class">
<span>class <span class="ident">ParsedTemplate</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>list() -&gt; new empty list
list(iterable) -&gt; new list initialized from iterable's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class List(list, MutableSequence[T], extra=list):

    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if cls._gorg is List:
            raise TypeError(&#34;Type List cannot be instantiated; &#34;
                            &#34;use list() instead&#34;)
        return _generic_new(list, cls, *args, **kwds)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.List</li>
<li>builtins.list</li>
<li>typing.MutableSequence</li>
<li>collections.abc.MutableSequence</li>
<li>typing.Sequence</li>
<li>collections.abc.Sequence</li>
<li>typing.Reversible</li>
<li>collections.abc.Reversible</li>
<li>typing.Collection</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>typing.Iterable</li>
<li>collections.abc.Iterable</li>
<li>typing.Container</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="gender_render.parse_templates.List"><code class="flex name class">
<span>class <span class="ident">ParsedTemplateRefined</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>list() -&gt; new empty list
list(iterable) -&gt; new list initialized from iterable's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class List(list, MutableSequence[T], extra=list):

    __slots__ = ()

    def __new__(cls, *args, **kwds):
        if cls._gorg is List:
            raise TypeError(&#34;Type List cannot be instantiated; &#34;
                            &#34;use list() instead&#34;)
        return _generic_new(list, cls, *args, **kwds)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.List</li>
<li>builtins.list</li>
<li>typing.MutableSequence</li>
<li>collections.abc.MutableSequence</li>
<li>typing.Sequence</li>
<li>collections.abc.Sequence</li>
<li>typing.Reversible</li>
<li>collections.abc.Reversible</li>
<li>typing.Collection</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>typing.Iterable</li>
<li>collections.abc.Iterable</li>
<li>typing.Container</li>
<li>collections.abc.Container</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="gender_render.parse_templates.Chars"><code class="flex name class">
<span>class <span class="ident">Chars</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper to categorize characters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L28-L59" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Chars:
    &#34;&#34;&#34;Helper to categorize characters.&#34;&#34;&#34;
    escape_char = &#34;\\&#34;
    whitespace_chars = &#34;\t\n \u200B&#34;
    special_chars = &#34;:*{}\\&#34;
    ws = &#34;whitespace&#34;
    char = &#34;non-special chars&#34;

    @staticmethod
    def type(c: str) -&gt; str:
        &#34;&#34;&#34;Returns the type of character c, which determines how states in the finite state machine that describes
        gender*render syntax transition to each other.
        This is either Chars.ws (whitespace), a special character or Chars.char (anything else).&#34;&#34;&#34;
        if c in Chars.special_chars:
            return c
        elif c in Chars.whitespace_chars:
            return Chars.ws
        else:
            return Chars.char

    @staticmethod
    def escape_gr_string(s: str, strict: bool = True) -&gt; str:
        &#34;&#34;&#34;Escapes all special gender*render characters in a string, such as {, }, \\, : and *, as well as whitespace,
        with backslashs.
        if `strict` is set to False, only {, } and \\ are escaped; this may be used for strings that are supposed to go
        into gender*render templates, yet not into the inners of the tags themselves.&#34;&#34;&#34;
        i = len(s) - 1
        while i &gt; -1:
            if s[i] in ((Chars.special_chars + Chars.whitespace_chars) if strict else {&#34;\\&#34;, &#34;{&#34;, &#34;}&#34;}):
                s = s[:i] + &#34;\\&#34; + s[i:]
            i -= 1
        return s</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.parse_templates.Chars.escape_char"><code class="name">var <span class="ident">escape_char</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.Chars.whitespace_chars"><code class="name">var <span class="ident">whitespace_chars</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.Chars.special_chars"><code class="name">var <span class="ident">special_chars</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.Chars.ws"><code class="name">var <span class="ident">ws</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.Chars.char"><code class="name">var <span class="ident">char</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.Chars.type"><code class="name flex">
<span>def <span class="ident">type</span></span>(<span>c: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the type of character c, which determines how states in the finite state machine that describes
gender*render syntax transition to each other.
This is either Chars.ws (whitespace), a special character or Chars.char (anything else).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L36-L46" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def type(c: str) -&gt; str:
    &#34;&#34;&#34;Returns the type of character c, which determines how states in the finite state machine that describes
    gender*render syntax transition to each other.
    This is either Chars.ws (whitespace), a special character or Chars.char (anything else).&#34;&#34;&#34;
    if c in Chars.special_chars:
        return c
    elif c in Chars.whitespace_chars:
        return Chars.ws
    else:
        return Chars.char</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.Chars.escape_gr_string"><code class="name flex">
<span>def <span class="ident">escape_gr_string</span></span>(<span>s: str, strict: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Escapes all special gender<em>render characters in a string, such as {, }, \, : and </em>, as well as whitespace,
with backslashs.
if <code>strict</code> is set to False, only {, } and \ are escaped; this may be used for strings that are supposed to go
into gender*render templates, yet not into the inners of the tags themselves.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L48-L59" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def escape_gr_string(s: str, strict: bool = True) -&gt; str:
    &#34;&#34;&#34;Escapes all special gender*render characters in a string, such as {, }, \\, : and *, as well as whitespace,
    with backslashs.
    if `strict` is set to False, only {, } and \\ are escaped; this may be used for strings that are supposed to go
    into gender*render templates, yet not into the inners of the tags themselves.&#34;&#34;&#34;
    i = len(s) - 1
    while i &gt; -1:
        if s[i] in ((Chars.special_chars + Chars.whitespace_chars) if strict else {&#34;\\&#34;, &#34;{&#34;, &#34;}&#34;}):
            s = s[:i] + &#34;\\&#34; + s[i:]
        i -= 1
    return s</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.States"><code class="flex name class">
<span>class <span class="ident">States</span></span>
</code></dt>
<dd>
<div class="desc"><p>Combines values for all sections the finite state machine that describes the syntax can be in, as well as
methods to handle the special escaped/unescaped versions of all states.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L64-L101" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class States:
    &#34;&#34;&#34;Combines values for all sections the finite state machine that describes the syntax can be in, as well as
    methods to handle the special escaped/unescaped versions of all states.&#34;&#34;&#34;

    # Currently, the read character is...
    not_within_tags = &#34;...not part of any tag&#34;

    in_empty_section = &#34;...in a yet empty section&#34;
    in_not_empty_section = &#34;...in a not anymore empty section&#34;
    in_section_with_one_finished_word = &#34;...in a section which already contains a finished word&#34;

    in_empty_value_section = &#34;...in a yet empty value section&#34;
    in_not_empty_value_section = &#34;...in a not empty value section&#34;

    escaped = &#34;...and escaped&#34;

    @staticmethod
    def escape(state: str) -&gt; str:
        &#34;&#34;&#34;Converts an unescaped state to its escaped equivalent.&#34;&#34;&#34;
        assert not States.is_escaped(state)
        return state + States.escaped

    @staticmethod
    def unescape(state: str) -&gt; str:
        &#34;&#34;&#34;Convert an escaped state to its unescaped equivalent.&#34;&#34;&#34;
        assert States.is_escaped(state)
        return state[:len(state)-len(States.escaped)]

    @staticmethod
    def is_escaped(state: str) -&gt; bool:
        &#34;&#34;&#34;Checks is the current char is an escaped char.&#34;&#34;&#34;
        return state.endswith(States.escaped)

    @staticmethod
    def switch_escapement(state: str) -&gt; str:
        &#34;&#34;&#34;Returns the escaped or unescaped state of the given state, depending on whether it is currently escaped or
        not.&#34;&#34;&#34;
        return States.escape(state) if not States.is_escaped(state) else States.unescape(state)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.parse_templates.States.not_within_tags"><code class="name">var <span class="ident">not_within_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_empty_section"><code class="name">var <span class="ident">in_empty_section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_not_empty_section"><code class="name">var <span class="ident">in_not_empty_section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_section_with_one_finished_word"><code class="name">var <span class="ident">in_section_with_one_finished_word</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_empty_value_section"><code class="name">var <span class="ident">in_empty_value_section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.in_not_empty_value_section"><code class="name">var <span class="ident">in_not_empty_value_section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="gender_render.parse_templates.States.escaped"><code class="name">var <span class="ident">escaped</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.States.escape"><code class="name flex">
<span>def <span class="ident">escape</span></span>(<span>state: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts an unescaped state to its escaped equivalent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L80-L84" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def escape(state: str) -&gt; str:
    &#34;&#34;&#34;Converts an unescaped state to its escaped equivalent.&#34;&#34;&#34;
    assert not States.is_escaped(state)
    return state + States.escaped</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.States.unescape"><code class="name flex">
<span>def <span class="ident">unescape</span></span>(<span>state: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an escaped state to its unescaped equivalent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L86-L90" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def unescape(state: str) -&gt; str:
    &#34;&#34;&#34;Convert an escaped state to its unescaped equivalent.&#34;&#34;&#34;
    assert States.is_escaped(state)
    return state[:len(state)-len(States.escaped)]</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.States.is_escaped"><code class="name flex">
<span>def <span class="ident">is_escaped</span></span>(<span>state: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks is the current char is an escaped char.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L92-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def is_escaped(state: str) -&gt; bool:
    &#34;&#34;&#34;Checks is the current char is an escaped char.&#34;&#34;&#34;
    return state.endswith(States.escaped)</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.States.switch_escapement"><code class="name flex">
<span>def <span class="ident">switch_escapement</span></span>(<span>state: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the escaped or unescaped state of the given state, depending on whether it is currently escaped or
not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L97-L101" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def switch_escapement(state: str) -&gt; str:
    &#34;&#34;&#34;Returns the escaped or unescaped state of the given state, depending on whether it is currently escaped or
    not.&#34;&#34;&#34;
    return States.escape(state) if not States.is_escaped(state) else States.unescape(state)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.StateTransitioner"><code class="flex name class">
<span>class <span class="ident">StateTransitioner</span></span>
</code></dt>
<dd>
<div class="desc"><p>Translates between states using a finite state machine.
This does not take into account the ability to escape characters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L106-L185" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StateTransitioner:
    &#34;&#34;&#34;Translates between states using a finite state machine.
    This does not take into account the ability to escape characters.&#34;&#34;&#34;

    state_transitions: Dict[str, Dict[str, Tuple[str, Callable[[ParsedTemplate, str], ParsedTemplate]]]] = {
        States.not_within_tags: {
            &#34;{&#34;: (States.in_empty_section,
                lambda r, c: r+[[(&#34;&#34;, [])]]),
            Chars.char: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c]),
            Chars.ws: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c]),
            &#34;:&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c]),
            &#34;*&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1]+c])
        },
        States.in_empty_section: {
            Chars.ws: (States.in_empty_section,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0]+c, r[-1][-1][1])]])
        },
        States.in_not_empty_section: {
            &#34;:&#34;: (States.in_empty_value_section,
                lambda r, c: r),
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]])], &#34;&#34;]),
            Chars.ws: (States.in_section_with_one_finished_word,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0]+c, r[-1][-1][1])]])
        },
        States.in_section_with_one_finished_word: {
            &#34;:&#34;: (States.in_empty_value_section,
                lambda r, c: r),
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]]), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0]])], &#34;&#34;]),
            Chars.ws: (States.in_section_with_one_finished_word,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(&#34;&#34;, [r[-1][-1][0], c])]])
        },
        States.in_empty_value_section: {
            Chars.ws: (States.in_empty_value_section,
                lambda r, c: r),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1][:-1]+[
                    ((r[-1][-1][1][-1]+c) if len(r[-1][-1][1]) &gt; 0 else c)
                ])]])
        },
        States.in_not_empty_value_section: {
            &#34;*&#34;: (States.in_empty_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], (r[-1][-1][1]
                       if r[-1][-1][1][-1] != &#34;&#34; else r[-1][-1][1][:-1])), (&#34;&#34;, [])]]),
            &#34;}&#34;: (States.not_within_tags,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1]
                       if r[-1][-1][1][-1] != &#34;&#34; else r[-1][-1][1][:-1])]]+[&#34;&#34;]),
            Chars.ws: (States.in_not_empty_value_section,
                lambda r, c: r[:-1] + [r[-1][:-1] + [(r[-1][-1][0], r[-1][-1][1]
                       + ([&#34;&#34;] if r[-1][-1][1][-1] != &#34;&#34; else []))]]),
            Chars.char: (States.in_not_empty_value_section,
                lambda r, c: r[:-1]+[r[-1][:-1]+[(r[-1][-1][0], r[-1][-1][1][:-1]+[(r[-1][-1][1][-1]+c)])]])
        }
    }

    @staticmethod
    def transition_state(state: str, char: str) -&gt; Tuple[str, Callable[[ParsedTemplate, str], ParsedTemplate]]:
        &#34;&#34;&#34;For a given state s and a given character c, returns the next state s2 and a function that takes a
        list representation of the already-parsed data and c and returns a modified, extended duplicate of the data
        based on c.&#34;&#34;&#34;
        type_of_char = Chars.type(char)
        if type_of_char in StateTransitioner.state_transitions[state]:
            return StateTransitioner.state_transitions[state][type_of_char]
        else:
            raise errors.SyntaxError(&#34;Parsing error: \&#34;&#34; + type_of_char + &#34;\&#34; may not occur if it is &#34; + state[3:])</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.parse_templates.StateTransitioner.state_transitions"><code class="name">var <span class="ident">state_transitions</span> : Dict[str, Dict[str, Tuple[str, Callable[[<a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]], str], <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.StateTransitioner.transition_state"><code class="name flex">
<span>def <span class="ident">transition_state</span></span>(<span>state: str, char: str) ‑> Tuple[str, Callable[[<a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]], str], <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>For a given state s and a given character c, returns the next state s2 and a function that takes a
list representation of the already-parsed data and c and returns a modified, extended duplicate of the data
based on c.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L176-L185" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def transition_state(state: str, char: str) -&gt; Tuple[str, Callable[[ParsedTemplate, str], ParsedTemplate]]:
    &#34;&#34;&#34;For a given state s and a given character c, returns the next state s2 and a function that takes a
    list representation of the already-parsed data and c and returns a modified, extended duplicate of the data
    based on c.&#34;&#34;&#34;
    type_of_char = Chars.type(char)
    if type_of_char in StateTransitioner.state_transitions[state]:
        return StateTransitioner.state_transitions[state][type_of_char]
    else:
        raise errors.SyntaxError(&#34;Parsing error: \&#34;&#34; + type_of_char + &#34;\&#34; may not occur if it is &#34; + state[3:])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.SectionTypes"><code class="flex name class">
<span>class <span class="ident">SectionTypes</span></span>
</code></dt>
<dd>
<div class="desc"><p>Capsules a mapping of priorities to section types and methods to assign section types to un-typed sections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L190-L251" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SectionTypes:
    &#34;&#34;&#34;Capsules a mapping of priorities to section types and methods to assign section types to un-typed sections.&#34;&#34;&#34;

    section_types_w_priorities = [
        (&#34;context&#34;, 1000., True),
        (&#34;id&#34;, 950., False)
    ]
    &#34;&#34;&#34;All supported section types as a list of tuples in the form of (name, priority, can_have_multiple_values)&#34;&#34;&#34;

    @staticmethod
    def section_type_accepts_multiple_values(section_type: str) -&gt; bool:
        &#34;&#34;&#34;Checks whether a section type can have multiple whitespace-separated values.&#34;&#34;&#34;
        return SectionTypes.section_type_exists(section_type) and bool(
            [i for i in range(len(SectionTypes.section_types_w_priorities))
             if SectionTypes.section_types_w_priorities[i][0] == section_type
             and SectionTypes.section_types_w_priorities[i][2] is True]
        )

    @staticmethod
    def section_type_exists(section_type: str) -&gt; bool:
        &#34;&#34;&#34;Checks if a section type exists.&#34;&#34;&#34;
        return bool(
            [i for i in range(len(SectionTypes.section_types_w_priorities))
             if SectionTypes.section_types_w_priorities[i][0] == section_type]
        )

    @staticmethod
    def create_section_types_for_untyped_tag(section_types: List[str]) -&gt; List[str]:
        &#34;&#34;&#34;Receives a list of section types in a tag (in chronological order) and assigns section types to those
        section without a section type, in accordance with the priorities of section types and the specification.
        Returns the typed section type list.
        Raises errors if section matching can not be done, or if no context section could be found.&#34;&#34;&#34;
        result = list()

        # get all explicitly specified section types into a set:
        already_used = set()
        if len(section_types) &gt; len(SectionTypes.section_types_w_priorities):
            raise errors.SyntaxPostprocessingError(&#34;Tag contains more sections than there are section types.&#34;)
        for section_type in filter(lambda x: x != &#34;&#34;, section_types):
            if section_type in already_used:
                raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; used twice in a tag.&#34;)
            elif not SectionTypes.section_type_exists(section_type):
                raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; does not exist.&#34;)
            else:
                already_used.add(section_type)

        # create a section priority queue without these element:
        available_sections_types = [s for s in SectionTypes.section_types_w_priorities if s[0] not in already_used]
        available_sections_types.sort(key=lambda s: s[1])

        # iterate over all declared section types from the left to the right:
        for section_type in reversed(section_types):
            if section_type == &#34;&#34;:
                result.insert(0, available_sections_types.pop()[0])
            else:
                result.insert(0, section_type)

        # raise an error if there is no context value:
        if &#34;context&#34; not in result:
            raise errors.SyntaxPostprocessingError(&#34;Tag misses a \&#34;context\&#34;-section.&#34;)

        return result</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="gender_render.parse_templates.SectionTypes.section_types_w_priorities"><code class="name">var <span class="ident">section_types_w_priorities</span></code></dt>
<dd>
<div class="desc"><p>All supported section types as a list of tuples in the form of (name, priority, can_have_multiple_values)</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.SectionTypes.section_type_accepts_multiple_values"><code class="name flex">
<span>def <span class="ident">section_type_accepts_multiple_values</span></span>(<span>section_type: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a section type can have multiple whitespace-separated values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L199-L206" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def section_type_accepts_multiple_values(section_type: str) -&gt; bool:
    &#34;&#34;&#34;Checks whether a section type can have multiple whitespace-separated values.&#34;&#34;&#34;
    return SectionTypes.section_type_exists(section_type) and bool(
        [i for i in range(len(SectionTypes.section_types_w_priorities))
         if SectionTypes.section_types_w_priorities[i][0] == section_type
         and SectionTypes.section_types_w_priorities[i][2] is True]
    )</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.SectionTypes.section_type_exists"><code class="name flex">
<span>def <span class="ident">section_type_exists</span></span>(<span>section_type: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a section type exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L208-L214" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def section_type_exists(section_type: str) -&gt; bool:
    &#34;&#34;&#34;Checks if a section type exists.&#34;&#34;&#34;
    return bool(
        [i for i in range(len(SectionTypes.section_types_w_priorities))
         if SectionTypes.section_types_w_priorities[i][0] == section_type]
    )</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.SectionTypes.create_section_types_for_untyped_tag"><code class="name flex">
<span>def <span class="ident">create_section_types_for_untyped_tag</span></span>(<span>section_types: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a list of section types in a tag (in chronological order) and assigns section types to those
section without a section type, in accordance with the priorities of section types and the specification.
Returns the typed section type list.
Raises errors if section matching can not be done, or if no context section could be found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L216-L251" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def create_section_types_for_untyped_tag(section_types: List[str]) -&gt; List[str]:
    &#34;&#34;&#34;Receives a list of section types in a tag (in chronological order) and assigns section types to those
    section without a section type, in accordance with the priorities of section types and the specification.
    Returns the typed section type list.
    Raises errors if section matching can not be done, or if no context section could be found.&#34;&#34;&#34;
    result = list()

    # get all explicitly specified section types into a set:
    already_used = set()
    if len(section_types) &gt; len(SectionTypes.section_types_w_priorities):
        raise errors.SyntaxPostprocessingError(&#34;Tag contains more sections than there are section types.&#34;)
    for section_type in filter(lambda x: x != &#34;&#34;, section_types):
        if section_type in already_used:
            raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; used twice in a tag.&#34;)
        elif not SectionTypes.section_type_exists(section_type):
            raise errors.SyntaxPostprocessingError(&#34;Section type \&#34;&#34; + section_type + &#34;\&#34; does not exist.&#34;)
        else:
            already_used.add(section_type)

    # create a section priority queue without these element:
    available_sections_types = [s for s in SectionTypes.section_types_w_priorities if s[0] not in already_used]
    available_sections_types.sort(key=lambda s: s[1])

    # iterate over all declared section types from the left to the right:
    for section_type in reversed(section_types):
        if section_type == &#34;&#34;:
            result.insert(0, available_sections_types.pop()[0])
        else:
            result.insert(0, section_type)

    # raise an error if there is no context value:
    if &#34;context&#34; not in result:
        raise errors.SyntaxPostprocessingError(&#34;Tag misses a \&#34;context\&#34;-section.&#34;)

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.GRParser"><code class="flex name class">
<span>class <span class="ident">GRParser</span></span>
</code></dt>
<dd>
<div class="desc"><p>Unites several static methods of a pipeline for parsing gender<em>render templates from strings into a list format
and refining this representation to the maximum extend possible without additionally seeing the corresponding
gender</em>render pronoun data.</p>
<p>These functions are written to be executed in the order they are called by <code>full_parsing_pipeline</code>, and may or may
not behave as expected when called on a value that didn't go through the other functions first.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L257-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GRParser:
    &#34;&#34;&#34;Unites several static methods of a pipeline for parsing gender*render templates from strings into a list format
    and refining this representation to the maximum extend possible without additionally seeing the corresponding
    gender*render pronoun data.

    These functions are written to be executed in the order they are called by `full_parsing_pipeline`, and may or may
    not behave as expected when called on a value that didn&#39;t go through the other functions first.&#34;&#34;&#34;

    @staticmethod
    def parse_gr_template_from_str(template: str) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a gender*render template as a string and returns it as an easily readable list representation.
        This does only do syntactic parsing in accordance to the defining finite state machine;
        further steps in the parsing pipeline are implemented by other methods of this parser.

        The resulting output is of the following structure:
        * value of a section: represented by lists of strings
        * type of section: represented by a string
        * section: tuple of type representation and value representation
        * tag: list of section representation
        * template: list, where every uneven element represents a tag and every even element is a string

        Special characters are all unescaped in the parsed version of the template.&#34;&#34;&#34;

        result = [&#34;&#34;]
        s = States.not_within_tags
        line_no = 1
        char_no = 1
        # iterate over all characters:
        for i in range(len(template)):
            c = template[i]
            # increment char count for SyntaxError raising:
            if c == &#34;\n&#34;:
                line_no += 1
                char_no = 1
            else:
                char_no += 1

            # log:
            warnings.WarningManager.raise_warning(
                &#34;result: &#34; + str(result) + &#34;\n\n&#34;
                + &#34;c: \&#34;&#34; + c + &#34;\&#34;\n&#34;
                + &#34;s: &#34; + s + &#34;\n&#34;
                + &#34;char type: &#34; + Chars.type(c),
                warnings.GRSyntaxParsingLogging)

            # do the work of the finite state machine:
            type_of_char = Chars.type(c)
            if States.is_escaped(s):
                s = States.unescape(s)
                s, processing_function = StateTransitioner.state_transitions[s][Chars.char]
                result = processing_function(result, c)
            else:
                if type_of_char == Chars.escape_char:
                    s = States.escape(s)
                else:
                    try:
                        s, processing_function = StateTransitioner.transition_state(s, c)
                        result = processing_function(result, c)
                    except errors.SyntaxError:
                        raise errors.SyntaxError(
                            &#34;The given gender*render template has invalid syntax.&#34;,
                            (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[line_no - 1])
                        )

        # raise an error if the template ends unproperly:
        if States.is_escaped(s):
            raise errors.SyntaxError(&#34;The template ends with an unescaped escape character, please escape it.&#34;,
                                     (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))
        elif s != States.not_within_tags:
            raise errors.SyntaxError(&#34;A tag opens, but is not finished properly.&#34;,
                                     (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))

        return result

    @staticmethod
    def assign_types_to_all_sections(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and assigns every section of undefined
        type a section type.&#34;&#34;&#34;
        result = copy.deepcopy(parsed_template)
        for i in range(1, len(result), 2):
            old_section_types: List[str] = [section[0] for section in result[i]]
            new_section_types: List[str] = SectionTypes.create_section_types_for_untyped_tag(old_section_types)
            result[i] = [(new_section_types[s], result[i][s][1]) for s in range(len(new_section_types))]
        return result

    @staticmethod
    def split_tags_with_multiple_context_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and splits every tag into a sequence of
        tags, one for every context value of the tag.
        This assumes that every section was already assigned a type by GRParser.assign_types_to_all_sections, and may
        lead to wrong results otherwise.
        The context section is left the end of the tag by this procedure.&#34;&#34;&#34;
        result = copy.deepcopy(parsed_template)
        for i in reversed(range(1, len(result), 2)):
            tag_without_context_section = [section for section in result[i] if section[0] != &#34;context&#34;]
            tag_but_only_context_section = [section for section in result[i] if section[0] == &#34;context&#34;]

            # split tag into one tag for every context value:
            context_values = tag_but_only_context_section.pop()[1]
            sequence_of_tags = [
                (copy.deepcopy(tag_without_context_section) + [(&#34;context&#34;, [context_value])])
                for context_value in context_values
            ]
            for j in reversed(range(1, len(sequence_of_tags))):
                sequence_of_tags.insert(j, &#34; &#34;)
            result[i:i+1] = sequence_of_tags

        return result

    @staticmethod
    def make_sure_that_sections_dont_exceed_allowed_amount_of_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and raises an error if any tag that
        does not allow multiple values has multiple values. This should always be used before calling
        convert_tags_to_indxable_dicts.
        Returns the given dict afterwards.&#34;&#34;&#34;
        for i in range(len(parsed_template)):
            if i % 2:  # is a tag
                for section_type, section_values in parsed_template[i]:
                    if SectionTypes.section_type_accepts_multiple_values(section_type):
                        continue
                    elif len(section_values) &gt; 1:
                        raise errors.SyntaxPostprocessingError(&#34;Tag no. &#34; + str((i + 1) / 2) + &#34; (\&#34;&#34;
                                                               + ReGRParser.unparse_gr_tag(parsed_template[i])
                                                               + &#34;\&#34;) has multiple values in \&#34;&#34;
                                                               + section_type +
                                                               &#34;\&#34;-section even though this type of section does&#34;
                                                               + &#34; not support this.&#34;)
        return parsed_template

    @staticmethod
    def convert_tags_to_indexable_dicts(parsed_template: ParsedTemplate) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and converts every tag from a
        representation a la &#34;[(a, b), (c, d)]&#34; to a representation a la &#34;{a: b, c: d}&#34;.
        This makes the value of specific types of sections easier to access by other methods.
        Note that the result returned by this method is different in that it is not accepted by the other methods of
        GRParser, and that this method should thus be the last method in this pipeline to be used.
        Raises an error if a section has multiple values yet accepts only one.&#34;&#34;&#34;
        result = copy.deepcopy(parsed_template)
        for i in range(len(result)):
            if i % 2:  # is a tag
                new_tag = dict()
                for section_type, section_values in result[i]:
                    if not SectionTypes.section_type_accepts_multiple_values(section_type) or section_type == &#34;context&#34;:
                        new_tag[section_type] = section_values[0]
                    else:
                        new_tag[section_type] = section_values
                result[i] = new_tag

        return result

    @staticmethod
    def convert_context_values_to_canonicals(parsed_template: ParsedTemplateRefined) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Converts a parsed template as returned by GRParser.convert_tags_to_indexable_dicts to a parsed template
        where every context value is canonical.&#34;&#34;&#34;
        result = copy.deepcopy(parsed_template)
        for i in range(1, len(parsed_template), 2):
            result[i][&#34;context&#34;] = handle_context_values.ContextValues.get_canonical(result[i][&#34;context&#34;])
        return result

    @staticmethod
    def full_parsing_pipeline(template: str) -&gt; ParsedTemplateRefined:
        &#34;&#34;&#34;Walks template through the full parsing pipeline defined by GRParser, and returns the result.&#34;&#34;&#34;
        template = GRParser.parse_gr_template_from_str(template)
        template = GRParser.assign_types_to_all_sections(template)
        template = GRParser.split_tags_with_multiple_context_values(template)
        template = GRParser.make_sure_that_sections_dont_exceed_allowed_amount_of_values(template)
        template = GRParser.convert_tags_to_indexable_dicts(template)
        template = GRParser.convert_context_values_to_canonicals(template)
        return template

    @staticmethod
    def get_all_specified_id_values(parsed_template: ParsedTemplateRefined) -&gt; FrozenSet[str]:
        &#34;&#34;&#34;Returns a frozen set of all id values explicitly specified by tags in the parsed template.&#34;&#34;&#34;
        return frozenset(
            parsed_template[i][&#34;id&#34;] for i in range(1, len(parsed_template), 2) if &#34;id&#34; in parsed_template[i]
        )

    @staticmethod
    def template_contains_unspecified_ids(parsed_template: ParsedTemplateRefined) -&gt; bool:
        &#34;&#34;&#34;Returns whether the parsed template contains tags with unspecified id value.&#34;&#34;&#34;
        return bool(list(
            parsed_template[i] for i in range(1, len(parsed_template), 2) if &#34;id&#34; not in parsed_template[i]
        ))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.GRParser.parse_gr_template_from_str"><code class="name flex">
<span>def <span class="ident">parse_gr_template_from_str</span></span>(<span>template: str) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a gender*render template as a string and returns it as an easily readable list representation.
This does only do syntactic parsing in accordance to the defining finite state machine;
further steps in the parsing pipeline are implemented by other methods of this parser.</p>
<p>The resulting output is of the following structure:
* value of a section: represented by lists of strings
* type of section: represented by a string
* section: tuple of type representation and value representation
* tag: list of section representation
* template: list, where every uneven element represents a tag and every even element is a string</p>
<p>Special characters are all unescaped in the parsed version of the template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L265-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def parse_gr_template_from_str(template: str) -&gt; ParsedTemplate:
    &#34;&#34;&#34;Takes a gender*render template as a string and returns it as an easily readable list representation.
    This does only do syntactic parsing in accordance to the defining finite state machine;
    further steps in the parsing pipeline are implemented by other methods of this parser.

    The resulting output is of the following structure:
    * value of a section: represented by lists of strings
    * type of section: represented by a string
    * section: tuple of type representation and value representation
    * tag: list of section representation
    * template: list, where every uneven element represents a tag and every even element is a string

    Special characters are all unescaped in the parsed version of the template.&#34;&#34;&#34;

    result = [&#34;&#34;]
    s = States.not_within_tags
    line_no = 1
    char_no = 1
    # iterate over all characters:
    for i in range(len(template)):
        c = template[i]
        # increment char count for SyntaxError raising:
        if c == &#34;\n&#34;:
            line_no += 1
            char_no = 1
        else:
            char_no += 1

        # log:
        warnings.WarningManager.raise_warning(
            &#34;result: &#34; + str(result) + &#34;\n\n&#34;
            + &#34;c: \&#34;&#34; + c + &#34;\&#34;\n&#34;
            + &#34;s: &#34; + s + &#34;\n&#34;
            + &#34;char type: &#34; + Chars.type(c),
            warnings.GRSyntaxParsingLogging)

        # do the work of the finite state machine:
        type_of_char = Chars.type(c)
        if States.is_escaped(s):
            s = States.unescape(s)
            s, processing_function = StateTransitioner.state_transitions[s][Chars.char]
            result = processing_function(result, c)
        else:
            if type_of_char == Chars.escape_char:
                s = States.escape(s)
            else:
                try:
                    s, processing_function = StateTransitioner.transition_state(s, c)
                    result = processing_function(result, c)
                except errors.SyntaxError:
                    raise errors.SyntaxError(
                        &#34;The given gender*render template has invalid syntax.&#34;,
                        (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[line_no - 1])
                    )

    # raise an error if the template ends unproperly:
    if States.is_escaped(s):
        raise errors.SyntaxError(&#34;The template ends with an unescaped escape character, please escape it.&#34;,
                                 (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))
    elif s != States.not_within_tags:
        raise errors.SyntaxError(&#34;A tag opens, but is not finished properly.&#34;,
                                 (&#34;unknown file&#34;, line_no, char_no, template.split(&#34;\n&#34;)[-1]))

    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.assign_types_to_all_sections"><code class="name flex">
<span>def <span class="ident">assign_types_to_all_sections</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template (as it is created by all methods of GRParser) and assigns every section of undefined
type a section type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L331-L340" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def assign_types_to_all_sections(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
    &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and assigns every section of undefined
    type a section type.&#34;&#34;&#34;
    result = copy.deepcopy(parsed_template)
    for i in range(1, len(result), 2):
        old_section_types: List[str] = [section[0] for section in result[i]]
        new_section_types: List[str] = SectionTypes.create_section_types_for_untyped_tag(old_section_types)
        result[i] = [(new_section_types[s], result[i][s][1]) for s in range(len(new_section_types))]
    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.split_tags_with_multiple_context_values"><code class="name flex">
<span>def <span class="ident">split_tags_with_multiple_context_values</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template (as it is created by all methods of GRParser) and splits every tag into a sequence of
tags, one for every context value of the tag.
This assumes that every section was already assigned a type by GRParser.assign_types_to_all_sections, and may
lead to wrong results otherwise.
The context section is left the end of the tag by this procedure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L342-L364" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def split_tags_with_multiple_context_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
    &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and splits every tag into a sequence of
    tags, one for every context value of the tag.
    This assumes that every section was already assigned a type by GRParser.assign_types_to_all_sections, and may
    lead to wrong results otherwise.
    The context section is left the end of the tag by this procedure.&#34;&#34;&#34;
    result = copy.deepcopy(parsed_template)
    for i in reversed(range(1, len(result), 2)):
        tag_without_context_section = [section for section in result[i] if section[0] != &#34;context&#34;]
        tag_but_only_context_section = [section for section in result[i] if section[0] == &#34;context&#34;]

        # split tag into one tag for every context value:
        context_values = tag_but_only_context_section.pop()[1]
        sequence_of_tags = [
            (copy.deepcopy(tag_without_context_section) + [(&#34;context&#34;, [context_value])])
            for context_value in context_values
        ]
        for j in reversed(range(1, len(sequence_of_tags))):
            sequence_of_tags.insert(j, &#34; &#34;)
        result[i:i+1] = sequence_of_tags

    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.make_sure_that_sections_dont_exceed_allowed_amount_of_values"><code class="name flex">
<span>def <span class="ident">make_sure_that_sections_dont_exceed_allowed_amount_of_values</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template (as it is created by all methods of GRParser) and raises an error if any tag that
does not allow multiple values has multiple values. This should always be used before calling
convert_tags_to_indxable_dicts.
Returns the given dict afterwards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L366-L384" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def make_sure_that_sections_dont_exceed_allowed_amount_of_values(parsed_template: ParsedTemplate) -&gt; ParsedTemplate:
    &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and raises an error if any tag that
    does not allow multiple values has multiple values. This should always be used before calling
    convert_tags_to_indxable_dicts.
    Returns the given dict afterwards.&#34;&#34;&#34;
    for i in range(len(parsed_template)):
        if i % 2:  # is a tag
            for section_type, section_values in parsed_template[i]:
                if SectionTypes.section_type_accepts_multiple_values(section_type):
                    continue
                elif len(section_values) &gt; 1:
                    raise errors.SyntaxPostprocessingError(&#34;Tag no. &#34; + str((i + 1) / 2) + &#34; (\&#34;&#34;
                                                           + ReGRParser.unparse_gr_tag(parsed_template[i])
                                                           + &#34;\&#34;) has multiple values in \&#34;&#34;
                                                           + section_type +
                                                           &#34;\&#34;-section even though this type of section does&#34;
                                                           + &#34; not support this.&#34;)
    return parsed_template</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.convert_tags_to_indexable_dicts"><code class="name flex">
<span>def <span class="ident">convert_tags_to_indexable_dicts</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a parsed template (as it is created by all methods of GRParser) and converts every tag from a
representation a la "[(a, b), (c, d)]" to a representation a la "{a: b, c: d}".
This makes the value of specific types of sections easier to access by other methods.
Note that the result returned by this method is different in that it is not accepted by the other methods of
GRParser, and that this method should thus be the last method in this pipeline to be used.
Raises an error if a section has multiple values yet accepts only one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L386-L405" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def convert_tags_to_indexable_dicts(parsed_template: ParsedTemplate) -&gt; ParsedTemplateRefined:
    &#34;&#34;&#34;Takes a parsed template (as it is created by all methods of GRParser) and converts every tag from a
    representation a la &#34;[(a, b), (c, d)]&#34; to a representation a la &#34;{a: b, c: d}&#34;.
    This makes the value of specific types of sections easier to access by other methods.
    Note that the result returned by this method is different in that it is not accepted by the other methods of
    GRParser, and that this method should thus be the last method in this pipeline to be used.
    Raises an error if a section has multiple values yet accepts only one.&#34;&#34;&#34;
    result = copy.deepcopy(parsed_template)
    for i in range(len(result)):
        if i % 2:  # is a tag
            new_tag = dict()
            for section_type, section_values in result[i]:
                if not SectionTypes.section_type_accepts_multiple_values(section_type) or section_type == &#34;context&#34;:
                    new_tag[section_type] = section_values[0]
                else:
                    new_tag[section_type] = section_values
            result[i] = new_tag

    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.convert_context_values_to_canonicals"><code class="name flex">
<span>def <span class="ident">convert_context_values_to_canonicals</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a parsed template as returned by GRParser.convert_tags_to_indexable_dicts to a parsed template
where every context value is canonical.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L407-L414" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def convert_context_values_to_canonicals(parsed_template: ParsedTemplateRefined) -&gt; ParsedTemplateRefined:
    &#34;&#34;&#34;Converts a parsed template as returned by GRParser.convert_tags_to_indexable_dicts to a parsed template
    where every context value is canonical.&#34;&#34;&#34;
    result = copy.deepcopy(parsed_template)
    for i in range(1, len(parsed_template), 2):
        result[i][&#34;context&#34;] = handle_context_values.ContextValues.get_canonical(result[i][&#34;context&#34;])
    return result</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.full_parsing_pipeline"><code class="name flex">
<span>def <span class="ident">full_parsing_pipeline</span></span>(<span>template: str) ‑> <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Walks template through the full parsing pipeline defined by GRParser, and returns the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L416-L425" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def full_parsing_pipeline(template: str) -&gt; ParsedTemplateRefined:
    &#34;&#34;&#34;Walks template through the full parsing pipeline defined by GRParser, and returns the result.&#34;&#34;&#34;
    template = GRParser.parse_gr_template_from_str(template)
    template = GRParser.assign_types_to_all_sections(template)
    template = GRParser.split_tags_with_multiple_context_values(template)
    template = GRParser.make_sure_that_sections_dont_exceed_allowed_amount_of_values(template)
    template = GRParser.convert_tags_to_indexable_dicts(template)
    template = GRParser.convert_context_values_to_canonicals(template)
    return template</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.get_all_specified_id_values"><code class="name flex">
<span>def <span class="ident">get_all_specified_id_values</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]) ‑> FrozenSet[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a frozen set of all id values explicitly specified by tags in the parsed template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L427-L432" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def get_all_specified_id_values(parsed_template: ParsedTemplateRefined) -&gt; FrozenSet[str]:
    &#34;&#34;&#34;Returns a frozen set of all id values explicitly specified by tags in the parsed template.&#34;&#34;&#34;
    return frozenset(
        parsed_template[i][&#34;id&#34;] for i in range(1, len(parsed_template), 2) if &#34;id&#34; in parsed_template[i]
    )</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.GRParser.template_contains_unspecified_ids"><code class="name flex">
<span>def <span class="ident">template_contains_unspecified_ids</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, Dict[str, Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str], <a title="gender_render.gender_nouns.GenderedNoun" href="gender_nouns.html#gender_render.gender_nouns.GenderedNoun">GenderedNoun</a>]]]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns whether the parsed template contains tags with unspecified id value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L434-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def template_contains_unspecified_ids(parsed_template: ParsedTemplateRefined) -&gt; bool:
    &#34;&#34;&#34;Returns whether the parsed template contains tags with unspecified id value.&#34;&#34;&#34;
    return bool(list(
        parsed_template[i] for i in range(1, len(parsed_template), 2) if &#34;id&#34; not in parsed_template[i]
    ))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gender_render.parse_templates.ReGRParser"><code class="flex name class">
<span>class <span class="ident">ReGRParser</span></span>
</code></dt>
<dd>
<div class="desc"><p>Bundles methods to get a valid gender*render template from ParsedTemplate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L444-L465" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ReGRParser:
    &#34;&#34;&#34;Bundles methods to get a valid gender*render template from ParsedTemplate.&#34;&#34;&#34;

    @staticmethod
    def unparse_gr_tag(tag_representation: List[Tuple[str, List[str]]]) -&gt; str:
        return &#34;{&#34; + &#34;*&#34;.join([(
                            ((Chars.escape_gr_string(section[0]) + &#34;:&#34;) if section[0] else &#34;&#34;)
                            + &#34; &#34;.join([Chars.escape_gr_string(value) for value in section[1]])
                        ) for section in tag_representation]) + &#34;}&#34;

    @staticmethod
    def unparse_gr_template(parsed_template: ParsedTemplate) -&gt; str:
        &#34;&#34;&#34;Takes the result of any method of the GRParser class and returns a template (as a string) that corresponds to
        the given parsed template.
        This may be used for testing purposes or to simplify gender*render templates.&#34;&#34;&#34;
        result = str()
        for i in range(len(parsed_template)):
            if i % 2:  # is a tag
                result += ReGRParser.unparse_gr_tag(parsed_template[i])
            else:  # is a string
                result += Chars.escape_gr_string(parsed_template[i], strict=False)
        return result</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="gender_render.parse_templates.ReGRParser.unparse_gr_tag"><code class="name flex">
<span>def <span class="ident">unparse_gr_tag</span></span>(<span>tag_representation: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L447-L452" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def unparse_gr_tag(tag_representation: List[Tuple[str, List[str]]]) -&gt; str:
    return &#34;{&#34; + &#34;*&#34;.join([(
                        ((Chars.escape_gr_string(section[0]) + &#34;:&#34;) if section[0] else &#34;&#34;)
                        + &#34; &#34;.join([Chars.escape_gr_string(value) for value in section[1]])
                    ) for section in tag_representation]) + &#34;}&#34;</code></pre>
</details>
</dd>
<dt id="gender_render.parse_templates.ReGRParser.unparse_gr_template"><code class="name flex">
<span>def <span class="ident">unparse_gr_template</span></span>(<span>parsed_template: <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Union[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[Tuple[str, <a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a>[str]]]]]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Takes the result of any method of the GRParser class and returns a template (as a string) that corresponds to
the given parsed template.
This may be used for testing purposes or to simplify gender*render templates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/phseiff/gender-render/tree/gh-pages/gender_render/parse_templates.py#L454-L465" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def unparse_gr_template(parsed_template: ParsedTemplate) -&gt; str:
    &#34;&#34;&#34;Takes the result of any method of the GRParser class and returns a template (as a string) that corresponds to
    the given parsed template.
    This may be used for testing purposes or to simplify gender*render templates.&#34;&#34;&#34;
    result = str()
    for i in range(len(parsed_template)):
        if i % 2:  # is a tag
            result += ReGRParser.unparse_gr_tag(parsed_template[i])
        else:  # is a string
            result += Chars.escape_gr_string(parsed_template[i], strict=False)
    return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="gender*render home" href="https://phseiff.com/gender-render">
<img src="https://phseiff.com/gender-render/docs/images/header-logo.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gender_render" href="index.html">gender_render</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a></code></h4>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.List" href="#gender_render.parse_templates.List">List</a></code></h4>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.Chars" href="#gender_render.parse_templates.Chars">Chars</a></code></h4>
<ul class="two-column">
<li><code><a title="gender_render.parse_templates.Chars.type" href="#gender_render.parse_templates.Chars.type">type</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.escape_gr_string" href="#gender_render.parse_templates.Chars.escape_gr_string">escape_gr_string</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.escape_char" href="#gender_render.parse_templates.Chars.escape_char">escape_char</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.whitespace_chars" href="#gender_render.parse_templates.Chars.whitespace_chars">whitespace_chars</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.special_chars" href="#gender_render.parse_templates.Chars.special_chars">special_chars</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.ws" href="#gender_render.parse_templates.Chars.ws">ws</a></code></li>
<li><code><a title="gender_render.parse_templates.Chars.char" href="#gender_render.parse_templates.Chars.char">char</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.States" href="#gender_render.parse_templates.States">States</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.States.escape" href="#gender_render.parse_templates.States.escape">escape</a></code></li>
<li><code><a title="gender_render.parse_templates.States.unescape" href="#gender_render.parse_templates.States.unescape">unescape</a></code></li>
<li><code><a title="gender_render.parse_templates.States.is_escaped" href="#gender_render.parse_templates.States.is_escaped">is_escaped</a></code></li>
<li><code><a title="gender_render.parse_templates.States.switch_escapement" href="#gender_render.parse_templates.States.switch_escapement">switch_escapement</a></code></li>
<li><code><a title="gender_render.parse_templates.States.not_within_tags" href="#gender_render.parse_templates.States.not_within_tags">not_within_tags</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_empty_section" href="#gender_render.parse_templates.States.in_empty_section">in_empty_section</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_not_empty_section" href="#gender_render.parse_templates.States.in_not_empty_section">in_not_empty_section</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_section_with_one_finished_word" href="#gender_render.parse_templates.States.in_section_with_one_finished_word">in_section_with_one_finished_word</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_empty_value_section" href="#gender_render.parse_templates.States.in_empty_value_section">in_empty_value_section</a></code></li>
<li><code><a title="gender_render.parse_templates.States.in_not_empty_value_section" href="#gender_render.parse_templates.States.in_not_empty_value_section">in_not_empty_value_section</a></code></li>
<li><code><a title="gender_render.parse_templates.States.escaped" href="#gender_render.parse_templates.States.escaped">escaped</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.StateTransitioner" href="#gender_render.parse_templates.StateTransitioner">StateTransitioner</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.StateTransitioner.transition_state" href="#gender_render.parse_templates.StateTransitioner.transition_state">transition_state</a></code></li>
<li><code><a title="gender_render.parse_templates.StateTransitioner.state_transitions" href="#gender_render.parse_templates.StateTransitioner.state_transitions">state_transitions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.SectionTypes" href="#gender_render.parse_templates.SectionTypes">SectionTypes</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.SectionTypes.section_type_accepts_multiple_values" href="#gender_render.parse_templates.SectionTypes.section_type_accepts_multiple_values">section_type_accepts_multiple_values</a></code></li>
<li><code><a title="gender_render.parse_templates.SectionTypes.section_type_exists" href="#gender_render.parse_templates.SectionTypes.section_type_exists">section_type_exists</a></code></li>
<li><code><a title="gender_render.parse_templates.SectionTypes.create_section_types_for_untyped_tag" href="#gender_render.parse_templates.SectionTypes.create_section_types_for_untyped_tag">create_section_types_for_untyped_tag</a></code></li>
<li><code><a title="gender_render.parse_templates.SectionTypes.section_types_w_priorities" href="#gender_render.parse_templates.SectionTypes.section_types_w_priorities">section_types_w_priorities</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.GRParser" href="#gender_render.parse_templates.GRParser">GRParser</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.GRParser.parse_gr_template_from_str" href="#gender_render.parse_templates.GRParser.parse_gr_template_from_str">parse_gr_template_from_str</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.assign_types_to_all_sections" href="#gender_render.parse_templates.GRParser.assign_types_to_all_sections">assign_types_to_all_sections</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.split_tags_with_multiple_context_values" href="#gender_render.parse_templates.GRParser.split_tags_with_multiple_context_values">split_tags_with_multiple_context_values</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.make_sure_that_sections_dont_exceed_allowed_amount_of_values" href="#gender_render.parse_templates.GRParser.make_sure_that_sections_dont_exceed_allowed_amount_of_values">make_sure_that_sections_dont_exceed_allowed_amount_of_values</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.convert_tags_to_indexable_dicts" href="#gender_render.parse_templates.GRParser.convert_tags_to_indexable_dicts">convert_tags_to_indexable_dicts</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.convert_context_values_to_canonicals" href="#gender_render.parse_templates.GRParser.convert_context_values_to_canonicals">convert_context_values_to_canonicals</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.full_parsing_pipeline" href="#gender_render.parse_templates.GRParser.full_parsing_pipeline">full_parsing_pipeline</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.get_all_specified_id_values" href="#gender_render.parse_templates.GRParser.get_all_specified_id_values">get_all_specified_id_values</a></code></li>
<li><code><a title="gender_render.parse_templates.GRParser.template_contains_unspecified_ids" href="#gender_render.parse_templates.GRParser.template_contains_unspecified_ids">template_contains_unspecified_ids</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gender_render.parse_templates.ReGRParser" href="#gender_render.parse_templates.ReGRParser">ReGRParser</a></code></h4>
<ul class="">
<li><code><a title="gender_render.parse_templates.ReGRParser.unparse_gr_tag" href="#gender_render.parse_templates.ReGRParser.unparse_gr_tag">unparse_gr_tag</a></code></li>
<li><code><a title="gender_render.parse_templates.ReGRParser.unparse_gr_template" href="#gender_render.parse_templates.ReGRParser.unparse_gr_template">unparse_gr_template</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>